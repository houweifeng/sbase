<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="949.27">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 12.0px 0.0px; line-height: 18.0px; font: 12.0px Times}
    p.p2 {margin: 0.0px 0.0px 12.0px 0.0px; line-height: 18.0px; font: 12.0px STSong}
    span.s1 {font: 12.0px STSong}
    span.s2 {font: 12.0px Lucida Grande}
    span.s3 {font: 12.0px Times}
    span.s4 {font: 12.0px LastResort}
    span.s5 {font: 12.0px Symbol}
  </style>
</head>
<body>
<p class="p1">                <span class="s1">超文本传输<a href="http://www.cnpaf.net/">协议</a></span>-HTTP/1.1</p>
<p class="p2"><span class="s2"><br>
</span>说明<span class="s2"><br>
</span><span class="s3">   </span>本文档规定了互联网社区的标准组<a href="http://www.cnpaf.net/">协议</a>，并需要讨论和建议以便更加完善。请参考<span class="s2"><br>
</span><span class="s3">“</span>互联网官方<a href="http://www.cnpaf.net/">协议</a>标准<span class="s3">”</span>（<span class="s3">STD 1</span>）来了解本<a href="http://www.cnpaf.net/">协议</a>的标准化状态。本<a href="http://www.cnpaf.net/">协议</a>不限流传发布。</p>
<p class="p1"><span class="s1">版权声明</span><span class="s2"><br>
</span>   Copyright (C) The Internet Society (1999).          All Rights Reserved.<span class="s2"><br>
</span><span class="s1">　</span>Copyright  www.cnpaf.net (2007).          All Rights Reserved.</p>
<p class="p2">摘要</p>
<p class="p2">超文本传输<a href="http://www.cnpaf.net/">协议</a>（<span class="s3">HTTP</span>）是一种为分布式，合作式，多媒体信息系统服务，面向<span class="s2"><br>
</span>应用层的<a href="http://www.cnpaf.net/">协议</a>。它是一种通用的，不分状态（<span class="s3">stateless)</span>的<a href="http://www.cnpaf.net/">协议</a>，除了诸如名称服务和分布对象<a href="http://www.cnpaf.net/class/Manage/">管理</a>系统之类的超文本用途外，还可以通过扩展它的请求方式，错误代码和报头<span class="s3">[47]</span>来<span class="s2"><br>
</span>完成许多任务。<span class="s3">HTTP</span>的一个特点是数据表示方式的典型性和可协商性允许独立于传输数据<span class="s2"><br>
</span>而建立系统。<span class="s2"><br>
</span><span class="s3">HTTP</span>在<span class="s3">1990</span>年<span class="s3">WWW</span>全球信息刚刚起步的时候就得到了应用。本说明书详细阐述了<span class="s3">HTTP/1.1</span><span class="s2"><br>
<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>，是<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 2068</span>的修订版<span class="s3">[33]</span>。</p>
<p class="p2">目录（略）</p>
<p class="p1">1 <span class="s1">引论</span></p>
<p class="p1">1.1 <span class="s1">目的</span></p>
<p class="p2">超文本传输<a href="http://www.cnpaf.net/">协议</a>（<span class="s3">HTTP</span>）是一种为分布式，合作式，多媒体信息系统服务，面向应用层的<span class="s2"><br>
<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>。在<span class="s3">1990</span>年<span class="s3">WWW</span>全球信息刚刚起步的时候<span class="s3">HTTP</span>就得到了应用。<span class="s3">HTTP</span>的第一个版本叫做<span class="s3">HTTP/0.9,</span>是一种为互联网原始数据传输服务的简单<a href="http://www.cnpaf.net/">协议</a>。由<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 1945[6]</span>定义的<span class="s3">HTTP/1.0</span>进一步完善了这个<a href="http://www.cnpaf.net/">协议</a>。它允许消息以类似<span class="s3">MIME</span>的格式传送，包括有关数据传输的维护信息和关于请求<span class="s3">/</span>应答的句法修正。但是，<span class="s3">HTTP/1.0</span>没有充分考虑到分层代理，高速缓存的作用以及对稳定连接和虚拟主机的需求。并且随着不完善的进程应用的激<span class="s2"><br>
</span>增，<span class="s3">HTTP/1.0</span>迫切需要一个新的版本<span class="s3">,</span>以便使两个通信应用程序能够确定彼此的真实性能。</p>
<p class="p2">这里规定的<a href="http://www.cnpaf.net/">协议</a>叫做<span class="s3">“HTTP/1.1".</span>这个<a href="http://www.cnpaf.net/">协议</a>与<span class="s3">HTTP/1.0</span>相比，要求更为严格，以确保各项功能得到可靠实现。</p>
<p class="p2">实际的信息系统除了简单的检索外，要求更多的功能性（<span class="s3">functionality)</span>，包括查找<span class="s3">(search)</span>，前端更新<span class="s3">(front-end update)</span>和注解<span class="s3">(annotation)</span>。<span class="s3">HTTP</span>允许可扩充的方法集和报头集以指示请求的目的<span class="s3">[47]</span>。它是建立在统一资源标识符（<span class="s3">URI</span>）<span class="s3">[3]</span>提供的地址（<span class="s3">URL</span>）<span class="s3">[4]</span>和名字（<span class="s3">URN</span>）上<span class="s3">[20]</span>，以指出方法应用于哪个资源的。消息以类似于一种叫做多用途网络邮件扩展（<span class="s3">MIME</span>）<span class="s3">[7] </span>的互联网邮件的格式传送。</p>
<p class="p2"><span class="s3">HTTP</span>也是用于用户代理之间及代理<span class="s3">/</span>网关到其他网络系统的通用通信<a href="http://www.cnpaf.net/">协议</a>，这样的网络系统可能由<a href="http://www.cnpaf.net/class/smtp/"><span class="s3">SMTP</span></a><span class="s3">[16],NNTP[13],<a href="http://www.cnpaf.net/class/ftp/">FTP</a>[18],Gopher[2]</span>和<span class="s3">WAIS[10]<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>支持。这样，<span class="s3">HTTP</span>允许不同的应用程序对资源进行基本的超媒体访问。</p>
<p class="p1">1.2 <span class="s1">要求</span></p>
<p class="p1"><span class="s1">本文的关键词</span>"MUST", "MUST NOT", "REQUIRED", "SHALL","SHALL NOT","SHOULD",<span class="s2"><br>
</span>"SHOULD NOT", "RECOMMENDED", "MAY", <span class="s1">和</span> "OPTIONAL"<span class="s1">将由<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a></span> 2119[34]<span class="s1">解释。</span></p>
<p class="p2">一项进程如果不能满足<a href="http://www.cnpaf.net/">协议</a>提供的一个或多个<span class="s3">MUST</span>或<span class="s3">REQUIRED</span>等级的要求，是不符合要求的。一项进程如果满足所有<span class="s3">MUST</span>或<span class="s3">REQUIRED</span>等级以及所有<span class="s3">SHOULD</span>等级的要求，则被称为<span class="s3">“</span>绝对符合<span class="s3">”</span>（<span class="s3">unconditionally compliant</span>）的；若满足所有<span class="s3">MUST</span>等级的要求但不能满足所有<span class="s3">SHOULD</span>等级的要求则被称为<span class="s3">“</span>部分符合<span class="s3">”</span>（<span class="s3">conditionally compliant</span>）的。</p>
<p class="p1">1.3 <span class="s1">术语</span></p>
<p class="p2">本说明用到了若干术语，以表示<span class="s3">HTTP</span>通信中各参与者和对象扮演的不同角色。</p>
<p class="p2">连接（<span class="s3">Connection</span>）<span class="s2"><br>
</span>为通信而在两个程序间建立的传输层虚拟电路。</p>
<p class="p2">消息<span class="s3">(Message)</span><span class="s2"><br>
</span><span class="s3">HTTP</span>通信中的基本单元。它由一个结构化的八比特字节序列组成，与第<span class="s3">4</span>章定义的句法相匹配，并通过连接得到传送。<span class="s2"><br>
</span><span class="s3">  </span><span class="s2"><br>
</span>请求<span class="s3">(Request)</span><span class="s2"><br>
</span>一种<span class="s3">HTTP</span>请求消息，参看第<span class="s3">5</span>章的定义。<span class="s2"><br>
</span><span class="s3">  </span><span class="s2"><br>
</span>应答<span class="s3">(Response)</span><span class="s2"><br>
</span>一种<span class="s3">HTTP</span>应答消息，参看第<span class="s3">6</span>章的定义。</p>
<p class="p2">资源<span class="s3">(Resource)</span><span class="s2"><br>
</span>一种网络数据对象或服务，可以用第<span class="s3">3.2</span>节定义的<span class="s3">URI</span>描述。资源可以以多种表现方式<span class="s2"><br>
</span>（例如多种语言，数据格式，大小和解决方案）或其他不同的途径获得。</p>
<p class="p2">实体<span class="s3">(Entity)</span><span class="s2"><br>
</span>作为请求或应答的有效负荷而传输的信息<span class="s3">.</span>一个实体包含报头形式的维护信息和消息体形式的内容<span class="s3">,</span>由第<span class="s3">7</span>节详述<span class="s3">.</span></p>
<p class="p2">表示方法<span class="s3">(Representation)</span><span class="s2"><br>
</span>一个应答包含的实体是由内容协商决定的<span class="s3">,</span>如第<span class="s3">12</span>章所述<span class="s3">.</span>一个特定的应答状态所对应的表示方法可能有多个<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">  </span><span class="s2"><br>
</span>内容协商<span class="s3">(Content Negotiation)</span><span class="s2"><br>
</span>为请求服务时选择适当表示方法的机制（<span class="s3">mechanism),</span>如第<span class="s3">12</span>节所述<span class="s3">.</span>任何应答里实体的表示方法都是可协商的<span class="s3">(</span>包括出错应答<span class="s3">).</span></p>
<p class="p2">变量（<span class="s3">Variant)</span><span class="s2"><br>
</span>在任何给定时刻<span class="s3">,</span>与一个资源对应的表示方法可以有一个或更多<span class="s3">.</span>每个表示方法称作一个变量<span class="s3">.</span>使用变量这个术语并不必然意味着资源是由内容协商决定的<span class="s3">.</span></p>
<p class="p2">客户机（<span class="s3">Client</span>）<span class="s2"><br>
</span>为发送请求建立连接的程序<span class="s3">.</span></p>
<p class="p2">用户代理<span class="s3">(User agent)</span><span class="s2"><br>
</span>初始化请求的客户端程序<span class="s3">.</span>常见的如浏览器<span class="s3">,</span>编辑器<span class="s3">,</span>蜘蛛<span class="s3">(</span>网络穿越机器人<span class="s3">),</span>或其他的终端用户工具<span class="s3">.</span></p>
<p class="p2">服务器<span class="s3">(Server)</span><span class="s2"><br>
</span>同意连接以便通过发回应答为请求提供服务的应用程序<span class="s3">.</span>任何给定的程序都有可以既做客户端又做服务器<span class="s3">;</span>我们使用这些术语仅指特定连接中程序完成的任务<span class="s3">,</span>而不是指通常意义上程序的性能<span class="s3">.</span>同样<span class="s3">,</span>任何服务器都可以基于每个请求的性质扮演原服务器<span class="s3">,</span>代理<span class="s3">,</span>网管<span class="s3">,</span>或者隧道等诸角色之一。</p>
<p class="p2">原服务器（<span class="s3">Origin server)</span><span class="s2"><br>
</span>给定的资源驻留或创建的地方<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">  </span><span class="s2"><br>
</span>代理服务器（<span class="s3"> Proxy</span>）<span class="s2"><br>
</span>一个既做服务器又做客户端的中介程序<span class="s3">.,</span>其用途是代表其他客户发送请求<span class="s3">.</span>请求在内部得到服务<span class="s3">,</span>或者经过一定的翻译转至其他服务器<span class="s3">.</span>一个代理服务器必须能同时履行本说明中客户端和服务器要求<span class="s3">.“</span>透明代理<span class="s3">”</span>（<span class="s3">transparent proxy</span>）是一种除了必需的验证和鉴定外不修改请求或相应的代理<span class="s3">.“</span>非透明代理<span class="s3">”</span>（<span class="s3">non-transparent proxy</span>）是一种修改请求或应答以便为用户代理提供附加服务的代理<span class="s3">,</span>附加服务包括类注释服务<span class="s3">,</span>媒体类型转换<span class="s3">,<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>简化<span class="s3">,</span>或者匿名滤除等<span class="s3">.</span>除非经明确指出<span class="s3">,HTTP</span>代理要求对两种代理都适用<span class="s3">.</span></p>
<p class="p2">网关（<span class="s3">gateway</span>）<span class="s2"><br>
</span>为其他服务器充当中介的服务器<span class="s3">.</span>与代理服务器不同<span class="s3">,</span>网关接收请求<span class="s3">,</span>仿佛它就是被请求资源所在的原服务器<span class="s3">;</span>提出请求的客户可能觉察不到它正在同网关通信<span class="s3">.</span><span class="s2"><br>
</span>一个在两个连接之间充当盲目中继（<span class="s3">blind relay)</span>的中间程序<span class="s3">.</span>一旦有效<span class="s3">,</span>隧道便不再被认为是<span class="s3">HTTP</span>通信的用户<span class="s3">,</span>虽然隧道可能已经被<span class="s3">HTTP</span>请求初始化了<span class="s3">.</span>当两端的中继连接都关闭的时候<span class="s3">,</span>隧道不再存在<span class="s3">.</span></p>
<p class="p2">高速缓存（<span class="s3">Cache</span>）<span class="s2"><br>
</span>一个程序应答信息的本地存储和控制此信息存储、检索和删除的子系统<span class="s3">,</span>一个高速缓冲存储器存储应答为的是减少对将来同样请求的应答时间和网络带宽消耗<span class="s3">,</span>任一客户或服务器都可能包含一个高速缓存<span class="s3">,</span>但高速缓存不能应用于一个充当隧道的服务器<span class="s3">.</span></p>
<p class="p2">可缓存（<span class="s3">Cacheable</span>）<span class="s2"><br>
</span><span class="s3">       </span>如果一个高速缓存允许存储应答信息的一份拷贝运用于应答后继请求的拷贝<span class="s3">,</span>一个应答就是可缓存的<span class="s3">.</span>用来确定<span class="s3">HTTP</span>应答的缓存能力（<span class="s3">cacheability</span>）的规则在<span class="s3">13</span>节中有定义<span class="s3">.</span>即使一个资源是可缓存的<span class="s3">,</span>也可能对一个高速缓存能否将缓存拷贝用于某特定请求存在附加的约束<span class="s3">.</span></p>
<p class="p2">直接（<span class="s3">first-hand</span>）<span class="s2"><br>
</span><span class="s3">      </span>如果一个应答直接到来并且没有缘于原服务器<span class="s3">,</span>或若干代理服务器的不必要的延时<span class="s3">,</span>那么这个应答就是直接的<span class="s3">.</span>如果它的有效性已经被原服务器直接认证<span class="s3">,</span>那么这个应答也同样是第一手的<span class="s3">.</span></p>
<p class="p2">明确终止时间（<span class="s3">explicit expiration time</span>）<span class="s3">     </span><span class="s2"><br>
</span>原服务器预算一个实体在无需进一步确认的情况下不再被高速缓存返回的时间<span class="s3">.</span></p>
<p class="p2">探索终止时间（<span class="s3">heuristic expiration time</span>）<span class="s3">      </span><span class="s2"><br>
</span>当没有外在的终止时间可利用时<span class="s3">, </span>由高速缓存所指定的终止时间<span class="s3">.</span></p>
<p class="p2">年龄（<span class="s3">Age</span>）<span class="s2"><br>
</span><span class="s3">     </span>一个应答的年龄是从它被发送<span class="s3">,</span>或被原服务器成功确认到现在的时间<span class="s3">.</span></p>
<p class="p2">保鲜寿命（<span class="s3">Freshness lifetime</span>）<span class="s2"><br>
</span>一个应答生成和过期之间的时间长度<span class="s3">.</span></p>
<p class="p2">保鲜（<span class="s3">Fresh</span>）<span class="s3">    </span><span class="s2"><br>
</span>如果一个应答的年龄还没有超过保鲜寿命<span class="s3">,</span>它就是保鲜的<span class="s3">.</span></p>
<p class="p2">陈旧（<span class="s3">Stale</span>）<span class="s2"><br>
</span><span class="s3">     </span>一个应答的年龄已经超过了它的保鲜寿命<span class="s3">,</span>就是陈旧的<span class="s3">.</span></p>
<p class="p2">语义透明（<span class="s3">semantically transparent</span>）<span class="s2"><br>
</span>当它的使用除了改善性能外既未影响请求客户机也未影响原服务器时<span class="s3">, </span>高速缓存对于某特定的应答就是工作于语义透明方式了<span class="s3">.</span>当高速缓存语义透明时<span class="s3">,</span>客户恰好收到与原服务器直接处理请求后得到的应答（除了逐段转接的报头部分）完全相同的应答。</p>
<p class="p2">有效性判别器（<span class="s3">Validator</span>）<span class="s2"><br>
</span><span class="s3">  </span>一个用来查找一个高速缓存记录是否是一个实体的等效拷贝的<a href="http://www.cnpaf.net/">协议</a>元素<span class="s3">(</span>例如<span class="s3">,</span>一个实体标记（<span class="s3">entity tag</span>）或最终更改时间（<span class="s3">Last-Modified time)).</span></p>
<p class="p2">上游<span class="s3">/</span>下游（<span class="s3">upstream/downstream</span>）<span class="s2"><br>
</span><span class="s3">     </span>上游和下游描述了消息的流动<span class="s3">:</span>所有消息都从上游流到下游<span class="s3">.</span></p>
<p class="p1"><span class="s1">向内</span>/<span class="s1">向外（</span>inbound/outbound<span class="s1">）</span><span class="s2"><br>
</span><span class="s1">向内和向外指的是消息的请求和应答路径</span>:"<span class="s1">向内</span>"<span class="s1">即</span>"<span class="s1">移向原服务器</span>","<span class="s1">向外</span>"<span class="s1">即</span>"<span class="s1">移向用户代理</span>".<span class="s2"><br>
</span><span class="s1">　</span>Copyright  www.cnpaf.net (2007).          All Rights Reserved.</p>
<p class="p2"><span class="s3">1</span>。<span class="s3">4 </span>总体操作</p>
<p class="p2"><span class="s3">HTTP<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>是一种请求<span class="s3">/</span>应答<a href="http://www.cnpaf.net/">协议</a>。<span class="s3"> </span>与主机建立连接后，客户以请求方法，<span class="s3">URI</span>和<a href="http://www.cnpaf.net/">协议</a>版本的形式向服务器发送请求，继以类<span class="s3">MIME</span>信息，其中包括请求修改，客户信息和可能的正文内容。<span class="s2"><br>
</span>服务器用包括消息<a href="http://www.cnpaf.net/">协议</a>版本和成功或错误代码的状态进行应答，继以包括服务器信息，实体维护信息和可能的实体内容的类<span class="s3">MIME</span>消息。<span class="s3">HTTP</span>和<span class="s3">MIME</span>之间的关系如附录<span class="s3">19.4</span>节所阐述。</p>
<p class="p1"><span class="s1">大部分的</span>HTTP<span class="s1">通信由用户代理引发，由应用到一些原服务器上资源的请求构成。最简单的情形，可以经用户代理（</span>UA<span class="s1">）和原服务器（</span>O<span class="s1">）之间的单一连接（</span>v<span class="s1">）完成。请求链</span>------------------------&gt;<span class="s1">用户代理</span>(UA)-------------------<span class="s1">单一连接（</span>v)-------------------<span class="s1">原服务器（</span>O<span class="s1">）</span> &lt;-----------------------<span class="s1">应答链</span></p>
<p class="p2">当一个或一个以上的中介在请求<span class="s3">/</span>应答链中出现的时候，会出现更复杂的情形。常见的中介形式有三种：代理，网关和隧道。代理是一种转送工具，它接收绝对形式的<span class="s3">URI</span>请求，重写全部或部分消息，然后把重新格式化后的请求发送到<span class="s3">URI</span>确定的服务器上。网关是一种接收工具，它充当其他服务器的上层，必要时将请求翻译为下层服务器的<a href="http://www.cnpaf.net/">协议</a>。隧道不改变消息而充当两个连接之间的中继点；它用于通信需要穿过中介（如防火墙），甚至中介不能理解信息内容的时候。<span class="s2"><br>
</span>请求链<span class="s3">--------------------------------------&gt;UA-----v-----A-----v-----B-----v-----C-----v-----O &lt;-------------------------------------</span>应答链</p>
<p class="p2"><span class="s2"><br>
</span>上图显示了用户代理和原服务器之间的三个中介（<span class="s3">A</span>，<span class="s3">B</span>和<span class="s3">C)</span>。游历整条链的请求或应答消息需通过四个独立的连接。这个特性很重要，因为某些<span class="s3">HTTP</span>通信选项只能应用于到最近的非隧道邻居，链的终点的连接，或者沿着链的所有连接。图表尽管是线性的，每部分可能都在忙于多路同时通信。例如，<span class="s3">B</span>可以接收来自不同于<span class="s3">A</span>的许多客户的请求，并且／或者转送到不同于<span class="s3">C</span>的服务器，与此同时，它还在处理<span class="s3">A</span>的请求。</p>
<p class="p2"><span class="s2"><br>
</span>任何非隧道的通信成员都可以使用内部的高速缓存来处理请求。高速缓存的作用是如果沿着链的一个成员对请求采用了高速缓冲的应答，请求<span class="s3">/</span>应答链就会大大缩短。以下图解作为结果产生的链，假定<span class="s3">B</span>拥有来自<span class="s3">O</span>（通过<span class="s3">C</span>）的一个从前应答的备份，请求尚未被<span class="s3">UA</span>或<span class="s3">A</span>缓存。<span class="s2"><br>
</span>请求链<span class="s3">----------&gt;UA-----v----------A-----v-----B-----C----O &lt;---------</span>应答链</p>
<p class="p2">并不是所有的应答都能有效地缓存，一些请求可能含有修改量，对缓存动作有特殊的要求。缓存动作和缓存应答的<span class="s3">HTTP</span>要求将在第<span class="s3">13</span>节定义。</p>
<p class="p2">实际上，目前万维网上有多种结构和配置的高速缓存和代理被实验或使用。这些系统包括节省越洋带宽的全国代理层，广播或多点通信缓存接口，<span class="s3"> </span>通过<span class="s3">CD-ROM</span>分配子缓存数据的机构，等等。<span class="s3">HTTP</span>系统应用在宽频带连接的企业局域网中，通过<span class="s3">PDAs</span>的低耗无线连接和断续连接的访问。<span class="s3">HTTP1.1</span>的目标是支持各种各样的应用配置，引进<a href="http://www.cnpaf.net/">协议</a>结构满足那些需要较高可靠性，可以排除故障或至少指示故障的网络应用的要求。</p>
<p class="p2"><span class="s3">HTTP</span>通信在通常发生在<a href="http://www.cnpaf.net/class/tcpandip/"><span class="s3">TCP</span></a><span class="s3">/</span>ＩＰ连接上。默认端口是<a href="http://www.cnpaf.net/class/tcpandip/"><span class="s3">TCP</span></a><span class="s3"> 80,</span>不过其它端口也可以使用。在互联网或其他网络上，这并不妨碍<span class="s3">HTTP</span>应用在其他<a href="http://www.cnpaf.net/">协议</a>的顶端。<span class="s3">http</span>仅仅期望可靠的传输；任何提供这种保证的<a href="http://www.cnpaf.net/">协议</a>都可以使用；<a href="http://www.cnpaf.net/">协议</a>传输数据单元的<span class="s3">HTTP/1.1</span>请求和应答结构的映象已经超出了本说明书的范围。</p>
<p class="p2">在<span class="s3">http/1.0</span>中，大部分的实现为每个请求<span class="s3">/</span>应答交换使用了新连接。而<span class="s3">http/1.1</span>中，一个连接可以用于一个或更多请求<span class="s3">/</span>应答交换，虽然连接可能会因为各种原因中断（见第<span class="s3">8.1</span>节）。</p>
<p class="p2"><span class="s3">2 </span>符号惯例和一般语法</p>
<p class="p1">2<span class="s1">．</span>1 <span class="s1">扩充</span>BNF</p>
<p class="p2">本文档规定的所有机制都用两种方法描述：散文体（<span class="s3">prose)</span>和类似于<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 822</span>的扩充<span class="s3">Backus-Naur Form(BNF)</span>。要理解本说明书，使用者需熟悉符号表示法。扩充<span class="s3">BNF</span>包括下列结构：</p>
<p class="p2">名字<span class="s3">=</span>定义<span class="s2"><br>
</span>一条规则的名字仅仅是名字本身（没有任何<span class="s3">"&lt;"</span>和<span class="s3">"&gt;"</span>）<span class="s3">,</span>跟等于号<span class="s3">"="</span>后面的定义是分离的。仅当连续线的空格用来表示一条长于一行的规则时空白才是重要的。某些基本规则使用大写字母，如<span class="s3">SP</span>，<span class="s3">LWS</span>，<span class="s3">HT</span>，<span class="s3">CRLF</span>，<span class="s3">DIGIT</span>，<span class="s3">ALPHA</span>，等等。无论何时，只要它们的存在有利于识别规则名字，就可以在定义的范围内使用角括号。</p>
<p class="p2"><span class="s3">“</span>文字<span class="s3">”</span><span class="s2"><br>
</span>文字原文使用引号。除特殊情况，原文对外界不敏感。</p>
<p class="p2">规则<span class="s3">1 | </span>规则<span class="s3">2</span><span class="s2"><br>
</span>由竖线<span class="s3">("|"</span>）分开的元素是可选的，例如，<span class="s3">"yes | no"</span>表示<span class="s3">yes</span>或<span class="s3">no</span>都是可接受的。</p>
<p class="p1"><span class="s1">（规则</span>1 <span class="s1">规则</span>2<span class="s1">）</span><span class="s2"><br>
</span><span class="s1">围在括号里的多个元素视作一个元素。这样</span>“(elem (foo | bar) elem)”<span class="s1">允许标记序列</span>“elem foo elem”<span class="s1">和</span>elem bar elem”<span class="s1">。</span></p>
<p class="p2"><span class="s3">*</span>规则<span class="s2"><br>
</span>前面的字符<span class="s3">"*"</span>表示重复。完整的形式是<span class="s3">"*</span>元素<span class="s3">",</span>表示元素至少出现次，至多出现次。默认值是<span class="s3">0</span>和无穷大，所以<span class="s3">"*(</span>元素<span class="s3">)"</span>允许任何数值，包括零；<span class="s3">"1*</span>元素<span class="s3">"</span>至少需要一次；<span class="s3">"1*2element"</span>允许一次或两次。</p>
<p class="p1"><span class="s2"><br>
</span>[<span class="s1">规则</span>]<span class="s2"><br>
</span><span class="s1">方括号里是任选元素；</span>"[foo bar]"<span class="s1">相当于</span>"*1(foo bar)".</p>
<p class="p2"><span class="s3">N </span>规则<span class="s2"><br>
</span>特殊的重复：<span class="s3">“(</span>元素<span class="s3">)”</span>相当于<span class="s3">“*(</span>元素<span class="s3">)”</span>；<span class="s3"> </span>也就是说，<span class="s3">(</span>元素<span class="s3">)</span>正好出现了次。这样<span class="s3">2DIGIT</span>是一个两位数字，<span class="s3">3ALPHA</span>是一个由三个字符组成的字符串。</p>
<p class="p2"><span class="s3">#</span>规则<span class="s2"><br>
</span>类似于<span class="s3">"*",</span>结构<span class="s3">"#"</span>是用来定义一系列元素的。完整的形式是<span class="s3">"#</span>元素<span class="s3">,</span>表示至少个元素，至多个元素，元素之间被一个或多个逗号<span class="s3">(",")</span>以及可选的线性白色空间<span class="s3">(LWS)</span>隔开了。这就使得列表的一般形式变得非常容易；像<span class="s2"><br>
</span><span class="s3">( *LWS element) *( *LWS ","*LWS element ))</span><span class="s2"><br>
</span>就可以表示为<span class="s2"><br>
</span><span class="s3">1#element</span><span class="s2"><br>
</span>无论在哪里使用这个结构，空元素都是元许的，但是不计入元素出现的次数。换句话说，<span class="s3">“(</span>元素<span class="s3">), , (</span>元素<span class="s3">) "</span>是允许的，但是仅仅视为两个元素。因此，在至少需要一个元素的地方，必须存在至少一个非空元素。默认值是<span class="s3">0</span>和无穷大，这样，<span class="s3">“#element”</span>允许任何数字，包括零；<span class="s3">“1#element”</span>至少需要<span class="s3">1</span>个元素；<span class="s3">“1#2element”</span>允许<span class="s3">1</span>个或<span class="s3">2</span>个元素。</p>
<p class="p2">；注释<span class="s2"><br>
</span>用分号引导的注释，从规则正文的右边一段距离开始直到行尾。这是做注释的简单方法，注释与说明是同样有用的。</p>
<p class="p2">隐含<span class="s3"> *LWS</span><span class="s2"><br>
</span>本说明书所描述的语法是基于字的。除非特别注明，线性空白可出现在任何两个相邻字之间（标记或引用字符串），以及相邻字和间隔符之间，并不改变一个域的含义。任何两个标记之间（下面会对<span class="s3">"token(</span>标记<span class="s3">)"</span>进行定义）必须有至少一个分割符，否则将会被理解为单一标记。</p>
<p class="p2"><span class="s3">2</span>．<span class="s3">2</span>基本规则</p>
<p class="p2">下面的规则描述了基本的解析结构，贯穿于本说明书的全文。<span class="s3">US-ASCII(</span>美国信息交换标准码<span class="s3">)</span>字符规定是由<span class="s3">ANSI X3.4-1986[21]</span>定义的。</p>
<p class="p1"> </p>
<p class="p1">       OCTET          = &lt;<span class="s1">任意八比特的数据序列</span>&gt;<span class="s2"><br>
</span>       CHAR           = &lt;<span class="s1">任意</span>ASCII<span class="s1">字符（八进制</span> 0-127<span class="s1">）</span>&gt;<span class="s2"><br>
</span>       UPALPHA        = &lt;<span class="s1">任意大写字母</span>"A"..."Z"&gt;<span class="s2"><br>
</span>       LOALPHA        = &lt;<span class="s1">任意小写字母</span>"a"..."z"&gt;<span class="s2"><br>
</span>       ALPHA          = UPALPHA | LOALPHA <span class="s2"><br>
</span>       DIGIT          = &lt;<span class="s1">任意数字</span>0<span class="s1">，</span>1<span class="s1">，</span>...9&gt;<span class="s2"><br>
</span>       CTL            = &lt;<span class="s1">任意控制字符</span>(octets 0 - 31)<span class="s1">及删除键</span>DEL<span class="s1">（</span>127<span class="s1">）</span>&gt;<span class="s2"><br>
</span>       CR             = <span class="s2"><br>
</span>       LF             = <span class="s2"><br>
</span>       SP             = <span class="s2"><br>
</span>       HT             = <span class="s2"><br>
</span>       &lt;"&gt;            =</p>
<p class="p2"><span class="s2"><br>
</span><span class="s3">HTTP/1.1</span>将<span class="s3">CR LF</span>的顺序定义为任何<a href="http://www.cnpaf.net/">协议</a>元素的行尾标志，除了报文以外（宽松应用见附录<span class="s3">19.3</span>）<span class="s3">.</span>报文内部的行尾标志是由它的关联媒体类型定义的，如<span class="s3">3.7</span>节所述。</p>
<p class="p1">       CRLF           = CR LF</p>
<p class="p2">如果延长线由空格或水平制表开始，<span class="s3">HTTP/1.1 </span>的报头域值可以折叠到到复合线上。所有的<span class="s2"><br>
</span>线性空白，包括折叠，具有同<span class="s3">SP</span>一样的语义。接收者在解释域值或将消息转送到下游时可以用单个<span class="s3">SP</span>替代任何线性空白。</p>
<p class="p1">       LWS            = [CRLF] 1*( SP | HT )</p>
<p class="p2">文本规则仅仅适用于描述域的内容和不会被消息语法<a href="http://www.cnpaf.net/">分析</a>程序解释的值。<span class="s3">*TEST</span>的字可以<span class="s2"><br>
</span>包含<span class="s3">ISO-8859-1[22]</span>里的字符，也可以包含字符规定里的字符<span class="s3">[14]</span>。</p>
<p class="p1">       TEXT           = &lt;<span class="s1">除</span>CTLs<span class="s1">以外的任意</span>OCTET<span class="s1">，但包括</span>LWS&gt;</p>
<p class="p2">一个<span class="s3">CRLF</span>仅仅在作为报头域延续的一部分时才在<span class="s3">TEXT</span>定义里允许使用。</p>
<p class="p2">十六进制数字字符用在数个<a href="http://www.cnpaf.net/">协议</a>元素里。</p>
<p class="p1">       HEX            = "A" | "B" | "C" | "D" | "E" | "F"<span class="s2"><br>
</span>                      | "a" | "b" | "c" | "d" | "e" | "f" | DIGIT</p>
<p class="p2"><span class="s2"><br>
</span>许多<span class="s3">HTTP/1.1</span>的报头域值是由<span class="s3">LWS</span>或特殊字符分隔的字构成的。这些特殊字符必须包含在引用字符串里，方可用在参数值（如<span class="s3">3.6</span>节定义）里。</p>
<p class="p1">       token  <span class="s1">（标记）</span>        = 1*&lt;<span class="s1">除</span>CTLs<span class="s1">与分割符以外的任意</span> CHAR &gt;<span class="s2"><br>
</span>       separators<span class="s1">（分割符）</span>    = "(" | ")" | "&lt;" | "&gt;" | "@"<span class="s2"><br>
</span>                      | "," | ";" | ":" | "\" | &lt;"&gt;<span class="s2"><br>
</span>                      | "/" | "[" | "]" | "?" | "="<span class="s2"><br>
</span>                      | "{" | "}" | SP | HT</p>
<p class="p2">用圆括号括起来的注释可以包含在一些<span class="s3">HTTP</span>报头域里。只有作为域值定义的一部分时注释才是允许的。在其他域里，圆括号视作域值的一部分。</p>
<p class="p1">       comment <span class="s1">（注释）</span>= "(" *( ctext | quoted-pair | comment ) ")"<span class="s2"><br>
</span>       ctext          = &lt;<span class="s1">除</span>"(" and ")"<span class="s1">以外的任意</span>TEXT &gt;</p>
<p class="p2">一个文本字符若在双引号里，则当作一个字。</p>
<p class="p1">       quoted-string  = ( &lt;"&gt; *(qdtext | quoted-pair ) &lt;"&gt; )<span class="s2"><br>
</span>       qdtext         = &lt;<span class="s1">除</span>&lt;"&gt;<span class="s1">以外的任意</span>TEXT &gt;</p>
<p class="p2">反斜线<span class="s3">("\")</span>可以用作单一字符引用结构，但仅在引用字符串或注释里。</p>
<p class="p1">       quoted-pair    = "\" CHAR</p>
<p class="p1"> </p>
<p class="p2"><span class="s2"><br>
</span><span class="s3">3 <a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>参数</p>
<p class="p1">3.1 HTTP<span class="s1">版本</span><span class="s2"><br>
</span><span class="s1">　</span>Copyright  www.cnpaf.net (2007).          All Rights Reserved.</p>
<p class="p2"><span class="s3">HTTP</span>使用<span class="s3">"&lt;</span>主要<span class="s3">&gt;.&lt;</span>次要<span class="s3">&gt;"</span>的编号方案表示<a href="http://www.cnpaf.net/">协议</a>版本。<a href="http://www.cnpaf.net/">协议</a>的版本方针是希望允许发送者表示消息的格式和性能以便理解更深一层的<span class="s3">HTTP</span>通信，而不仅仅是当前通信获得的特征。消息构件的增加不影响通信动作，或仅仅增加了扩展域值，版本号并没有因此变化。<a href="http://www.cnpaf.net/">协议</a>的改变增加了一些特征，没有改变一般的消息解析规则，但是增加了消息的语义或者暗含了发送者新增的性能，这时<span class="s3">&lt;</span>次要<span class="s3">&gt;</span>数字便要增大。当<a href="http://www.cnpaf.net/">协议</a>的消息格式改变时，<span class="s3">&lt;</span>主要<span class="s3">&gt;</span>数字增大。</p>
<p class="p2"><span class="s3">HTTP</span>消息的版本在消息的第一行<span class="s3">HTTP-</span>版本域里表示。</p>
<p class="p1">       HTTP-Version   = "HTTP" "/" 1*DIGIT "." 1*DIGIT</p>
<p class="p2">注意主要和次要数字必须看作是两个分离的整数，二者都可以增加到比单位数还大。这样，<span class="s3">HTTP/2.4</span>的版本比<span class="s3">HTTP/2.3</span>低，依次<span class="s3">HTTP/2.3</span>的版本比<span class="s3">HTTP/12.3</span>低。首位的零必定被接收者忽视，一定不要发送。</p>
<p class="p2">一个发送包含<span class="s3">HTTP</span>版本<span class="s3">"HTTP/1.1"</span>的请求或应答消息的应用，必须至少有条件的服从本说明书。至少有条件服从本说明书的应用应该在消息里使用<span class="s3">"HTTP/1.1"</span>的<span class="s3">HTTP-</span>版本，任何与<span class="s3"> HTTP/1.0</span>不兼容的消息则必须这样做。关于何时发送特殊的<span class="s3">HTTP-</span>版本值，更多资料请参看<span class="s2"><br>
<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a></span><span class="s3"> 2145[36].</span></p>
<p class="p2">一项应用的<span class="s3">HTTP</span>版本是应用至少有条件服从的最高<span class="s3">HTTP</span>版本<span class="s3">.</span></p>
<p class="p2">代理和网关转送的消息的<a href="http://www.cnpaf.net/">协议</a>版本与应用版本不同时，需要小心。既然<a href="http://www.cnpaf.net/">协议</a>版本表示发送者的<a href="http://www.cnpaf.net/">协议</a>性能，代理<span class="s3">/</span>网关一定不能发送标示版本高于它本身的实际版本的消息。如果收到更高版本的请求，代理<span class="s3">/</span>网关必须降低请求的版本，或者发出出错应答，或者切换到隧道动作。</p>
<p class="p2">由于自<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 2068[33]</span>发布后发现的<span class="s3">HTTP/1.0</span>代理协同工作问题，高速缓存代理必须，网关可以，隧道必须不将请求提升到它们支持的最高版本。代理<span class="s3">/</span>网关的应答的主要版本号必须同请求相同。</p>
<p class="p2">注：<span class="s3">HTTP</span>版本的转换可能会包含相关版本必需或禁止的头域修改。</p>
<p class="p2"><span class="s3">3.2 </span>统一资源标识符（<span class="s3">URI</span>）</p>
<p class="p2"><span class="s3">URIs</span>的许多名字已为人所知：<span class="s3">WWW</span>地址<span class="s3">,</span>通用文件标识符，通用资源标识符<span class="s3">[3]</span>，以及最后统一资源定位器<span class="s3">(URL)[4]</span>和统一资源名称<span class="s3">(URN)[20]</span>的结合。只要与<span class="s3">HTTP</span>相关，统一资源定位器只是格式化的字符串，它通过名称，地址，或任何别的特征确定了资源的位置。</p>
<p class="p1"><span class="s2"><br>
</span>3.2.1 <span class="s1">一般语法</span></p>
<p class="p2"><span class="s2"><br>
</span>根据使用时的上下文，<span class="s3">HTTP</span>里的<span class="s3">URI</span>可以表示成绝对形式或基于已知的<span class="s3">URI</span>的相对形式。两种形式的区别是根据这样的事实：绝对<span class="s3">URI</span>总是以一个摘要名字作为开头，其后是一个冒号。关于<span class="s3">URL</span>更详尽的信息请参看<span class="s3">"</span>统一资源标识符<span class="s3">(URI):</span>一般语法和语义<span class="s3">",<a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 2396 [42](</span>代替了<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3">s 1738 [4]</span>和<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 1808 [11]).</span>本说明书采用那份说明书里关于<span class="s3">"URI-</span>索引<span class="s3">","</span>绝对<span class="s3">URI","</span>相对<span class="s3">URI","</span>端口<span class="s3">","</span>主机<span class="s3">","</span>绝对路径<span class="s3">"</span>和<span class="s3">"</span>权力<span class="s3">"</span>的定义<span class="s3">.</span></p>
<p class="p2"><span class="s3">HTTP<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>不对<span class="s3">URI</span>的长度作事先的限制<span class="s3">.</span>服务器必须能够处理它们服务的任何资源的<span class="s3">URI,</span>并且应该能够处理无限长度的<span class="s3">URI,</span>如果它们提供可以产生这种<span class="s3">URI</span>的基于<span class="s3">GET</span>的形式<span class="s3">.</span></p>
<p class="p2">注<span class="s3">:</span>服务器在依赖长于<span class="s3">255</span>字节的<span class="s3">URI</span>时应谨慎<span class="s3">,</span>因为一些旧的客户或代理实现可能不支持这些长度<span class="s3">.</span></p>
<p class="p1">3.2.2 http URL</p>
<p class="p1">http<span class="s1">方案通过</span>HTTP<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a><span class="s1">定出网络资源的位置</span>.<span class="s1">本节定义了这种方案</span>-http URL<span class="s1">特殊的语法和语义</span>.<span class="s2"><br>
</span>   http_URL = "http:" "//" host [ ":" port ] [ abs_path [ "?" query ]]</p>
<p class="p2">如果端口为空或未给出<span class="s3">,</span>就假定为<span class="s3">80.</span>语义即<span class="s3">:</span>已识别的资源放在服务器上<span class="s3">,</span>在那台主机的那个端口上监听<a href="http://www.cnpaf.net/class/tcpandip/"><span class="s3">TCP</span></a>连接<span class="s3">,</span>对资源的请求的<span class="s3">URI</span>为绝对路径<span class="s3">(5.1.2</span>节<span class="s3">). </span>无论什么可能的时候<span class="s3">,URL</span>里使用<span class="s3">IP</span>地址都是应该避免的<span class="s3">(</span>参看<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 1900 [24]).</span>如果绝对地址没有出现在<span class="s3">URL</span>里<span class="s3">,</span>它用作对资源的请求的<span class="s3">URI</span>时必须作为<span class="s3">"/"</span>给出<span class="s3">.</span>如果代理收到一个不是充分资格域名的主机名<span class="s3">,</span>一定不能改变主机名<span class="s3">.</span></p>
<p class="p1"><span class="s2"><br>
</span>3.2.3 URI <span class="s1">比较</span></p>
<p class="p2">当比较两个<span class="s3">URI</span>是否匹配时<span class="s3">,</span>客户应该对整个<span class="s3">URI</span>进行区分大小写<span class="s3">,</span>以八字节为单元的比较<span class="s3">.</span>以下情况例外<span class="s3">:</span></p>
<p class="p2"><span class="s3">-</span>一个为空或未给定的端口等同于那个<span class="s3">URI</span>索引里的默认端口<span class="s3">;</span></p>
<p class="p2"><span class="s3">-</span>主机名的比较必须是不区分大小写的<span class="s3">;</span></p>
<p class="p2"><span class="s3">-</span>方案名的比较必须是不区分大小写的<span class="s3">;</span></p>
<p class="p2"><span class="s3">-</span>一个空绝对路径等同于绝对路径<span class="s3">"/".</span></p>
<p class="p1">   Characters other than those in the "reserved" and "unsafe" sets are equivalent to their ""%" HEX HEX" encoding.<span class="s2"><br>
</span><span class="s1">除了</span>"<span class="s1">保留</span>"<span class="s1">或</span>"<span class="s1">危险</span>"<span class="s1">集里的字符</span>(<span class="s1">参见<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a></span> 2396 [42]) ,<span class="s1">字符等同于它们的</span>""%" HEX HEX"<span class="s1">编码</span>. </p>
<p class="p2">例如<span class="s3">,</span>以下三个<span class="s3">URI</span>是等同的<span class="s3">:</span></p>
<p class="p1">      <a href="http://abc.com/~smith/home.html">http://abc.com:80/~smith/home.html</a><span class="s2"><br>
</span>      <a href="http://abc.com/~smith/home.html">http://ABC.com/~smith/home.html</a><span class="s2"><br>
</span>      <a href="http://abc.com:/~smith/home.html">http://ABC.com:/~smith/home.html</a></p>
<p class="p2"><span class="s2"><br>
</span><span class="s3">3.3 </span>日期<span class="s3">/</span>时间格式</p>
<p class="p1">3.3.1 <span class="s1">完整日期</span></p>
<p class="p2">历史上的<span class="s3">HTTP</span>应用一直允许三种不同的表示日期<span class="s3">/</span>时间印记的格式<span class="s3">:</span></p>
<p class="p1">      Sun, 06 Nov 1994 08:49:37 GMT  ; <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 822, updated by <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 1123<span class="s2"><br>
</span>      Sunday, 06-Nov-94 08:49:37 GMT ; <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 850, obsoleted by <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 1036<span class="s2"><br>
</span>      Sun Nov  6 08:49:37 1994       ; ANSI C's asctime() format</p>
<p class="p2"><span class="s2"><br>
</span>第一种格式是作为<span class="s3">Internet</span>标准提出来的<span class="s3">,</span>它表示一个由<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 1123 [8](<a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 822[9]</span>的升级版本<span class="s3">)</span>定义的固定长度的子集<span class="s3">.</span>第二种格式使用比较普遍<span class="s3">,</span>但是基于废弃的<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 850 [12],</span>需要<span class="s3">(</span>应该<span class="s3">)</span>用四位数表示年份<span class="s3">.</span>对日期值进行语法<a href="http://www.cnpaf.net/">分析</a>的<span class="s3">HTTP/1.1</span>客户和服务器必须接受所有三种格式<span class="s3">(</span>为了同<span class="s3">HTTP/1.0</span>兼容<span class="s3">),</span>虽然它们必须只产生<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 1123</span>格式以在头域里表示<span class="s3">HTTP</span>日期值<span class="s3">.</span></p>
<p class="p2">注<span class="s3">:</span>鼓励日期值的接收者在接受可能由非<span class="s3">HTTP</span>应用发来的日期值时要坚定<span class="s3">,</span>这种非<span class="s3">HTTP</span>应用有时是通过代理<span class="s3">/</span>网关到<a href="http://www.cnpaf.net/class/smtp/"><span class="s3">SMTP</span></a>或<span class="s3">NNTP</span>检索或张贴消息<span class="s3">.</span></p>
<p class="p1"><span class="s1">所有的</span>HTTP<span class="s1">日期</span>/<span class="s1">时间印记都必须毫无例外的以格林威治平均时间</span>(GMT)<span class="s1">表示</span>.<span class="s1">为了</span>HTTP,GMT<span class="s1">完全等同于</span>UTC(<span class="s1">协调世界时间</span>).<span class="s1">这在前两种形式里用三个字母的时区缩写</span>-GMT<span class="s1">的蕴含来表示</span>,<span class="s1">并且读取</span>ASC<span class="s1">时间格式时必须先被假定</span>.HTTP<span class="s1">日期区分大小写</span>,<span class="s1">除了在语法中作为</span>SP<span class="s1">特别包括的</span>LWS<span class="s1">外</span>,<span class="s1">一定不能包括额外的</span>LWS.<span class="s2"><br>
</span>       HTTP-date    = rfc1123-date | rfc850-date | asctime-date<span class="s2"><br>
</span>       rfc1123-date = wkday "," SP date1 SP time SP "GMT"<span class="s2"><br>
</span>       rfc850-date  = weekday "," SP date2 SP time SP "GMT"<span class="s2"><br>
</span>       asctime-date = wkday SP date3 SP time SP 4DIGIT<span class="s2"><br>
</span>       date1        = 2DIGIT SP month SP 4DIGIT<span class="s2"><br>
</span>                      ; day month year (e.g., 02 Jun 1982)<span class="s2"><br>
</span>       date2        = 2DIGIT "-" month "-" 2DIGIT<span class="s2"><br>
</span>                      ; day-month-year (e.g., 02-Jun-82)<span class="s2"><br>
</span>       date3        = month SP ( 2DIGIT | ( SP 1DIGIT ))<span class="s2"><br>
</span>                      ; month day (e.g., Jun  2)<span class="s2"><br>
</span>       time         = 2DIGIT ":" 2DIGIT ":" 2DIGIT<span class="s2"><br>
</span>                      ; 00:00:00 - 23:59:59<span class="s2"><br>
</span>       wkday        = "Mon" | "Tue" | "Wed"<span class="s2"><br>
</span>                    | "Thu" | "Fri" | "Sat" | "Sun"<span class="s2"><br>
</span>       weekday      = "Monday" | "Tuesday" | "Wednesday"<span class="s2"><br>
</span>                    | "Thursday" | "Friday" | "Saturday" | "Sunday"<span class="s2"><br>
</span>       month        = "Jan" | "Feb" | "Mar" | "Apr"<span class="s2"><br>
</span>                    | "May" | "Jun" | "Jul" | "Aug"<span class="s2"><br>
</span>                    | "Sep" | "Oct" | "Nov" | "Dec"</p>
<p class="p2">注意<span class="s3">:HTTP</span>对日期<span class="s3">/</span>时间印记格式的请求仅仅应用在<a href="http://www.cnpaf.net/">协议</a>流里<span class="s3">.</span>客户和服务器不必为了用户简报<span class="s3">,</span>请求记录及其他而使用这些格式<span class="s3">.</span></p>
<p class="p1">3.3.2 Delta<span class="s1">秒</span></p>
<p class="p1"><span class="s1">一些</span>HTTP<span class="s1">头域收到消息后</span>,<span class="s1">允许以十进制整数秒表示的时间值</span>.<span class="s2"><br>
</span>       delta-seconds  = 1*DIGIT</p>
<p class="p1">3.4 <span class="s1">字符集</span></p>
<p class="p2"><span class="s3">HTTP</span>使用的关于术语<span class="s3">"</span>字符集<span class="s3">"</span>的定义和<span class="s3">MIME</span>中所描述的一样<span class="s3">.</span></p>
<p class="p2">本文档中的术语<span class="s3">"</span>字符集<span class="s3">"</span>指一种用一个或更多表格将一个八字节序列转换成一个字符序列的方法<span class="s3">.</span>注意另一方向的无条件转换是不需要的<span class="s3">,</span>在这种转换里<span class="s3">,</span>并不是所有的字符都能在一个给定字符集里得到<span class="s3">,</span>并且字符集可能提供多个八进制序列表示一个特定字符<span class="s3">.</span>这个定义将允许各种字符编码方式<span class="s3">,</span>从简单的单表格映射如<span class="s3">US-ASCII</span>到复杂的表格交换方法如<span class="s3">ISO-2022</span>的技术里所使用的<span class="s3">.</span>然而<span class="s3">,</span>与<span class="s3">MIME</span>字符集名字相关联的定义必须充分说明从八字节变换到字符所实现的映射<span class="s3">.</span>特别的<span class="s3">,</span>使用外部轮廓信息来决定精确映射是不允许的<span class="s3">.</span></p>
<p class="p2">注<span class="s3">:</span>这里使用的术语<span class="s3">"</span>字符集<span class="s3">"</span>更一般的被称作一种<span class="s3">"</span>字符编码<span class="s3">".</span>不过既然<span class="s3">HTTP</span>和<span class="s3">MIME</span>使用同样的注册表<span class="s3">,</span>共用术语是很重要的<span class="s3">.</span></p>
<p class="p1">HTTP<span class="s1">字符集用不区分大小写的标记表示</span>.<span class="s1">完全标记集合由</span>IANA<span class="s1">字符集注册表</span>[19]<span class="s1">定义</span>.<span class="s2"><br>
</span>       charset = token</p>
<p class="p2">尽管<span class="s3">HTTP</span>允许用任意标记作为字符集的值<span class="s3">,</span>任何在<span class="s3">IANA</span>字符集注册表里有预先确定值的标记必须表示该注册表定义的字符集<span class="s3">.</span>对那些<span class="s3">IANA</span>定义的字符集<span class="s3">,</span>应用应该限制使用字符集<span class="s3">.</span></p>
<p class="p1"><span class="s1">实现者应该注意</span>IETF<span class="s1">字符集的要求</span>[38][41].</p>
<p class="p1">3.4.1 <span class="s1">失踪字符集</span></p>
<p class="p2">一些<span class="s3">HTTP/1.0</span>软件将没有字符集参数的内容类型头错误的理解为<span class="s3">"</span>接收者应该猜猜<span class="s3">."</span>若发送者希望避免这种情况<span class="s3">,</span>可以包含一个字符集参数<span class="s3">,</span>即使字符集是<span class="s3">ISO-8859-1;</span>当知道不会使接收者混淆时<span class="s3">,</span>也应该这样做<span class="s3">.</span></p>
<p class="p2">不幸的是<span class="s3">,</span>一些旧的<span class="s3">HTTP/1.0</span>不能适当处理详细的字符集参数<span class="s3">.HTTP/1.1</span>接收者必须重视发送者提供的字符集标注<span class="s3">;</span>当最初显示文档时，那些提供<span class="s3">"</span>猜<span class="s3">"</span>字符集服务的用户代理必须使用内容类型域中的字符集，如果它们支持那个字符集，而不是接收者的首选项。参看<span class="s3">3.7.1</span>节。</p>
<p class="p1">3.5 <span class="s1">内容编码</span></p>
<p class="p2">内容编码值表示一种已经或可以应用于实体的编码变换。内容编码主要用来允许文档压缩，换句话说，有效的变换而不损失它的基本媒体类型的特性，也不丢失信息。经常地，实体以编码形式储存<span class="s3">,</span>直接传送<span class="s3">,</span>只能由接收者译码<span class="s3">.</span></p>
<p class="p1">       content-coding   = token</p>
<p class="p2">所有内容编码值都是不区分大小写的<span class="s3">.HTTP/1.1</span>在接收译码<span class="s3">(14.3</span>节<span class="s3">)</span>和内容译码<span class="s3">(14.11</span>节<span class="s3">)</span>的头域里使用内容编码值<span class="s3">.</span>尽管该值描述了内容编码<span class="s3">,</span>更重要的是它指出需要什么编码机制<span class="s2"><br>
</span>来除去编码<span class="s3">.</span></p>
<p class="p2">互联网赋值机构<span class="s3">(IANA)</span>充当内容编码值标记的注册处<span class="s3">.</span>最初<span class="s3">,</span>注册表包含下列标记<span class="s3">:</span></p>
<p class="p1">  gzip<span class="s1">（压缩程序）</span> <span class="s2"><br>
</span><span class="s1">一种由文件压缩程序</span>"gzip"(GNU zip)---<span class="s1">如<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a></span> 1952<span class="s1">所描述</span>---<span class="s1">生成的编码格式</span>.<span class="s1">这种格式是一种</span>32<span class="s1">位</span>CRC Lempel-Ziv<span class="s1">编码</span>(LZ77).   [<span class="s1">译者注</span>]CRC:<span class="s1">循环冗余校验</span></p>
<p class="p1">   compress<span class="s1">（压缩）</span><span class="s2"><br>
</span><span class="s1">由通用</span>UNIX<span class="s1">文件压缩程序</span>"compress"<span class="s1">生成的编码格式</span>.<span class="s1">这种格式是一种具有可适应性的</span>Lempel-Ziv-Welch<span class="s1">编码</span>.<span class="s2"><br>
</span><span class="s1">对未来的编码来说</span>,<span class="s1">用程序名识别编码格式是不可取</span>,<span class="s1">令人气馁的</span>.<span class="s1">在这里他们的用处是作为历史实践的代表而不是好的方案</span>.<span class="s1">为了同以前的</span>HTTP<span class="s1">实现相兼容</span>,<span class="s1">应用应该将</span>"x-gzip"<span class="s1">和</span>"x-compress"<span class="s1">分别等同于</span>"gzip"<span class="s1">和</span>"compress".<span class="s2"><br>
</span>   <span class="s2"><br>
</span>   deflate<span class="s1">（缩小）</span><span class="s4"></span><span class="s2"><br>
<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a></span> 1950 [31]<span class="s1">定义的</span>"zlib"<span class="s1">格式与<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a></span> 1951 [29]<span class="s1">描述的</span>"deflate"<span class="s1">压缩机制的组合</span>.</p>
<p class="p2"><span class="s3">   Identity</span>（标识）<span class="s2"><br>
</span><span class="s3">    </span>缺省<span class="s3">(</span>标识<span class="s3">)</span>编码<span class="s3">;</span>无论如何<span class="s3">,</span>不进行转化的应用<span class="s3">.</span>这种内容译码仅被用于接受译码报头<span class="s3">,</span>并且不能被用在内容编码报头<span class="s3">.</span></p>
<p class="p2"><span class="s3">  </span>新的内容译码值的标记应该注册<span class="s3">;</span>为了允许客户和服务器间的互用性<span class="s3">,</span>内容译码运算的规范需要实现一个可被公开利用并能独立实现的新值<span class="s3">,</span>并且与这节中内容译码定义的目的相一致<span class="s3">.</span></p>
<p class="p1">3.6  <span class="s1">传输编码</span></p>
<p class="p1">   <span class="s1">传输编码值被用来表示一个已经</span>,<span class="s1">能够</span>,<span class="s1">或可能需要应用于一个实体的编码转化</span>,<span class="s1">为的是能够确保通过网络<a href="http://www.cnpaf.net/class/security/">安全</a>传输</span>.<span class="s1">这不同于内容译码</span>,<span class="s1">传输译码是消息的特性而不是原始实体的特性</span>.<span class="s2"><br>
</span>       transfer-coding = "chunked" | transfer-extension<span class="s2"><br>
</span>       transfer-extension      = token *( ";" parameter )</p>
<p class="p2"><span class="s3">   </span>参数采用属性<span class="s3">/</span>值对的形式<span class="s3">.</span></p>
<p class="p1">       <span class="s1">参数</span>                   = <span class="s1">属性</span>  "=" <span class="s1">值</span><span class="s2"><br>
</span>       <span class="s1">属性</span>                   = <span class="s1">标记</span><span class="s2"><br>
</span>       <span class="s1">值</span>                     = <span class="s1">标记</span>  |   <span class="s1">引用</span>-<span class="s1">串（</span>quoted-string<span class="s1">）</span></p>
<p class="p2"><span class="s3">   </span>所有传输译码值是不直观的<span class="s3">.HTTP/1.1</span>在<span class="s3">TE</span>头域<span class="s3">(14.39</span>节<span class="s3">)</span>和传输译码头域<span class="s3">(14.41</span>节<span class="s3">)</span>运用传输译码<span class="s3">.</span></p>
<p class="p2"><span class="s3">   </span>无论何时一个传输译码都被应用于一个消息体<span class="s3">,</span>传输译码的设置必须包括<span class="s3">"</span>大块<span class="s3">",</span>除非消息被结束连接停止<span class="s3">.</span>当<span class="s3">"</span>大块<span class="s3">"</span>传输译码被应用时<span class="s3">,</span>它必须是应用于消息体的最后传输译码<span class="s3">.</span>这些规则允许接受从而确定消息的传输长度<span class="s3">(4.4</span>节<span class="s3">)</span></p>
<p class="p2"><span class="s3">   </span>传输译码与<span class="s3">MINE[7]</span>的内容传输译码值相类似<span class="s3">,</span>它被定义能够实现传送服务器超过<span class="s3">7</span>位的二进制数据的<a href="http://www.cnpaf.net/class/security/">安全</a>传输<span class="s3">.</span>不过<span class="s3">,<a href="http://www.cnpaf.net/class/security/"><span class="s1">安全</span></a></span>传输对纯<span class="s3">8</span>位传输<a href="http://www.cnpaf.net/">协议</a>有不同的焦点<span class="s3">.</span>在<span class="s3">HTTP</span>中<span class="s3">,</span>消息体唯一不<a href="http://www.cnpaf.net/class/security/">安全</a>的特性是确定确切的体的长度的这个难点<span class="s3">(7.2.2</span>节<span class="s3">),</span>或在共享传输上加密的要求<span class="s3">.</span></p>
<p class="p1">   <span class="s1">网络分配数字权威</span>(IANA)<span class="s1">担任了传输译码值标记注册处的角色</span>.<span class="s1">起初</span>,<span class="s1">注册包含如下标记</span>:"<span class="s1">大块</span>"(3.6.1<span class="s1">节</span>),"<span class="s1">身份</span>"(3.6.2<span class="s1">节</span>),"gzip"(3.5<span class="s1">节</span>),"<span class="s1">压缩</span>"(3.5<span class="s1">节</span>),<span class="s1">和</span>"<span class="s1">缩小</span>"(3.5<span class="s1">节</span>).</p>
<p class="p2"><span class="s3">   </span>新的传输译码值标记应和新的内容译码值标记以相同的方式注册<span class="s3">(3.5</span>节<span class="s3">).</span></p>
<p class="p2">服务器接收到一个不能理解的传输译码实体时应返回<span class="s3">501(</span>不实现<span class="s3">),</span>并且切断联系<span class="s3">.</span>服务器不能向<span class="s3">HTTP/1.0</span>客户发送传输译码<span class="s3">.</span></p>
<p class="p1">3.6.1 <span class="s1">成块传输代码（</span>Chunked Transfer Coding<span class="s1">）</span></p>
<p class="p1">   <span class="s1">成块编码更改消息主体</span>,<span class="s1">为的是将它以一系列大块的形式传送</span>,<span class="s1">每一个连同它自己尺寸的指示器</span>,<span class="s1">被一个包含实体头域的可随意选择的</span>trailer<span class="s1">跟随</span>.<span class="s1">这允许有力量的地生产同接受所必需的消息一起转化的内容</span>,<span class="s1">从而检验它已经获得全部消息</span>.<span class="s2"><br>
</span>       Chunked-Body   = *chunk(<span class="s1">大块</span>)<span class="s2"><br>
</span>       <span class="s1">大块</span>-<span class="s1">正文</span>           last-chunk(<span class="s1">最后</span>-<span class="s1">大块</span>)<span class="s2"><br>
</span>                        trailer(<span class="s1">追踪者</span>)<span class="s2"><br>
</span>                        CRLF</p>
<p class="p1">       chunk          = chunk-size [ chunk-extension ] CRLF<span class="s2"><br>
</span>        <span class="s1">大块</span>          =  <span class="s1">大块</span>-<span class="s1">尺寸</span> [ <span class="s1">大块</span> -<span class="s1">扩展</span>]CRLF<span class="s2"><br>
</span>                        chunk-data CRLF<span class="s2"><br>
</span>                         <span class="s1">大块</span>-<span class="s1">数据</span> CRLF<span class="s2"><br>
</span>       chunk-size     = 1*HEX<span class="s2"><br>
</span>       <span class="s1">大块数据</span><span class="s2"><br>
</span>       last-chunk     = 1*("0") [ chunk-extension ] CRLF<span class="s2"><br>
</span>        <span class="s1">最后</span>-<span class="s1">大块</span>     = 1*("0") [<span class="s1">大块</span>-<span class="s1">扩展</span>]CRLF            </p>
<p class="p1">       chunk-extension= *( ";" chunk-ext-name [ "=" chunk-ext-val ] )<span class="s2"><br>
</span>       <span class="s1">大块</span>-<span class="s1">扩展</span>                <span class="s1">大块</span>-<span class="s1">外部</span>-<span class="s1">名称</span>      <span class="s1">大块</span>-<span class="s1">外部</span>-<span class="s1">值</span><span class="s2"><br>
</span>       chunk-ext-name = token<span class="s2"><br>
</span>        <span class="s1">大块</span>-<span class="s1">外部</span>-<span class="s1">名称</span>= <span class="s1">标记</span><span class="s2"><br>
</span>       chunk-ext-val  = token | quoted-string<span class="s2"><br>
</span>         <span class="s1">大块</span>-<span class="s1">外部</span>-<span class="s1">值</span> = <span class="s1">标记</span>  |  <span class="s1">引用</span>-<span class="s1">串</span><span class="s2"><br>
</span>       chunk-data     = chunk-size(OCTET)<span class="s2"><br>
</span>        <span class="s1">大块</span>-<span class="s1">数据</span>     = <span class="s1">大块</span> -<span class="s1">尺寸</span>(<span class="s1">八位子节</span>)<span class="s2"><br>
</span>       trailer        = *(entity-header CRLF)<span class="s2"><br>
</span>        <span class="s1">追踪者</span>        = * (<span class="s1">实体</span>-<span class="s1">领先</span> CRLF)</p>
<p class="p2"><span class="s3">   </span>大块尺寸域是用<span class="s3">16</span>进制表示大块尺寸的一串数字<span class="s3">.</span>成块编码以任一尺寸为<span class="s3">0</span>的大块结束<span class="s3">,</span>后缀以<span class="s3">trailer,</span>以一个空行终止<span class="s3">.</span></p>
<p class="p1">   trailer<span class="s1">允许发送者在消息末尾包含附加的</span>HTTP<span class="s1">头域</span>.trailer<span class="s1">头域可被应用于简要说明包含</span>trailer<span class="s1">的头域</span> (14.40<span class="s1">节</span>)</p>
<p class="p2"><span class="s3">   </span>一个服务器在应答中运用传输译码时不能在任何头域使用<span class="s3">trailer,</span>除非以下至少一条为真<span class="s3">:</span><span class="s2"><br>
</span><span class="s3">   a)        </span>请求包括一个<span class="s3">TE</span>头域时表明<span class="s3">"trailer"</span>在应答的转移译码中是可被接受的<span class="s3">,</span>就像<span class="s3">14.39</span>节中描述的那样<span class="s3">;</span>或者<span class="s2"><br>
</span><span class="s3">   b) </span>服务器是为了应答的原始服务器<span class="s3">,trailer</span>的域完全由随意的元数据构成<span class="s3">,</span>这个接收者可以在不接受这个元数据的情况下使用消息<span class="s3">(</span>在一个原始服务器可接受的方式中<span class="s3">).</span>另一方面<span class="s3">,</span>原始服务器愿意接受<span class="s3">trailer</span>域可能会在通往客户的通道上被默默放弃的这种可能性<span class="s3">.</span></p>
<p class="p2"><span class="s3">   </span>当消息被一个<span class="s3">HTTP/1.1</span>代理人接受并且<span class="s3">8</span>转寄至一个<span class="s3">HTTP/1.0</span>接受器时<span class="s3">,</span>这种需求防止了一个互用性的失误<span class="s3">.</span>它避免了一个依据<a href="http://www.cnpaf.net/">协议</a>将使在代理者上安置一个可能无限大的缓冲器成为必要的情形发生<span class="s3">. </span></p>
<p class="p2"><span class="s3">   </span>对一个大块主体进行解码处理的例子已在附录<span class="s3">19.4.6</span>中作过介绍</p>
<p class="p2"><span class="s3">  </span>所有<span class="s3">HTTP/1.1</span>应用程序必须能接受和解码<span class="s3">"</span>大块<span class="s3">"</span>传输译码<span class="s3">,</span>并且必须忽略它们不理解的大块扩展扩展名<span class="s3">.</span></p>
<p class="p1">3.7 <span class="s1">媒体类型</span></p>
<p class="p2"><span class="s3">   </span>为了提供公开的<span class="s3">,</span>可扩展的数据输入和规范流通<span class="s3">,HTTP</span>在目录类型<span class="s3">(14.17</span>节<span class="s3">)</span>和认可<span class="s3">(14.1</span>节<span class="s3">)</span>头域中运用网络媒体类型<span class="s3">.</span></p>
<p class="p1">       <span class="s1">媒体类型</span>       = <span class="s1">类型</span> "/" <span class="s1">亚类型</span>*(";" <span class="s1">参数</span>  )<span class="s2"><br>
</span>       <span class="s1">类型</span>           = <span class="s1">标记</span><span class="s2"><br>
</span>       <span class="s1">亚类型</span>       = <span class="s1">标记</span></p>
<p class="p2"><span class="s3">   </span>参数可能在属性<span class="s3">/</span>值的形式上遵循类型<span class="s3">/</span>亚类型<span class="s3">.(</span>如<span class="s3">3.6</span>节定义<span class="s3">)</span></p>
<p class="p2"><span class="s3">   </span>类型<span class="s3">,</span>亚类型<span class="s3">,</span>和参数属性名称是不直观的<span class="s3">.</span>参数值直观与否<span class="s3">,</span>取决于参数名称的意义<span class="s3">.</span><span class="s2"><br>
</span>线性的白色空间<span class="s3">(LWS)</span>不能被用于类型和亚类型之间<span class="s3">,</span>也不能用于一种属性及他的值之间<span class="s3">.</span>一个参数存在与否对媒体类型的处理有着重要的意义<span class="s3">,</span>取决于它在媒体类型注册中的定义<span class="s3">.</span></p>
<p class="p2"><span class="s3">  </span>注意一些旧的<span class="s3">HTTP</span>应用软件不能识别媒体类型参数<span class="s3">.</span>向一个旧的<span class="s3">HTTP</span>应用软件传送数据时<span class="s3">,</span>只有当类型<span class="s3">/</span>亚类型精确度需要时<span class="s3">,</span>才能实现媒体类型参数<span class="s3">.</span></p>
<p class="p2"><span class="s3">   </span>媒体类型值已经在网络分配数码权威<span class="s3">(IANA[19])</span>注册<span class="s3">.</span>媒体类型的注册程序在<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 1590[17]</span>中略述<span class="s3">.</span>使用未经注册的媒体类型是不会得心应手的<span class="s3">.</span></p>
<p class="p2"><span class="s3">3.7.1 </span>规范化和原文缺省</p>
<p class="p2"><span class="s3">   </span>网络媒体类型以语言的语音典型形式注册<span class="s3">.</span>一个通过<span class="s3">HTTP</span>通讯传输的实体必须被以先于传送的适当的规范的形式描绘<span class="s3">,</span>除<span class="s3">'text'</span>类形以外<span class="s3">,</span>就像下段定义的那样<span class="s3">.</span></p>
<p class="p2"><span class="s3">   </span>当在规范的形式中<span class="s3">,'text'</span>类型的媒体亚类型运用<span class="s3">GRLF</span>作为全文行的间断<span class="s3">.HTTP</span>放松了这个要求<span class="s3">,</span>当一个完整实体被间断完成时<span class="s3">,</span>允许全文媒体以简单的<span class="s3">GR</span>或<span class="s3">LF</span>独立作为一行的隔断的传输<span class="s3">. </span>在通过<span class="s3">HTTP</span>承认的原文媒体中<span class="s3">,</span>作为一个行的间断的代表<span class="s3">,HTTP</span>应用程序必须接受<span class="s3">CRLF,</span>空的<span class="s3">CR,</span>和空的<span class="s3">LF. </span>而且<span class="s3">,</span>如果原文在一个特性设置中被表现<span class="s3">,</span>没有分别用<span class="s3">8</span>位字节<span class="s3">13</span>和<span class="s3">10</span>表示<span class="s3">CR</span>和<span class="s3">LF,</span>就像某种多重字节特性设置<span class="s3">,HTTP</span>允许使用任何被为了表现<span class="s3">CR</span>和<span class="s3">LF</span>在行间断中的等同的特性设置所定义的任何<span class="s3">8</span>位字节次序<span class="s3">.</span>这个关于行间断的伸缩性仅仅应用于再一个实体中的原文媒体<span class="s3">;</span>一个空的<span class="s3">CR</span>或<span class="s3">LF</span>在任意<span class="s3">HTTP</span>控制的结构中都不能代替<span class="s3">CRLF.(</span>例如头域和多部边界<span class="s3">)</span></p>
<p class="p2"><span class="s3">   </span>如果一个实体把一个目录译码译成电码<span class="s3">,</span>在下面的译码必须被定义成在上面先被译码的形式<span class="s3">.</span></p>
<p class="p2"><span class="s3">   "charset"</span>参数和一些媒体类型一起使用用来定义数据的特性设置<span class="s3">(3.4</span>节<span class="s3">).</span>当发送者没有提供清楚的<span class="s3">charset</span>参数<span class="s3">,</span>通过<span class="s3">HTTP</span>接受时<span class="s3">"text"</span>类型的媒体类型就被定义成有一个为<span class="s3">"ISO-8859-1"</span>的默认<span class="s3">charset</span>值<span class="s3">.</span>特性设置的数据不同于<span class="s3">"ISO-8859-1"</span>或它的子集必须被标以适当的<span class="s3">charset</span>值<span class="s3">. </span>参见<span class="s3">3.4.1</span>节中兼容性问题<span class="s3">.</span></p>
<p class="p1">3.7.2 <span class="s1">多部分类型（</span>Multipart type)</p>
<p class="p2"><span class="s3">   MIME</span>提供了一系列<span class="s3">"</span>多重部分<span class="s3">"</span>类型<span class="s3">---</span>在单个消息体内一个或多个实体的包装<span class="s3">.</span>所有的多重部分类型共享一个公共的序列<span class="s3">,</span>就像<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 2046</span>的<span class="s3">5.1.1</span>节中定义的那样<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">   </span>必须包括一个作为媒体类型值一部分的边界参数<span class="s3">.</span>这个消息体自成为一个要素<a href="http://www.cnpaf.net/">协议</a><span class="s3">,</span>因此在两部分间只能用<span class="s3">CRLF</span>来表现行的间断<span class="s3">.</span>不同于<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 2046,</span>任一多重消息的末尾必须为空<span class="s3">;HTTP</span>应用程序不能传送末尾<span class="s3">(</span>即使原始的多重部分包含一个末尾<span class="s3">).</span>存在这些制约为的是保护一个多重部分消息实体的固有本质<span class="s3">,</span>结束多重部分边界已经在消息体的<span class="s3">"</span>结尾<span class="s3">"</span>加以表明<span class="s3">.</span></p>
<p class="p2"><span class="s3">   </span>通常<span class="s3">,HTTP</span>将一个消息体视为与任何其他媒体类型无异<span class="s3">:</span>严格如有效负载<span class="s3">.</span>当消息体出现在<span class="s3">206</span>应答时<span class="s3">,</span>有一个例外就是<span class="s3">"</span>多重部分<span class="s3">/</span>字符串<span class="s3">"</span>类型<span class="s3">(</span>附录<span class="s3">19.2),</span>将会被一些<span class="s3">HTTP</span>隐藏装置打断<span class="s3">,</span>就像<span class="s3">13.5.4</span>和<span class="s3">14.16</span>节中描述的那样<span class="s3">.</span>除此情况外<span class="s3">,</span>一个<span class="s3">HTTP</span>用户代理应该遵循与一个<span class="s3">MINE</span>用户代理相同或相似的行为<span class="s3">,</span>在多重部分类型收据之上<span class="s3">.MIME</span>头域在一个多重部分消息体的每一个部分里<span class="s3">,</span>对超过<span class="s3">MIME</span>意义的定义的<span class="s3">HTTP</span>没有任何意义<span class="s3">.</span></p>
<p class="p2"><span class="s3">  </span>通常<span class="s3">, </span>一个<span class="s3">HTTP</span>用户代理应该遵循与一个<span class="s3">MINE</span>用户代理相同或相似的行为<span class="s3">,</span>在多重部分类型收据之上<span class="s3">.</span>如果一个应用程序收到一个不能识别的多重部分亚类型<span class="s3">,</span>这个应用程序必须将它视为与<span class="s3">"</span>多重部分<span class="s3">/</span>混合<span class="s3">"</span>相等<span class="s3">.</span></p>
<p class="p2"><span class="s3">  </span>注<span class="s3">:"</span>多重部分<span class="s3">/</span>形态<span class="s3">-</span>数据<span class="s3">"</span>形式已被在适合于通过<span class="s3">POST</span>请求方法处理的传送形式数据明确定义<span class="s3">,</span>就像在<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 1867[15]</span>中描述的那样<span class="s3">.</span></p>
<p class="p1">3.8 <span class="s1">产品标记</span></p>
<p class="p2"><span class="s3">   </span>产品标记被用来承认通过软件名和译本识别它们自己的通讯应用软件<span class="s3">.</span>很多域还把产品标记用于认可次级产品<span class="s3">,</span>专业产品构成应用软件中有重要意义的部分被一一列出<span class="s3">,</span>用白色间隔分开<span class="s3">.</span>按照惯例<span class="s3">,</span>按产品对于识别应用软件的重要性的顺序列出它们<span class="s3">.</span></p>
<p class="p1">       <span class="s1">产品</span>           = <span class="s1">标示</span>  ["/" <span class="s1">产品</span> -<span class="s1">版本</span>]<span class="s2"><br>
</span>       <span class="s1">产品</span>-<span class="s1">版本</span>       = <span class="s1">标示</span></p>
<p class="p2"><span class="s3">   </span>例<span class="s3">:</span><span class="s2"><br>
</span><span class="s3">        </span>用户<span class="s3">-</span>代理<span class="s3">:   CERN-LineMode/2.15 libwww/2.17b3</span><span class="s2"><br>
</span><span class="s3">      </span>服务器<span class="s3">: Apache/0.8.4</span><span class="s2"><br>
</span><span class="s3">   </span>产品标示应言简意赅<span class="s3">.</span>它们不能用来做广告或其他不重要的信息<span class="s3">.</span>虽然任一标示可能出现在产品<span class="s3">-</span>版本上<span class="s3">,</span>但这个标示仅能被用来做一个版本标识<span class="s3">(i.e., </span>同类产品中成功的版仅区别在产品值的产品版本部分）</p>
<p class="p1">3.9 <span class="s1">质量值</span>(Quality Values)</p>
<p class="p1">  HTTP<span class="s1">内容流通</span>(12<span class="s1">节</span>)<span class="s1">运用简短的</span>"<span class="s1">浮点</span>"<span class="s1">数字来表明不同可流通参数之间的重要联系</span>("<span class="s1">重要性</span>").<span class="s1">一个重要性从</span>0<span class="s1">到</span>1<span class="s1">规格化了一个真实的数字</span>,0<span class="s1">是最小值</span>,<span class="s1">是最大值</span>.<span class="s1">如果一个参数为</span>0<span class="s1">的质量值</span>,<span class="s1">那么这个参数的内容不被客户接受</span>.HTTP/1.1<span class="s1">应用软件不能产生多于小数点后三位数字</span>.<span class="s1">这些值的用户配置也应受限于这种方式</span>.<span class="s2"><br>
</span>       qvalue         = ( "0" [ "." 0*3DIGIT ] )<span class="s2"><br>
</span>                      | ( "1" [ "." 0*3("0") ] )</p>
<p class="p2"><span class="s3">   "</span>质量值<span class="s3">" </span>是一个不当的用词<span class="s3">,</span>因为这些值仅仅表现想要得到的质量中的降级关系<span class="s3">.</span></p>
<p class="p1">3.10 <span class="s1">语言标记</span></p>
<p class="p2"><span class="s3">   </span>一个语言标记和自然的语言一样说<span class="s3">,</span>写<span class="s3">,</span>或被人类用于与其他人传递信息<span class="s3">.</span>计算机语言明显不包括在内<span class="s3">.HTTP</span>在认可语言和目录语言域内运用语言标记<span class="s3">.</span></p>
<p class="p2"><span class="s3">   HTTP</span>语言标记的语法和注册像<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 1766[1]</span>中定义的一样<span class="s3">.</span>总之<span class="s3">,</span>一个语言标记是由一部分或多部分构成<span class="s3">:</span>一个主要语言标记和可能为空的一系列下标签<span class="s3">.</span></p>
<p class="p1">        <span class="s1">语言标记</span>      = <span class="s1">主要标记</span>    *("_"  <span class="s1">下标签</span>)<span class="s2"><br>
</span>        <span class="s1">主要标记</span>   = 1*8ALPHA<span class="s2"><br>
</span>        <span class="s2"><br>
</span>        <span class="s1">下标签</span>        = 1*8ALPHA<span class="s2"><br>
</span>        <span class="s2"><br>
</span>    <span class="s1">标签中不允许出现空格，标签对个例不敏感（</span>case-insensitive<span class="s1">）</span>.<span class="s1">由</span>IANA<span class="s1">来<a href="http://www.cnpaf.net/class/Manage/">管理</a>语言标记中的名字间隔</span>.<span class="s1">典型的标签包括</span>:</p>
<p class="p1">       en, en-US, en-cockney, i-cherokee, x-pig-latin</p>
<p class="p2"><span class="s3">   </span>任何两个字母的主要标签是一个<span class="s3">ISO-639</span>语言的缩写<span class="s3">,</span>两个大写字母的下标签是一个<span class="s3">ISO-3166</span>的国家代码<span class="s3">.(</span>上面的最后三个标签是未经注册的标签<span class="s3">;</span>除最后一个之外所有都是可在将来注册的例子标签<span class="s3">).</span></p>
<p class="p1">3.11 <span class="s1">实体标签</span></p>
<p class="p2"><span class="s3">   </span>实体标签用来从相同请求资源中比较两个或更多实体<span class="s3">.HTTP/1.1</span>在<span class="s3">Etag(14.19</span>节<span class="s3">),If-match(14.24</span>节<span class="s3">),If-None-match(14.26</span>节<span class="s3">),</span>和<span class="s3">If-rang(14.27</span>节<span class="s3">)</span>头域中运用实体标签<span class="s3">.</span>关于它们怎样像高速缓冲存储器确认一样使用和比较的解释在<span class="s3">13.3.3</span>节中<span class="s3">.</span>一个实体标签由一个给定的不透明的一行组成<span class="s3">,</span>可能加上一个虚弱指示器的前缀<span class="s3">.</span></p>
<p class="p1">      entity-tag = [ weak ] opaque-tag<span class="s2"><br>
</span>      weak       = "W/"<span class="s2"><br>
</span>      opaque-tag = quoted-string</p>
<p class="p2"><span class="s3">   </span>一个<span class="s3">"</span>坚固的<span class="s3">(strong)</span>实体标签<span class="s3">"</span>在两个实体八位子节相等时可能会被一个资源里的两个实体共享<span class="s3">.</span></p>
<p class="p2"><span class="s3">   </span>一个<span class="s3">"</span>虚弱<span class="s3">(weak)</span>的实体标签<span class="s3">",</span>由<span class="s3">"W/"</span>前缀表示<span class="s3">,</span>在实体相等且可以互相替代而在语义上不发生重大的变动时<span class="s3">,</span>可能会被一个资源力的两个实体共享<span class="s3">.</span>一个虚弱的实体标签只能在虚弱对比时使用<span class="s3">.</span></p>
<p class="p2"><span class="s3">   </span>一个实体标签必须在所有与一个特殊资源相连系实体的译本中是独一无二的<span class="s3">.</span>一个给定的实体标签值可以被不同的<span class="s3">URI</span>请求用来获得实体<span class="s3">.</span>相同实体标签值在不同<span class="s3">URI</span>请求获得实体的联合中的运用不意味着那些实体的等同<span class="s3">.</span></p>
<p class="p1">3.12 <span class="s1">范围单位</span>(Range Units)</p>
<p class="p2"><span class="s3">    HTTP/1.1</span>允许一个客户要求单独部分的应答实体被包括在应答内<span class="s3">.HTTP/1.1</span>在范围<span class="s3">(14.35</span>节<span class="s3">)</span>和目录范围头域<span class="s3">(14.16</span>节<span class="s3">)</span>运用范围单位<span class="s3">.</span>一个实体可根据不同的结构单位分解成子区域<span class="s3">.</span></p>
<p class="p1">       <span class="s1">范围</span>-<span class="s1">单位</span>       = <span class="s1">字节</span>-<span class="s1">单位</span> |  <span class="s1">其他</span>-<span class="s1">范围</span>-<span class="s1">单位</span><span class="s2"><br>
</span>      <span class="s1">字节</span>-<span class="s1">单位</span>        =  "<span class="s1">字节</span>"<span class="s2"><br>
</span>      <span class="s1">其他</span>-<span class="s1">范围</span>-<span class="s1">单位</span>   = <span class="s1">标记</span></p>
<p class="p2"><span class="s3">   HTTP/1.1</span>中定义的唯一的范围单位是<span class="s3">"</span>字节<span class="s3">".HTTP/1.1</span>实现时可能忽略其他单位指定的范围。<span class="s2"><br>
</span><span class="s3">   HTTP/1.1</span>的设计允许应用软件不依靠有关范围的知识而实现</p>
<p class="p1"><span class="s2"><br>
</span>4 HTTP<span class="s1">消息</span></p>
<p class="p1"><span class="s1">　</span>Copyright  www.cnpaf.net (2007).          All Rights Reserved.</p>
<p class="p1">4.1  <span class="s1">消息类型</span></p>
<p class="p2"><span class="s3">      HTTP</span>消息由从客户到服务器的请求和从服务器到客户的回答组成<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">              HTTP-</span>消息<span class="s3"> = </span>请求<span class="s3">|</span>回答<span class="s3"> ;HTTP/1.1 </span>消息<span class="s2"><br>
</span><span class="s3">       </span>请求<span class="s3">(</span>第五节<span class="s3">)</span>和回答<span class="s3">(</span>第六节<span class="s3">)</span>的消息是用一般的消息格式<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 822[9]</span>来传输实体的<span class="s3">(</span>消息的有效载荷<span class="s3">).</span>这两种消息都是由开始行<span class="s3">,</span>零或者更多的头域<span class="s3">(</span>也叫做头<span class="s3">),</span>象征头结束的空行<span class="s3">(</span>譬如说一个只有回车字符的行<span class="s3">)</span>组成<span class="s3">,</span>有时可能会有一个信息体<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">       </span>一般的消息<span class="s3">=</span>开始行<span class="s2"><br>
</span><span class="s3">                  *(</span>消息头<span class="s3"> CRLF)</span><span class="s2"><br>
</span><span class="s3">                  CRLF</span><span class="s2"><br>
</span><span class="s3">                   [</span>消息的内容<span class="s3">]</span><span class="s2"><br>
</span><span class="s3">       </span>开始行<span class="s3">    =</span>请求行<span class="s3">|</span>状态行<span class="s2"><br>
</span><span class="s3">       </span>为了健壮性<span class="s3">,</span>服务器必须在期望收到要求行的地方忽略任何接收到的空行<span class="s3">.</span>换句话说<span class="s3">,</span>如果服务器在读一条信息开始的<a href="http://www.cnpaf.net/">协议</a>流时先收到了<span class="s3">CRLF,</span>它必须忽略这个<span class="s3">CRLF.</span><span class="s2"><br>
</span><span class="s3">       </span>一般一个有问题的<span class="s3">HTTP/1.0</span>客户端在<span class="s3">POST</span>请求后会产生额外的<span class="s3">CRLF.</span>为了重述什么是<span class="s3">BNF</span>明确禁止的<span class="s3">,</span>一个<span class="s3">HTTP/1.1</span>客户端没有必要开始和跟随一个额外的<span class="s3">CRLF</span>的请求<span class="s3">.</span></p>
<p class="p2"><span class="s3">4.2 </span>消息头<span class="s2"><br>
</span><span class="s3">     HTTP</span>头域包括常规头<span class="s3">(4.5</span>节<span class="s3">)</span>请求头<span class="s3">(5.3</span>节<span class="s3">),</span>应答头<span class="s3">(6.2</span>节<span class="s3">)</span>和实体头<span class="s3">(7.1</span>节<span class="s3">)</span>域<span class="s3">,</span>它们遵循<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3">822[0]3.1</span>节中给出的同一个常规的格式<span class="s3">.</span>每一个头域由一个紧跟<span class="s3">":"</span>的名字和域值构成<span class="s3">.</span>域名是大小写不敏感的<span class="s3">.</span>域值可能在任何<span class="s3">LWS</span>的前面<span class="s3">,</span>尽管单个的<span class="s3">SP</span>是首先的<span class="s3">.</span>头域能通过把各个额外行<span class="s3">(</span>至少有一个<span class="s3">SP</span>或<span class="s3">HT)</span>前置来扩展成多行<span class="s3">.</span>当产生<span class="s3">HTTP</span>结构的时<span class="s3">,</span>应用必须遵循<span class="s3">"</span>共同格式<span class="s3">",</span>那儿它被知道或定义<span class="s3">,</span>即使有时存在一些不能接受任何东西的操作<span class="s3">.</span></p>
<p class="p2"><span class="s3">  </span>共同的格式<span class="s3">.</span></p>
<p class="p2">消息<span class="s3">-</span>头<span class="s3">=</span>域名<span class="s3">":"[</span>域值<span class="s3">]</span><span class="s2"><br>
</span>域名<span class="s3">=</span>记号<span class="s2"><br>
</span>域值<span class="s3">=*(</span>域的内容<span class="s3">|LWS)</span><span class="s2"><br>
</span>域的内容<span class="s3">=&lt;</span>由八位的字节构成域值<span class="s3">,</span>它由文本或组合标记<span class="s3">,</span>分割符<span class="s3">,</span>和引用的字符串组成<span class="s3">&gt;</span></p>
<p class="p2">这个域的内容不包括任何引导的或连接的<span class="s3">LWS:</span>位于域内容属性的第一个不是空白的地方的前面或最厚的布是空白的地方的后面<span class="s3">.</span>去掉这些引导或连接的<span class="s3">LWS</span>可能不会影响域内容的意思<span class="s3">,</span>任何位于域内容之间的<span class="s3">LWS</span>在解释域的内容或传送消息的下载流的时候可以用单个的<span class="s3">SP</span>替换<span class="s3">.</span><span class="s2"><br>
</span>用不同域名收到的头域的顺序不是重要的<span class="s3">.</span>但是<span class="s3">,</span>一个好的习惯是先送常规头<span class="s3">,</span>接着是请求头或应答头<span class="s3">,</span>最后是实体头域<span class="s3">.</span></p>
<p class="p2">多个消息头域使用同一个域可能会出现在一些消息中<span class="s3">,</span>在这些消息中<span class="s3">,</span>可能也只可能是整个域用逗号分割的列表定义<span class="s3">(</span>例如<span class="s3">,#(</span>值<span class="s3">)).</span>这些必须有可能在没有改变消息的情况下被组合成一个<span class="s3">"</span>域名<span class="s3">:</span>域值<span class="s3">"</span>对<span class="s3">,</span>在这些被逗号隔开的域中后面的域植被添加到第一个域中<span class="s3">.</span>那些用同一个域名组成一个头域的顺序是重要的<span class="s3">,</span>因此当一个消息在传输的时候代理一定不能改变这些域值的顺序<span class="s3">.</span></p>
<p class="p1">4.3 <span class="s1">消息体</span></p>
<p class="p2"><span class="s3">  HTTP</span>消息的消息体备用用来传输由要求和应答组成的实体<span class="s3">.</span>这些消息体仅仅当传输译码被应用的时候才和实体不同<span class="s3">,</span>这用传输编码的头域标明<span class="s3">(14.41</span>节<span class="s3">).</span></p>
<p class="p2"><span class="s3">     </span>消息体<span class="s3">=</span>实体<span class="s3">|&lt;</span>编码的实体<span class="s3">&gt;</span></p>
<p class="p2">传输编码常用来表示那些应用程序为了<a href="http://www.cnpaf.net/class/security/">安全</a>和保证消息的正确传输的传输码<span class="s3">.</span>传输编码是一种消息的属性而不是实体<span class="s3">,</span>因此沿着请求<span class="s3">/</span>应答链它可以被任何应用程序加上或去掉<span class="s3">.</span></p>
<p class="p2"><span class="s3">   </span>当一个消息中允许有消息体时的规则和请求应答时的不一样<span class="s3">.</span></p>
<p class="p2"><span class="s3">   </span>一个请求的消息体是用来传达内容长度或请求传输编码头的传输编码头域的信息<span class="s3">.</span>如果请求方式的规范不允许请求中加入实体则一个请求中也必须不能包括消息体<span class="s3">.</span>一个服务器必须读和处理任何请求的消息体<span class="s3">;</span>如果请求方法没有定义一个实体的表述<span class="s3">,</span>则当处理这个请求是必须忽略消息体<span class="s3">.</span></p>
<p class="p2"><span class="s3">   </span>对于应答消息<span class="s3">,</span>一个消息是否包括消息体依赖于请求的方法和应答的状态代码<span class="s3">(6.1.1</span>节<span class="s3">).</span>对于所有头请求方法的应答都不能包括消息体<span class="s3">,</span>即使有时实体头域的存在让人相信它们包括了<span class="s3">.</span>所有<span class="s3">1XX(</span>信息的<span class="s3">),204(</span>无内容的<span class="s3">),</span>和<span class="s3">304(</span>没有修改的<span class="s3">)</span>的应答都不能包括消息体<span class="s3">.</span>所有其他的应答必须包括消息体<span class="s3">,</span>虽然它可能长度为零<span class="s3">.</span></p>
<p class="p2"><span class="s3">4.4 </span>消息的长度</p>
<p class="p2"><span class="s3">     </span>一条消息的传输长度是消息体出现在消息中的长度<span class="s3">,</span>也就是说<span class="s3">,</span>当传输代码被处理以后<span class="s3">.</span>当一条消息包含消息体<span class="s3">,</span>实体的输长度有以下几条决定<span class="s3">(</span>以先后顺序<span class="s3">):</span></p>
<p class="p2"><span class="s3">     1</span>。任何回应信息不应包含在信息体中，如<span class="s3">1xx</span>，<span class="s3">204,304</span>回应和任何对头请求的回应。这种情况都是在头域结束后第一行为空白行<span class="s3">,</span>不管实体域是否出现。</p>
<p class="p2"><span class="s3">     2</span>。传输代码头域<span class="s3">(</span>属于<span class="s3">general-header</span>域<span class="s3">)</span>出现的话而且有值而不是身份，那么传输长度就可以使用<span class="s3">chunked</span>大块来确定，除非信息由于连接关闭而中断了<span class="s3">.</span></p>
<p class="p2"><span class="s3">     3</span>。如果<span class="s3">Content-Length</span>头域<span class="s3">(</span>属于实体头<span class="s3">)</span>出现，那么它的值是信息体传输长度。如果传输头域和<span class="s3">Content-Length</span>头域都出现了，而长度不一致，那么<span class="s3">Content-Length</span>头域中的值就不该传。</p>
<p class="p2"><span class="s3">     4</span>。如果被<span class="s3">1.0</span>代理传送的范围头域不能理解多部份<span class="s3">/</span>位范围；服务器必须采用<span class="s3">1</span>，<span class="s3">2</span>，<span class="s3">3</span>的方式界定信息体长度。</p>
<p class="p2"><span class="s3">     5</span>。当服务器正在关闭连接<span class="s3">.(</span>正在关闭连接不能用来说明应答体的结束<span class="s3">,</span>因为它将导致服务器没有可能送回一个应答信号<span class="s3">.)</span></p>
<p class="p2">为了与<span class="s3">HTTP/1.0</span>应用程序兼容<span class="s3">,HTTP/1.1</span>请求包含的消息体必须包括一个有效内容长度的头域<span class="s3">,</span>除非知道服务器适应<span class="s3">HTTP/1.1.</span>如果一个请求包含一个消息体并没有给出内容长度<span class="s3">,</span>那个服务器会应答<span class="s3">400(</span>错误的请求<span class="s3">)</span>如果他不能判断消息长度的话<span class="s3">,</span>或者应答<span class="s3">411(</span>要求成都<span class="s3">)</span>如果它坚持想要收到一个有效内容的长度<span class="s3">.</span></p>
<p class="p2">所有的<span class="s3">HTTP/1.1</span>应用程序必须接受<span class="s3">"CHUNKED"</span>传输代码<span class="s3">(3.6</span>节<span class="s3">),</span>因此允许这种机制来处理消息当消息的程度不能被决定<span class="s3">.</span></p>
<p class="p2">消息没有必要都不包括内容长度头域和<span class="s3">non-identity</span>传输代码<span class="s3">.</span>如果消息包括了一个<span class="s3">non-identity</span>传输代码<span class="s3">,</span>传输长度必须忽略<span class="s3">.</span></p>
<p class="p2">当一个内容的长度在消息体允许的地方给出时<span class="s3">,</span>这个域值必须和消息体中八进制数一致<span class="s3">.HTTP/1.1</span>用户代理必须通报使用者当一个无效的长度被接受和发现<span class="s3">.</span></p>
<p class="p1">4.5 <span class="s1">常规头域</span></p>
<p class="p2"><span class="s3">   </span>这儿有一些头域能适应一般的请求和应答消息<span class="s3">,</span>但是它没有应用渔船树种的实体<span class="s3">.</span>这些头域只应用于那些被发射的消息<span class="s3">.</span></p>
<p class="p1">     <span class="s1">常规的头域</span>=<span class="s1">高速缓存控制</span>         ;14.9<span class="s1">节</span><span class="s2"><br>
</span>                |<span class="s1">连接</span>         ;14.10<span class="s1">节</span><span class="s2"><br>
</span>                |<span class="s1">数据</span>         ;14.18<span class="s1">节</span><span class="s2"><br>
</span>                |<span class="s1">程序</span>         ;14.32<span class="s1">节</span><span class="s2"><br>
</span>                |<span class="s1">追踪</span>         ;14.40<span class="s1">节</span><span class="s2"><br>
</span>                |<span class="s1">传输编码</span>     ;14.41<span class="s1">节</span><span class="s2"><br>
</span>                |<span class="s1">升级</span>         ;14.42<span class="s1">节</span><span class="s2"><br>
</span>                |<span class="s1">路由</span>         ;14.45<span class="s1">节</span><span class="s2"><br>
</span>                <span class="s1">警告</span>          ;14.46<span class="s1">节</span></p>
<p class="p2"><span class="s3">   </span>常规头域的名字的真正扩展必须和<a href="http://www.cnpaf.net/">协议</a>版本的变化相结合。然而，新的或实验性质的头域可能被赋予常规头域的意义，如果信息传输中的所有部分都承认它们为常规头域的话，未被承认的头于一般当实体头域看待。</p>
<p class="p1"><span class="s2"><br>
</span>5 <span class="s1">请求</span></p>
<p class="p1"><span class="s1">从客户机到服务器的请求</span>,<span class="s1">其首行包括利用资源的方式</span>,<span class="s1">区分资源的标识</span>,<span class="s1">以及<a href="http://www.cnpaf.net/">协议</a>的版本号</span><span class="s2"><br>
</span><span class="s1">请求</span>   =<span class="s1">请求行</span>                       ;  5.1<span class="s1">节</span><span class="s2"><br>
</span>       *((<span class="s1">常规报头</span>                    ;  4.5<span class="s1">节</span><span class="s2"><br>
</span>         |<span class="s1">请求报头</span>                    ;  5.3<span class="s1">节</span><span class="s2"><br>
</span>         <span class="s1">实体报头</span>)CRLF)              ;  7.1<span class="s1">节</span><span class="s2"><br>
</span>           CRLF         <span class="s2"><br>
</span>         [<span class="s1">消息正文</span>]                   ;  4.3<span class="s1">节</span></p>
<p class="p1">5.1 <span class="s1">请求行</span></p>
<p class="p2"><span class="s3">   </span>请求<span class="s3">-</span>行的开头是方法标识<span class="s3">,</span>接下来是请求<span class="s3">URL</span>和<a href="http://www.cnpaf.net/">协议</a>版本号<span class="s3">,</span>以回车换行结束<span class="s3">.</span>各部分之间用空格符<span class="s3">(SP)</span>分隔<span class="s3">,</span>除了最后的回车换行外<span class="s3">,</span>不允许有回车<span class="s3">(CR)</span>和换行<span class="s3">(LF).</span></p>
<p class="p1">       <span class="s1">请求</span>-<span class="s1">行</span>  ==<span class="s1">方式</span>(<span class="s1">空格</span>) <span class="s1">请求</span>URI(<span class="s1">空格</span>)  HTTP<span class="s1">版本号</span>(<span class="s1">回车换行</span>)</p>
<p class="p1">5.1.1<span class="s1">方法</span></p>
<p class="p2"><span class="s3">  </span>方法标记指的是在请求<span class="s3">URI</span>所指定的资源上所实现的方式<span class="s3">,</span>这种方式是条件敏感的</p>
<p class="p1">Method     = "OPTIONS"                     ;9.2<span class="s1">节</span><span class="s2"><br>
</span>             | "GET"                        ;9.3<span class="s1">节</span><span class="s2"><br>
</span>             | "HEAD"                       ;9.4<span class="s1">节</span><span class="s2"><br>
</span>             |"POST"                        ;9.5<span class="s1">节</span><span class="s2"><br>
</span>             |"PUT"                         ;9.6<span class="s1">节</span><span class="s2"><br>
</span>             |"DELETE"                      ;9.7<span class="s1">节</span><span class="s2"><br>
</span>             |"TRACE"                       ;9.8<span class="s1">节</span><span class="s2"><br>
</span>             |"CONNECT"                     ;9.9<span class="s1">节</span><span class="s2"><br>
</span>             | <span class="s1">扩展方式</span>(extension-method)</p>
<p class="p2">扩展方式<span class="s3">=   </span>标记</p>
<p class="p2">资源允许的方法列表能由允许<span class="s3">(Allow)</span>报头域详细指定．既然被允许方法的设置可以动态的改变<span class="s3">,</span>返回的应答码总是通知客户机当前方法是否被允许<span class="s3">.</span>如果原服务器知道方法，但方法不被请求的资源允许，原服务器应当返回状态码<span class="s3">405(</span>方法不允许<span class="s3">)</span>．如果方法不被原服务器承认和实现<span class="s3">,</span>原服务器应当返回状态码<span class="s3">501(</span>没有实现）<span class="s3">.</span>获取<span class="s3">(GET)</span>和报头<span class="s3">(HEAD)</span>方法应当被所有的多功能服务器支持．其他所有的方法是可选的，然而，假若以上的方法没有实现，则他们必须被在第九章里所说明的同一种语法定义所实现．</p>
<p class="p1">5.1.2 <span class="s1">请求</span>URL</p>
<p class="p2">　　请求<span class="s3">URL</span>是一种全球统一的应用于资源请求的资源标识符（３<span class="s3">.2 </span>节）．<span class="s2"><br>
</span>　<span class="s2"><br>
</span>　　　　请求<span class="s3">URL   ="*"|</span>绝对<span class="s3">URL|</span>绝对路径<span class="s3">|</span>主机<span class="s3">authotity</span></p>
<p class="p2">请求<span class="s3">URI</span>的四个选项在一般情况下是互相关联的<span class="s3">,</span>星号<span class="s3">"*"</span>表示请求不是应用于某种特别的资源<span class="s3">,</span>而是服务器本身<span class="s3">,</span>只有当所用的方法不是资源必要的方法才是允许的<span class="s3">.</span>举例如下</p>
<p class="p1">             <span class="s1">选项</span>(OPTIONS)*HTTP/1.1</p>
<p class="p2">当代理服务器产生请求时，绝对<span class="s3">URI</span>地址是不可缺少的．代理服务器被要求转寄来自高速缓冲存储器有效的请求或服务<span class="s3">,</span>返回应答．注意到代理服务器可以把请求转发给另一台代理服务器或直接转发给绝对<span class="s3">URI</span>地址说明的服务器．为了避免请求循环，代理服务器必须识别所有的服务器名字，包括任何别名，本地变异名，数字<span class="s3">IP</span>地址．请求行举例如下：<span class="s2"><br>
</span>　　　　　<span class="s2"><br>
</span>　　　　　Ｇ<span class="s3">ET  <a href="http://www.w3.org/pub/www/TheProject.html">http://www.w3.org/pub/www/TheProject.html</a>  HTTP/1.1</span></p>
<p class="p2">为了在未来的<span class="s3">HTTP</span>版本的所有请求中转换绝对<span class="s3">URL</span>地址，所有基于Ｈ<span class="s3">TTP/1.1</span>的服务器必须接受绝对<span class="s3">URL</span>地址的组成，虽然基于<span class="s3">HTTP/1.1</span>的客户机将只产生请求发给代理服务器</p>
<p class="p1"><span class="s1">主机</span>(authority)<span class="s1">组成部分只是在连接方法</span>(CONNECT)<span class="s1">中用到（９</span>.9<span class="s1">节）．</span></p>
<p class="p2">最通用形式的请求ＵＲ<span class="s3">I</span>用于标识在原服务器或网关上的资源<span class="s3">.</span>这种情况下，绝对ＵＲＬ路径必须作为请求ＵＲＬ传送（看３<span class="s3">.</span>２<span class="s3">.</span>１节，绝对路径），ＵＲＩ局域网地址<span class="s3">(authority)(</span>必须输入主机报头域．例如，希望直接得到原服务器顶层资源的客户机将在<span class="s3">"</span>ｗｗｗ．ｗ３．ｏｒｇ<span class="s3">"</span>主机的端口８０建立ＴＣＰ连接发送以下行：<span class="s2"><br>
</span>　　<span class="s2"><br>
</span>　　　<span class="s3">GET /pub/WWW/TheProject.html HTTP/1.1</span><span class="s2"><br>
</span><span class="s3">      Host:www.w3.org</span></p>
<p class="p2">接下来是请求的其他部分，注意绝对路径不能是空的；假如没有初始的<span class="s3">URI</span>，必须给出<span class="s3">"</span>／<span class="s3">"</span>（服务器根目录）．</p>
<p class="p2">请求ＵＲＬ用在<span class="s3">3.2.1</span>节里说明的格式传输．如果用<span class="s3">"%HEX</span>　<span class="s3">HEX"[42]</span>码编码<span class="s3">,</span>为了正确的翻译请求，原服务器必须译码．对于有适当状态码的无效的请求，服务器必须给予应答．</p>
<p class="p2">当透明的代理服务器转发收到的请求ＵＲＬ地址给下一台网内的服务器时，禁止其重写<span class="s3"> "</span>绝对路径<span class="s3">"</span>部分<span class="s3">,</span>上面提到的用<span class="s3">"</span>／<span class="s3">"</span>代替空的绝对地址不在此例．</p>
<p class="p2">注：当原服务器不恰当的用非保留ＵＲＬ字符作保留用时，<span class="s3">"</span>禁止重写<span class="s3">"</span>规则防止<span class="s2"><br>
</span>代理服务器更改请求的含义，实现程序将了解前面的一些<span class="s3">HTTP/1.1</span>代理服务器就将知道改写了请求ＵＲＩ．</p>
<p class="p2"><span class="s3">5.2</span>请求定义的资源</p>
<p class="p2">一个<span class="s3">INTERNET</span>请求所定义的精确资源由请求<span class="s3">URL</span>和主机报头域所决定<span class="s3">.</span></p>
<p class="p2">当决定<span class="s3">HTTP/1.1<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>标识的资源时，不允许资源与请求主机不同的原服务器可以忽略主机报头域的值，（但看１９<span class="s3">.</span>６<span class="s3">.</span>１节了解支持<span class="s3">HTTP/1.1</span>主机上的另一种需求）<span class="s3">.</span></p>
<p class="p2">基于主机的请求区分资源的服务器<span class="s3">(</span>有时指虚拟的主机或空白的主机名<span class="s3">)</span>必须用以下的规则决定<span class="s3">HTTP/1.1</span>请求所请求的资源．</p>
<p class="p2">１．<span class="s3"> </span>如果请求<span class="s3">URI</span>是绝对地址，主机是请求<span class="s3">URI</span>的一部分．任何主机报头域应当忽略．<span class="s2"><br>
</span>２．<span class="s3"> </span>假如请求<span class="s3">URI</span>不是绝对地址，且请求包括一个主机报头域，则主机由该域的值所决定．<span class="s2"><br>
</span>３．<span class="s3"> </span>假如由规定１或规定２定义的主机是无效的主机，则应答当是一个<span class="s3">400</span>出错信息</p>
<p class="p2">为了找出真正被请求的资源，一个缺乏主机标识域的<span class="s3">HTTP/1.0</span>请求接收者可以尝试使用试探的方法（例如检测ＵＲＩ路径对于特定的主机是唯一的这个性质）．</p>
<p class="p2">５<span class="s3">.3</span>请求报头域</p>
<p class="p2">请求的报头域允许客户传递关于请求，客户自己的附加信息给服务器．这些域作为请求修饰成分，和程序语言中方法调用的参数有差不多的含义．</p>
<p class="p1"><span class="s1">　　　请求报头　＝　接收</span>(Accept)<span class="s1">　　　　　　　　　　</span>                ;14.1<span class="s1">节</span><span class="s2"><br>
</span>                   |<span class="s1">接收</span>Charset (Accept-Charset)              ;14.2<span class="s1">节</span><span class="s2"><br>
</span>                   |<span class="s1">接收编码</span>(Accept-Encoding)          ;14.3<span class="s1">节</span> <span class="s2"><br>
</span>                   |<span class="s1">接收语言</span>(Accept-Language)               ;14.4<span class="s1">节</span> <span class="s2"><br>
</span>                   |<span class="s1">认证</span>(Authorization<span class="s1">）</span>                        ;14.8<span class="s1">节</span> <span class="s2"><br>
</span>                   |<span class="s1">期望</span>(Expect)                              ;14.20<span class="s1">节</span><span class="s2"><br>
</span>                   |<span class="s1">源</span>(From)                                  ;14.22<span class="s1">节</span><span class="s2"><br>
</span>                   |<span class="s1">主机</span>(Host)                               ;14.23<span class="s1">节</span><span class="s2"><br>
</span>                   |<span class="s1">假如匹配</span>(If-Match)                       ;14.24<span class="s1">节</span><span class="s2"><br>
</span>                   |<span class="s1">假如修改</span>(If-Modified-Since)              ;14.25<span class="s1">节</span><span class="s2"><br>
</span>                   |<span class="s1">假如不匹</span>(If-None-Match)            ;14.26<span class="s1">节</span><span class="s2"><br>
</span>                   |<span class="s1">假如归类</span>(If-Range)                 ;14.27<span class="s1">节</span><span class="s2"><br>
</span>                   |<span class="s1">假如不修改</span>(If-Unmodified-Since )         ;14.28<span class="s1">节</span><span class="s2"><br>
</span>                   |<span class="s1">最大转发量</span>(Max-Forwards                      ;14.31<span class="s1">节</span><span class="s2"><br>
</span>                   |<span class="s1">代理认证</span>( Proxy-Authorization)         ;14.34<span class="s1">节</span> <span class="s2"><br>
</span>                   |<span class="s1">范围</span>(Range)                                 ;14.35<span class="s1">节</span><span class="s2"><br>
</span>                   |<span class="s1">提交者</span>(Referer)                          ;14.36<span class="s1">节</span><span class="s2"><br>
</span>                   |TE                                  ;14.39<span class="s1">节</span><span class="s2"><br>
</span>                   |<span class="s1">用户代理</span>(User-Agent)                  ;14.43<span class="s1">节</span></p>
<p class="p2">随着<a href="http://www.cnpaf.net/">协议</a>版本的变化<span class="s3">,</span>请求报头域的名字可以可靠的扩展．然而新的或扩展的报头域可以给出请求报头域的语法，其前提是通信中所有部分承认它们是请求报头域．不被承认的报头域被当作实体报头域．</p>
<p class="p2">６<span class="s3"> </span>应答</p>
<p class="p2">接收和翻译一个请求信息后，服务器发出一个<span class="s3">HTTP</span>应答信息．</p>
<p class="p1"><span class="s1">　　　　　应答　　　＝状态行　</span>                                 ;6.1<span class="s1">节</span><span class="s2"><br>
</span><span class="s1">　　　　　　　　　　　</span>*((<span class="s1">常规报头</span>(general-header<span class="s1">）</span>                ; 4.5<span class="s1">节</span><span class="s2"><br>
</span>                       |<span class="s1">应答报头</span>(response-header)            ;6.2<span class="s1">节</span><span class="s2"><br>
</span>                       |<span class="s1">实体报头</span>(entity-header)CRLF)          ;7.1<span class="s1">节</span><span class="s2"><br>
</span>                             CRLF<span class="s2"><br>
</span>                      [<span class="s1">应答正文</span>]                             ;7.2<span class="s1">节</span></p>
<p class="p1">6.1 <span class="s1">状态行</span></p>
<p class="p2">应答信息的第一行是状态行<span class="s3">,</span>由<a href="http://www.cnpaf.net/">协议</a>版本以及数字状态码和相关的文本说明组成<span class="s3">,</span>各部分间用空格符隔开，除了最后的回车或换行外，中间不允许有回车换行．<span class="s2"><br>
</span>　　　　　<span class="s2"><br>
</span>　　　状态行　＝　<span class="s3">HTTP</span>版本<span class="s3"> SP</span>状态码<span class="s3"> SP </span>原因短语<span class="s3"> CRLF</span></p>
<p class="p2"><span class="s3">6.1.1</span>状态码与注解</p>
<p class="p2">状态码是试图理解和满足请求的三位数字的整数码，这些码的完整定义在第十章．注解短语是特意给出的关于状态码的文本描述．状态码用于自动控制而注解短语是面向用户的．客户机不需要检查和显示注解短语．</p>
<p class="p2">状态码的第一位数字定义应答类型．后两位数字没有任何类型任务．第一位数字有五种值：</p>
<p class="p1">-1xx: <span class="s1">报告的</span>                - <span class="s1">接收到请求</span>,<span class="s1">继续进程</span>.<span class="s2"><br>
</span>-2xx  <span class="s1">成功</span>                  - <span class="s1">操作成功的收到</span>.<span class="s2"><br>
</span>-3xx  <span class="s1">重发</span>              - <span class="s1">为了完成请求</span>,<span class="s1">必须采取进一步措施</span>.<span class="s2"><br>
</span>-4xx  <span class="s1">客户端出错</span>            - <span class="s1">请求包括错的顺序或不能完成</span>.<span class="s2"><br>
</span>-5xx  <span class="s1">服务器出错</span>            - <span class="s1">服务器无法完成显然有效的请求</span>.</p>
<p class="p2">为<span class="s3">HTTP/1.1</span>定义的状态码单独的值，和一个相应的一系列注解短语的例子，介绍如下<span class="s3">,</span>这儿列出的注解短语只是建议――它们可以被相当的没有感情色彩的<a href="http://www.cnpaf.net/">协议</a>取代．</p>
<p class="p1"><span class="s1">　　状态码　＝</span><span class="s2"><br>
</span><span class="s1">　　</span>             "100" ;         10.1.1<span class="s1">节</span>:         <span class="s1">继续</span>           <span class="s2"><br>
</span>                    |"101"   ;  10.1.2<span class="s1">节</span>:         <span class="s1">转换<a href="http://www.cnpaf.net/">协议</a></span>     <span class="s2"><br>
</span>                    |"200"   ;  10.2.1<span class="s1">节</span>:         OK<span class="s2"><br>
</span>                |"201"   ;        10.2.2<span class="s1">节</span>:   <span class="s1">创建</span>                <span class="s2"><br>
</span>                    |"202"   ;  10.2.3<span class="s1">节</span>:   <span class="s1">接受</span>         <span class="s2"><br>
</span><span class="s1">　　</span>                |"203"   ;  10.2.4<span class="s1">节</span>:        <span class="s1">非权威信息</span>   <span class="s2"><br>
</span>                                                    <span class="s2"><br>
</span>                    |"204"   ;   10.2.5<span class="s1">节</span>:  <span class="s1">无内容</span>       <span class="s2"><br>
</span>                    |"205"   ;   10.2.6<span class="s1">节</span>:  <span class="s1">重置内容</span>      <span class="s2"><br>
</span>                    |"206"   ;   10.2.7<span class="s1">节</span>:  <span class="s1">局部内容</span>      <span class="s2"><br>
</span>                    |"300"   ;   10.3.1<span class="s1">节</span>:  <span class="s1">多样选择</span>      <span class="s2"><br>
</span>                |"301"   ;   10.3.2<span class="s1">节</span>:  <span class="s1">永久移动</span>      <span class="s2"><br>
</span>                |"302"   ;   10.3.3<span class="s1">节</span>:  <span class="s1">创建</span>          <span class="s2"><br>
</span>                    |"303"   ;   10.3.4<span class="s1">节</span>:  <span class="s1">观察别的部分</span>          <span class="s2"><br>
</span>                    |"304"   ;   10.3.5<span class="s1">节</span>:  <span class="s1">只读</span>                  <span class="s2"><br>
</span>                    |"305"   ;   10.3.6<span class="s1">节</span>:  <span class="s1">用户代理</span>              <span class="s2"><br>
</span>                    |"307"   ;   10.3.8<span class="s1">节</span>   <span class="s1">临时重发</span>              <span class="s2"><br>
</span>                |"400"   ;   10.4.1<span class="s1">节</span>:  <span class="s1">坏请求</span>                <span class="s2"><br>
</span>                    |"401"   ;   10.4.2<span class="s1">节</span>:  <span class="s1">未授权的</span>              <span class="s2"><br>
</span>                    |"402"   ;   10.4.3<span class="s1">节</span>:  <span class="s1">必要的支付</span>            <span class="s2"><br>
</span>                    |"403"   ;   10.4.4<span class="s1">节</span>:  <span class="s1">禁用</span>                  <span class="s2"><br>
</span>                    |"404"   ;   10.4.5<span class="s1">节</span>:  <span class="s1">没找到</span>                 <span class="s2"><br>
</span>                    |"405"   ;   10.4.6<span class="s1">节</span>:  <span class="s1">不允许的方式</span>          <span class="s2"><br>
</span>                    |"406"   ;   10.4.7<span class="s1">节</span>:  <span class="s1">不接受</span>                 <span class="s2"><br>
</span>                |"407"   ;   10.4.8<span class="s1">节</span>:  <span class="s1">需要代理验证</span> <span class="s2"><br>
</span>                |"408"   ;   10.4.9<span class="s1">节：</span>         <span class="s1">请求超时</span>              <span class="s2"><br>
</span><span class="s1">　　　　</span>        |"409"   ;   10.4.10<span class="s1">节；</span>        <span class="s1">冲突</span>                  <span class="s2"><br>
</span><span class="s1">　　　　</span>        |"410"   ;   10.4.11<span class="s1">节：</span> <span class="s1">停止</span>                  <span class="s2"><br>
</span><span class="s1">　　　　</span>        |"411"   ;   10.4.12<span class="s1">节：</span> <span class="s1">需要的长度</span>            <span class="s2"><br>
</span><span class="s1">　　　　</span>        |"412"   <span class="s1">；</span>  10.4.13<span class="s1">节；</span>        <span class="s1">预处理失败</span>            <span class="s2"><br>
</span><span class="s1">　　　　</span>        |"413"   ;   10.4.14<span class="s1">节：</span> <span class="s1">请求实体太大</span>      <span class="s2"><br>
</span><span class="s1">　　　　</span>        |"414"   ;   10.4.15<span class="s1">节；</span>        <span class="s1">请求</span>-URI<span class="s1">太大</span>      <span class="s2"><br>
</span>                |"415"   ;   10.4.16<span class="s1">节：</span> <span class="s1">不支持的媒体类型</span>   <span class="s2"><br>
</span>                |"416"   <span class="s1">；</span>  10.4.17<span class="s1">节：</span>        <span class="s1">请求的范围不满足</span>   <span class="s2"><br>
</span>                |"417"   ;   10.4.18<span class="s1">节：</span> <span class="s1">期望失败</span>           <span class="s2"><br>
</span>                |"500"   ;   10.5.1<span class="s1">节</span>:   <span class="s1">服务器内部错误</span>       <span class="s2"><br>
</span>                |"501"   ;   10.5.2<span class="s1">节</span>:          <span class="s1">不能实现</span>             <span class="s2"><br>
</span>                |"502"   ;   10.5.3<span class="s1">节</span>:   <span class="s1">坏网关</span>               <span class="s2"><br>
</span>                |"503"   ;   10.5.4<span class="s1">节</span>:          <span class="s1">服务不能实现</span>         <span class="s2"><br>
</span>                |"504"   ;   10.5.5<span class="s1">节</span>:   <span class="s1">网关超时</span>             <span class="s2"><br>
</span>                |"505"   ;   10.5.6<span class="s1">节</span>:   HTTP<span class="s1">版本不支持</span>  <span class="s2"><br>
</span>              |<span class="s1">扩展码</span>  </p>
<p class="p1"><span class="s1">扩展码</span> =3DIGIT<span class="s2"><br>
</span><span class="s1">注解短语</span>=*</p>
<p class="p2"><span class="s3">HTTP</span>状态码是可扩展的．<span class="s3">HTTP</span>应用程序不需要理解所有已注册状态码的含义，尽管那样的理解显而易见是很合算的．但是，应用程序必须了解由第一位数字指定的状态码的类型，任何未被识别的应答应被看作是该类型的Ｘ<span class="s3">00</span>状态，有一个例外就是未被识别的状态码不能缓存．例如，如果客户机收到一个未被识别的状态码<span class="s3">431</span>，　<span class="s3">Copyright  www.cnpaf.net (2007).          All Rights Reserved.</span><span class="s2"><br>
</span>则可以<a href="http://www.cnpaf.net/class/security/">安全</a>的假定请求有错，且其对待应答的情况是仿佛客户端收到的是<span class="s3">400</span>状态码．在这种情况下，用户代理应当把实体和应答一起提交给用户，因为实体很可能包括说明不平常状态的人认可读的信息．</p>
<p class="p2">６<span class="s3">.2</span>应答报头域</p>
<p class="p2">应答头允许服务器传送应答的附加信息<span class="s3">,</span>这些信息不能放在状态行里<span class="s3">.</span>这些报头域给出有关服务器的信息以及请求<span class="s3">URI</span>指定的资源的下一步的通路．</p>
<p class="p1"><span class="s1">　　　应答报头</span>  =  <span class="s1">接收范围</span>                        ; 14.5<span class="s1">节</span><span class="s2"><br>
</span>                   |<span class="s1">生存时间</span>         ; 14.6<span class="s1">节</span><span class="s2"><br>
</span>                   |Etag            ; 14.19<span class="s1">节</span><span class="s2"><br>
</span>                   |<span class="s1">位置</span>                 ; 14.30<span class="s1">节</span><span class="s2"><br>
</span>                   |<span class="s1">代理认证</span>            ; 14.33<span class="s1">节</span><span class="s2"><br>
</span>                   |<span class="s1">等会再试</span>            ; 14.37<span class="s1">节</span><span class="s2"><br>
</span>                   |<span class="s1">服务器</span>             ; 14.38<span class="s1">节</span><span class="s2"><br>
</span>                   |<span class="s1">变化</span>               ; 14.44<span class="s1">节</span><span class="s2"><br>
</span>                   |WWW<span class="s1">认证</span>                ; 14.47<span class="s1">节</span></p>
<p class="p2">随着<a href="http://www.cnpaf.net/">协议</a>版本的变化<span class="s3">,</span>应答报头可以可靠的扩展．而且，如果通信的所有组成部分都把它当作应答报头域<span class="s3">,</span>新的或试验性的应答报头域可以被给定应答报头域的含义，未被承认的报头域被当作实体报头域．</p>
<p class="p2"><span class="s2"><br>
</span><span class="s3">7</span>。<span class="s3"> </span>实体。</p>
<p class="p2">在未经特别规定的情况下，请求与应答的报文也可以传送实体。<span class="s3"> </span>实体包括实体报头域与实体正文，而有些应答只包括实体报头。在本节内，接收者与发送者既可以指用户端，也可以指服务器，视由谁收发实体而定。</p>
<p class="p2"><span class="s3">7</span>。<span class="s3">1 </span>实体报文域</p>
<p class="p2">实体报文域定义了关于实体正文的维护信息（参数），或在无正文情况下定义了请求的资源。其中一些参数是可选的，一些则是由技术指标规定必须的。</p>
<p class="p1"><span class="s1">实体报头</span> = <span class="s1">允许（</span>Allow<span class="s1">）；</span>                        14.7<span class="s1">节</span><span class="s2"><br>
</span>                        |<span class="s1">内容编码；</span>                                14.11<span class="s1">节</span><span class="s2"><br>
</span>                        |<span class="s1">内容语言；</span>                                14.12<span class="s1">节</span><span class="s2"><br>
</span>                        |<span class="s1">内容长度；</span>                                14.13<span class="s1">节</span><span class="s2"><br>
</span>                        |<span class="s1">内容位置；</span>                                14.14<span class="s1">节</span><span class="s2"><br>
</span>                        |<span class="s1">内容</span>-MD5<span class="s1">；</span>                                14.15<span class="s1">节</span><span class="s2"><br>
</span>                        |<span class="s1">内容范围；</span>                                14.16<span class="s1">节</span><span class="s2"><br>
</span>                        |<span class="s1">内容类型；</span>                                14.17<span class="s1">节</span><span class="s2"><br>
</span>                        |<span class="s1">过期</span>(Expires)<span class="s1">；</span>                        14.21<span class="s1">节</span><span class="s2"><br>
</span>                        |<span class="s1">上次修改；</span>                                14.29<span class="s1">节</span><span class="s2"><br>
</span>                        |<span class="s1">扩展报头</span></p>
<p class="p2">扩展报头<span class="s3">=</span>报文报头</p>
<p class="p2">扩展报头机制允许在不改变<a href="http://www.cnpaf.net/">协议</a>的前提下定义额外的实体报头域，但不保证这些域在收端能够被识别。未被识别的域应当被接收者忽略，且必须被透明转发。</p>
<p class="p2"><span class="s2"><br>
</span><span class="s3">7</span>。<span class="s3">2 </span>实体正文。</p>
<p class="p2">经由<span class="s3">HTTP</span>请求或应答发送的实体正文部分（如果存在的话）的格式与编码方式应由实体报文域决定。<span class="s2"><br>
</span><span class="s3">      </span><span class="s2"><br>
</span><span class="s3">       </span>实体正文<span class="s3">= *</span>八位字节</p>
<p class="p2">如<span class="s3">4</span>。<span class="s3">3</span>节所述，实体正文只有当报文正文存在时才存在。实体正文是通过对报文正文按某种保证<a href="http://www.cnpaf.net/class/security/">安全</a>性且便于传输的传输编码进行解码得到的。</p>
<p class="p2"><span class="s3">7</span>。<span class="s3">2</span>。<span class="s3">1</span>。<span class="s3"> </span>类型。</p>
<p class="p2">对于报文中的实体正文而言，其数据类型由报头中的<span class="s3">"</span>内容类型<span class="s3">"</span>与<span class="s3">"</span>内容编码<span class="s3">"</span>域决定。也即定义了一个双层有序的编码模型：</p>
<p class="p2"><span class="s3">    </span>实体正文<span class="s3">=</span>内容编码（内容类型（数据））</p>
<p class="p2"><span class="s3">"</span>内容类型<span class="s3">"</span>规定了基本数据的媒体类型。<span class="s2"><br>
</span><span class="s3">"</span>内容编码<span class="s3">"</span>则可用来指明对数据施加的任何附加的，通常以数据压缩为目的的编码方式，并将其作为所请求资源的一项属性。<span class="s3"> </span>没有缺省的编码方式。</p>
<p class="p2">任一包含了实体正文的<span class="s3">HTTP/1</span>。<span class="s3">1</span>报文都应包括<span class="s3">"</span>内容类型<span class="s3">"</span>报头域，以定义正文的媒体类型。当且仅当<span class="s3">"</span>内容类型<span class="s3">"</span>域未给出媒体类型时，<span class="s3"> </span>接收者才可以通过查看资源的内容，扩展名或<span class="s3">URL</span>来猜测其媒体类型。若媒体类型仍然未知，接收者应将其作为<span class="s3">"</span>应用<span class="s3">/</span>八位字节流<span class="s3">"</span>类来处理。</p>
<p class="p2"><span class="s3">7</span>。<span class="s3">2</span>。<span class="s3">2 </span>实体长度</p>
<p class="p2">报文的实体长度指的是在对报文进行传输编码前报文正文的长度。<span class="s3">4</span>。<span class="s3">4</span>节定义了确定报文正文传输长度的方法。</p>
<p class="p2"><span class="s2"><br>
</span><span class="s3">8</span>。连接</p>
<p class="p2"><span class="s3">8</span>。<span class="s3">1 </span>持续连接。</p>
<p class="p1">8<span class="s1">。</span>1<span class="s1">。</span>1 <span class="s1">目的</span></p>
<p class="p2">在持续连接之前，为获取每一<span class="s3">URL</span>都建立了独立的<a href="http://www.cnpaf.net/class/tcpandip/"><span class="s3">TCP</span></a><span class="s3"> </span>连接，<span class="s3"> </span>这就加重了<span class="s3">HTTP</span>服务器的负担，易引起<span class="s3">INTERNET</span>阻塞。嵌入式图片与其它相关数据通常使用户在短时间内对同一服务器提交多个请求。目前已有针对这些性能问题的<a href="http://www.cnpaf.net/">分析</a>以及原型实施的结果<span class="s3">[26]</span>，<span class="s3">[30]</span>。<span class="s3"> </span>实施的具体过程和对实际<span class="s3">HTTP/1</span>。<span class="s3">1</span>（<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 2068</span>）的测试均显示了良好的结果<span class="s3">[39]</span>。<span class="s3"> </span>对其他方法也有了初步探究，如<span class="s3">T/<a href="http://www.cnpaf.net/class/tcpandip/">TCP</a> [27]</span>。</p>
<p class="p2">持续<span class="s3">HTTP </span>连接有着诸多的优点：</p>
<p class="p2"><span class="s3">--- </span>通过建立与关闭较少的连接，不仅节省了路由器与主机（客户机，服务器，代理服务器，网关，隧道或高速缓冲存储机）的<span class="s3">CPU</span>时间，还节省了主机用于<a href="http://www.cnpaf.net/class/tcpandip/"><span class="s3">TCP</span></a><a href="http://www.cnpaf.net/">协议</a>控制块的内存。</p>
<p class="p2"><span class="s3">--- HTTP</span>请求与应答可以进入连接流水线。<span class="s3"> </span>流水线方式使得客户无须挨个等待应答即发起多个请求，从而更充分的利用了单个的<a href="http://www.cnpaf.net/class/tcpandip/"><span class="s3">TCP</span></a>连接，减少了崩溃时间。</p>
<p class="p2"><span class="s3">--- </span>在减少<a href="http://www.cnpaf.net/class/tcpandip/"><span class="s3">TCP</span></a>连接中数据包个数的同时，使<a href="http://www.cnpaf.net/class/tcpandip/"><span class="s3">TCP</span></a>有了充裕的时间来确定网络的拥塞状况，缓解了网络拥塞。</p>
<p class="p2"><span class="s3">--- </span>因为无须在创建<a href="http://www.cnpaf.net/class/tcpandip/"><span class="s3">TCP</span></a>连接握手上耗费时间，而使连续请求造成的延迟现象得到改善。</p>
<p class="p2"><span class="s3">--- </span>由于出错不会导致<a href="http://www.cnpaf.net/class/tcpandip/"><span class="s3">TCP</span></a>连接的关闭，<span class="s3">HTTP</span>可以更好的实现自我完善。使用较新版<span class="s3">HTTP</span>的用户会乐于尝试一些新功能，与旧版服务器通信时，则会在接到出错报告后用旧模式重试。</p>
<p class="p2"><span class="s3">HTTP</span>的实现应当采用持续连接。</p>
<p class="p2"><span class="s3">8</span>。<span class="s3">1</span>。<span class="s3">2 </span>总体操作</p>
<p class="p2"><span class="s3">HTTP/1.1 </span>与早期<span class="s3">HTTP </span>版本的一个显著区别在于持续连接是任何<span class="s3">HTTP</span>连接的缺省方式。也就是说，除非另有指定，客户机总应当假定服务器会保持持续连接，即便在接到服务器的出错应答时也应如此。</p>
<p class="p2">持续连接提供了一种可以由客户机或服务器发信号终止<a href="http://www.cnpaf.net/class/tcpandip/"><span class="s3">TCP</span></a>连接的机制。终止连接的信号利用了<span class="s3">"</span>连接<span class="s3">"</span>报头域（<span class="s3">14.10</span>节）。一旦出现了终止连接的信号，客户机便不可再向此连接提出任何新请求。</p>
<p class="p1">8<span class="s1">。</span>1<span class="s1">。</span>2<span class="s1">。</span>1 <span class="s1">谈判</span></p>
<p class="p2">除非请求的连接报头域中包括了<span class="s3">"</span>终止连接<span class="s3">"</span>的符号，<span class="s3">HTTP/1</span>。<span class="s3">1</span>服务器总可以假定<span class="s3">HTTP/1</span>。<span class="s3">1 </span>客户机想要维持持续连接。如果服务器想在发出应答后立即终止连接，它应当发送一个含有终止要求的连接报头域。</p>
<p class="p2">无论是客户机或服务器发起终止连接，这都是本次连接的最后一个请求。</p>
<p class="p2">除非经明确指出，客户机与服务器不应假定低版<span class="s3">HTTP</span>会自动采用持续连接方式。请参见<span class="s3">19</span>。<span class="s3">6</span>。<span class="s3">2</span>节关于与<span class="s3">HTTP/1</span>。<span class="s3">0</span>客户机后向兼容性的有关内容。</p>
<p class="p2">为了维持持续连接，连接中的报文都必须有如<span class="s3">4</span>。<span class="s3">4</span>节所述的自定义报文长度（即不是由连接终止定义的长度）。</p>
<p class="p2"><span class="s3">8</span>。<span class="s3">1</span>。<span class="s3">2</span>。<span class="s3">2 </span>流水线</p>
<p class="p2">支持持续连接的客户机可以以流水线方式发送请求（即无须等待应答而发送多个请求）。服务器则必须将其应答按接到请求的顺序发出。</p>
<p class="p2">建立连接后立即采用持续连接与流水线方式的客户机应作好初次流水线尝试失败后重试的准备，而不可在持续连接尚未确定时就连续发送请求。客户机还必须为服务器在发出所有应答之前就结束连接的情况作好重发请求的准备。</p>
<p class="p2">客户机不应该用非等幂方法或非等幂方法序列（参见<span class="s3">9</span>。<span class="s3">1</span>。<span class="s3">2</span>节）连发请求。否则，过早终止的传输层连接会导致不确定的结果。</p>
<p class="p2"><span class="s3">8</span>。<span class="s3">1</span>。<span class="s3">3 </span>代理服务器</p>
<p class="p2">使代理服务器正确地实现<span class="s3">14</span>。<span class="s3">10</span>节所规定的连接报头域的属性是非常关键的。</p>
<p class="p2">代理服务器必须独立于它所连接的客户机，原服务器（或其它代理服务器）而发出持续连接的信号。每一持续连接仅针对传输层链接。</p>
<p class="p2">代理服务器不可与一台<span class="s3">HTTP/1.0</span>客户机建立<span class="s3">HTTP/1</span>。<span class="s3">1</span>持续连接（请参见<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 2068 [33] </span>中关于<span class="s3">HTTP/1</span>。<span class="s3">0</span>客户机上实现<span class="s3">"</span>维持活跃态<span class="s3">"</span>报头问题的探讨及资料）</p>
<p class="p2"><span class="s3">8</span>。<span class="s3">1</span>。<span class="s3">4 </span>实际的考虑</p>
<p class="p2">服务器通常有一个时限值，超过一定时间即不再维系处于非活跃态的连接。代理服务器会选一个较高的值，因为客户机很可能会与同一服务器建立多个连接。持续连接方式的采用对于客户机与服务器的时限均未提出任何要求。当客户机或服务器希望超时终止时，<span class="s3"> </span>它应按规范终止传输连接。客户端与服务器端应始终注意对方是否终止了连接，并适当的予以应答。若客户机或服务器未能及时检测到对方已终止了连接，将会造成不必要的网络资源浪费。</p>
<p class="p2">客户机，服务器，或代理服务器可能在任意时刻终止传输连接。比如，客户机可能正想发出新的请求，而此时服务器却决定关闭<span class="s3">"</span>闲置<span class="s3">"</span>的连接。在服务器看来，连接是在闲置状况下被关闭的，<span class="s3"> </span>而客户机却以为请求在进行中。</p>
<p class="p2">这表明客户机，服务器与代理服务器必须有能力从非同步的连接终止事件中恢复。只要请求序列是等幂的（参见<span class="s3">9</span>。<span class="s3">1</span>。<span class="s3">2</span>节），客户端软件就应自动重新发起传输层连接并重传被废弃的请求序列。<span class="s3"> </span>对非等幂方法或序列不可自动重试，但用户代理可以向手工操作员提供重发请求的机会。用户代理软件对应用程序基于句法理解的确认可以用来代替人工方式。若重试失败，则不应允许再试。</p>
<p class="p2">服务器在每次连接中只要有可能，总应至少应答一个请求。除非出于网络或客户端的故障，服务器不应在传送应答的中途断开连接。</p>
<p class="p2">使用持续连接的客户机应限制与某一服务器同时连接的个数。单用户客户机不应与任一服务器或代理服务器保持两个以上的连接。代理服务器与其它服务器或代理之间应维护<span class="s3">2*N</span>个连接，其中<span class="s3">N</span>是同时在线的用户数。设定这一规则是为了改进<span class="s3">HTTP</span>应答时间且避免拥塞。</p>
<p class="p2"><span class="s3">8</span>。<span class="s3">2 </span>报文传输要求、</p>
<p class="p2"><span class="s3">8</span>。<span class="s3">2</span>。<span class="s3">1 </span>持续连接与流量控制</p>
<p class="p2"><span class="s3">HTTP/1</span>。<span class="s3">1</span>服务器应当保持持续连接并使用<a href="http://www.cnpaf.net/class/tcpandip/"><span class="s3">TCP</span></a>的流量控制机制来解决临时过载，而不是在终止连接后指望客户端的重试。后一方法会恶化网络阻塞。</p>
<p class="p2"><span class="s3">8</span>。<span class="s3">2</span>。<span class="s3">2 </span>监视连接中出错状态的报文</p>
<p class="p2">发送报文正文的<span class="s3">HTTP/1</span>。<span class="s3">1</span>（或更新）客户机应在传输请求的同时监视连接是否处于出错状态。若客户机发现了错误，它应当立即停止正文的传送。若正文是以块编码方式发送的（<span class="s3">3</span>。<span class="s3">6</span>节），可以用一长度为零的块和空报尾来提前标记报文结束。若正文前有<span class="s3">"</span>内容长度<span class="s3">"</span>报头，则客户机必须关闭连接。</p>
<p class="p2"><span class="s3">8</span>。<span class="s3">2</span>。<span class="s3">3 100</span>号状态的用途</p>
<p class="p2"><span class="s3">100</span>号状态的目的在于帮助那些发送含有请求正文的请求报文的客户机在发送请求正文之前推测服务器看到请求报头后是否愿意接收请求。有些时候，如果服务器不看正文就弃置报文的话，客户机对正文的发送就多此一举了。</p>
<p class="p2">对<span class="s3">HTTP/1</span>。<span class="s3">1 </span>客户机的要求：</p>
<p class="p2"><span class="s3">--- </span>若客户机在发送请求正文之前等候<span class="s3">100</span>（继续）应答，则它必须发送填有<span class="s3">"100--</span>继续<span class="s3">"</span>期望的<span class="s3">"</span>期待请求<span class="s3">"</span>报头域（<span class="s3">14</span>。<span class="s3">20</span>节）。</p>
<p class="p2"><span class="s3">--- </span>若客户机不需要发送请求正文，则它不得发送填有<span class="s3">"100--</span>继续<span class="s3">"</span>期望的<span class="s3">"</span>期待请求<span class="s3">"</span>报头域（<span class="s3">14</span>。<span class="s3">20</span>节）。</p>
<p class="p2">由于存在旧的实现方法，<a href="http://www.cnpaf.net/">协议</a>允许出现诸如客户机发出了<span class="s3">"</span>期望：<span class="s3">100-</span>继续<span class="s3">" </span>却没接到<span class="s3">417</span>（期望失败）或<span class="s3">100</span>（继续）状态的混乱局面存在。<span class="s3"> </span>因此，当客户机将这一报头域发给它从未接到<span class="s3">100</span>（继续）状态的原服务器（通常是通过代理）时，<span class="s3"> </span>客户机不应在发送请求正文前无限期地等待。</p>
<p class="p2">对<span class="s3">HTTP/1</span>。<span class="s3">1</span>原服务器的要求：</p>
<p class="p2"><span class="s3">--- </span>在接到<span class="s3">"</span>期望<span class="s3">"</span>请求报头域填有<span class="s3">"100-</span>继续<span class="s3">"</span>期望的请求时，原服务器必须以<span class="s3">100</span>（继续）状态应答并继续读入数据流，或者以终止状态码应答。原服务器在发送<span class="s3">100</span>（继续）应答之前不得等待。若以终止状态码应答，它既可关闭传输层连接，也可继续读入数据而丢弃请求的剩余部分。但此时它不得按客户机所请求的方式运行。</p>
<p class="p2"><span class="s3">--- </span>如请求报文不含填有<span class="s3">"100-</span>继续<span class="s3">"</span>的<span class="s3">"</span>期望<span class="s3">"</span>报头域，<span class="s3"> </span>原服务器不应发送<span class="s3">100</span>（继续）应答。当请求来自<span class="s3">HTTP/1</span>。<span class="s3">0</span>（或更早）客户机时也不得发送<span class="s3">100</span>（继续）应答。对此规定有一例外：为了与<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 2068</span>兼容，服务器对于未含填有<span class="s3">"100-</span>继续<span class="s3">"</span>的<span class="s3">"</span>期望<span class="s3">"</span>报头域的<span class="s3">PUT</span>或<span class="s3">POST </span>请求可以应答<span class="s3">100</span>（继续）状态。这一例外的目的在于尽量减少由<span class="s3">100</span>（继续）状态的未申明等待引起的客户机处理延迟，仅适用于<span class="s3">HTTP/1</span>。<span class="s3">1</span>请求，和其它<span class="s3">HTTP </span>版本的请求无关。</p>
<p class="p2"><span class="s3">--- </span>若已经接到相应请求的部分或全部请求正文，原服务器可以免发<span class="s3">100</span>（继续）应答。</p>
<p class="p2"><span class="s3">--- </span>一旦请求正文被收到处理，发出<span class="s3">100</span>（继续）应答的原服务器除非过早切断传输层连接，否则最终必须发送终止状态码。</p>
<p class="p2"><span class="s3">--- </span>若原服务器接到不含填有<span class="s3">"100-</span>继续<span class="s3">"</span>的<span class="s3">"</span>期望<span class="s3">"</span>报头域的请求，该请求含有请求正文，而服务器又在从传输层连接读入正文之前就应答了终止状态码，则服务器不应在读完全部请求或客户机终止连接前关闭连接。<span class="s3"> </span>否则，客户机可能无法可靠地<span class="s3"> </span>接收应答报文。然而，这一要求在阐释中不应阻止服务器防卫拒绝服务的攻击或有严重缺陷的客户程序。</p>
<p class="p2">对代理服务器的要求：</p>
<p class="p2"><span class="s3">--- </span>若代理服务器接到包含填有<span class="s3">"100-</span>继续<span class="s3">"</span>的<span class="s3">"</span>期望<span class="s3">"</span>报头域的请求，且代理服务器要么知道下一站服务器遵循<span class="s3">HTTP/1</span>。<span class="s3">1</span>或更高版<a href="http://www.cnpaf.net/">协议</a>，要么不知下一站服务器的<span class="s3">HTTP</span>版本，则它必须连同<span class="s3">"</span>期望<span class="s3">"</span>报头域一起转发此请求。</p>
<p class="p2"><span class="s3">--- </span>若且代理服务器知道下一站服务器版本是<span class="s3">HTTP/1</span>。<span class="s3">0</span>或更低，则它不得转发此请求，而应应答以<span class="s3">417</span>（期望失效）状态。</p>
<p class="p2"><span class="s3">--- </span>代理服务器应当维护一高速缓存，以记录新近访问到的下一站点服务器的<span class="s3">HTTP</span>版本号。</p>
<p class="p2"><span class="s3">--- </span>若接到的请求来自于版本是<span class="s3">HTTP/1</span>。<span class="s3">0</span>（或更低）的客户机，不含填有<span class="s3">"100-</span>继续<span class="s3">"</span>的<span class="s3">"</span>期望<span class="s3">"</span>报头域的请求，则代理服务器不得转发<span class="s3">100</span>（继续）应答。<span class="s3"> </span>这一要求可覆盖<span class="s3">1xx</span>应答转发的一般规则（参见<span class="s3">10</span>。<span class="s3">1</span>节）。</p>
<p class="p2"><span class="s3">8</span>．<span class="s3">2</span>．<span class="s3">4 </span>服务器过早关闭连接时客户机的行为</p>
<p class="p2">如果<span class="s3">HTTP/1</span>。<span class="s3">1 </span>客户机发出一条含有请求正文但不含填有<span class="s3">"100-</span>继续<span class="s3">"</span>的<span class="s3">"</span>期望<span class="s3">"</span>报头域的请求，并且客户机直接与<span class="s3">HTTP/1</span>。<span class="s3">1</span>原服务器相连，在从服务器处接到任何状态信息之前就发现连接被关闭，那么客户机应当重试请求。在重试时，客户机何以采用如下所述的<span class="s3">"</span>二进制指数后退算法<span class="s3">"</span>以确保获得可靠应答：</p>
<p class="p2"><span class="s3">1</span>．<span class="s3"> </span>向服务器发起一新连接。<span class="s2"><br>
</span><span class="s3">2</span>．<span class="s3"> </span>发送请求的报头。<span class="s2"><br>
</span><span class="s3">3</span>．<span class="s3"> </span>初始化变量<span class="s3">R</span>为通往服务器的往返时间的估计值（比如基于建立连接的时间），或在无法估计往返时间时设为一常数值<span class="s3">5</span>秒。<span class="s2"><br>
</span><span class="s3">4</span>．<span class="s3"> </span>计算<span class="s3">T=R*</span>（<span class="s3">2**N</span>），<span class="s3">N</span>为此前重试请求的次数。<span class="s2"><br>
</span><span class="s3">5</span>．<span class="s3"> </span>等待服务器发来的出错应答或是<span class="s3">T</span>秒（两者中时间较短的）。<span class="s2"><br>
</span><span class="s3">6</span>．<span class="s3"> </span>若没等到出错应答，<span class="s3">T</span>秒后发送请求正文。<span class="s2"><br>
</span><span class="s3">7</span>．<span class="s3"> </span>若客户机发现连接被提前终止，转到第<span class="s3">1</span>步，直到请求被接受，接到出错应答，或是用户因不耐烦而终止了重试进程。</p>
<p class="p2">在任意环节上，客户机如果接到出错状态，<span class="s2"><br>
</span><span class="s3">--- </span>不应再继续，<span class="s3"> </span>并且<span class="s2"><br>
</span><span class="s3">--- </span>如完成请求报文的发送则应终止连接</p>
<p class="p2"><span class="s2"><br>
</span>９<span class="s3"> </span>方法定义</p>
<p class="p2"><span class="s3">HTTP/1.1</span>常规方法的定义如下<span class="s3">.</span>虽然这个定义可以展开<span class="s3">,</span>但附加的方法不能被假定分享和个别扩展的客户机和服务器同样的语义<span class="s3">.</span></p>
<p class="p2">主机请求应答报头<span class="s3">(14.23</span>节<span class="s3">)</span>必须符合所有的<span class="s3">HTTP/1.1</span>请求<span class="s3">.</span></p>
<p class="p1">9.1 <a href="http://www.cnpaf.net/class/security/"><span class="s1">安全</span></a><span class="s1">和等幂</span>(Idempotent)<span class="s1">方法</span></p>
<p class="p1">9.1.1 <a href="http://www.cnpaf.net/class/security/"><span class="s1">安全</span></a><span class="s1">方法</span></p>
<p class="p2">实现程序应当知道软件通过在<span class="s3">Internet</span>上的交互来扮演用户<span class="s3">,</span>且应该仔细的允许用户知道任何它们可能采取的行动<span class="s3">,</span>这些行动可能给他们自己或他人带来无法预料的结果<span class="s3">.</span></p>
<p class="p2">特别的<span class="s3">.</span>这样的惯例已经形成<span class="s3">,</span>就是<span class="s3">GET</span>和<span class="s3">HEAD</span>方法除了补救外不应该有别的采取措施的含义<span class="s3">.</span>这些方法应该被看作<span class="s3">"<a href="http://www.cnpaf.net/class/security/"><span class="s1">安全</span></a>".</span>这允许用户代理描绘其他方法<span class="s3">,</span>像<span class="s3">POST,PUT,DELETE,</span>在某种意义上<span class="s3">,</span>用户知道某种不<a href="http://www.cnpaf.net/class/security/">安全</a>的行为被请求的事实<span class="s3">.</span></p>
<p class="p2">自然<span class="s3">, </span>随着<span class="s3">GET</span>请求的实现<span class="s3">,</span>不可能保证服务器不产生副作用<span class="s3">;</span>事实上<span class="s3">,</span>一些动态的资源考虑到那样的特征<span class="s3">.</span>在这里重要的区别是用户没有请求副作用<span class="s3">,</span>因此不应该为此承担责任<span class="s3">.</span></p>
<p class="p1">9.1.2 <span class="s1">等幂方法</span></p>
<p class="p2">方法也可以等幂的性质<span class="s3">,</span>这种情况下<span class="s3">(</span>除了出错或终止问题<span class="s3">)N&gt;0</span>个同样请求的副作用和单个请求一样<span class="s3">.</span>方法<span class="s3">GET,HEAD,PUT,DELETE</span>都有这种性质<span class="s3">.</span>而且<span class="s3">,</span>方法<span class="s3">OPTIONS</span>和<span class="s3">TRACE</span>不应该有副作用<span class="s3">,</span>等幂就是这样的含义<span class="s3">.</span>然而<span class="s3">,</span>有可能几个请求的序列是不等幂的<span class="s3">,</span>即使在那样的序列中所有方法单独实现都是等幂的<span class="s3">(</span>如果整个序列整体的实现结果总是相同的<span class="s3">,</span>即不因序列整体<span class="s3">,</span>部分的重新实现而变化<span class="s3">,</span>则序列是等幂的<span class="s3">).</span>例如<span class="s3">,</span>如果一个序列实现的结果依赖一个序列中后来可以修改的值<span class="s3">,</span>则该序列不是等幂的<span class="s3">.</span></p>
<p class="p2">没有副作用的序列是等幂的<span class="s3">(</span>倘若在同样的资源配置下不同时操作<span class="s3">)</span></p>
<p class="p1">9.2  OPTIONS(<span class="s1">选项）</span></p>
<p class="p2"><span class="s3">OPTIONS</span>方法描述了在请求<span class="s3">URI</span>确定的请求<span class="s3">/</span>应答过程中通信条件是否可行的信息<span class="s3">.</span>该方法允许客户机确定条件或设备<span class="s3">,</span>其与资源或服务器的没有暗示资源操作或初始化资源重建的情况下的性能有关<span class="s3">,</span></p>
<p class="p2">这种方法的应答是不能缓存的<span class="s3">.</span></p>
<p class="p2">如果<span class="s3">OPTIONS</span>请求包括一个实体<span class="s3">(</span>用来指示内容长度或传输码的存在<span class="s3">),</span>接着媒体类型应该有一个内容内型域来确定<span class="s3">.</span>虽然这种规定对那样的主体没有定义任何功能<span class="s3">,</span>未来<span class="s3">HTTP</span>的扩展可以用<span class="s3">OPTIONS</span>域来安排更多细节性的有关服务器的询问<span class="s3">.</span>一台不支持扩展的服务器可以抛弃请求正文<span class="s3">.</span></p>
<p class="p2">如果请求<span class="s3">URI</span>是一个星号<span class="s3">("*"), OPTIONS</span>请求特意应用于总的服务器而不是特定的服务资源<span class="s3">.</span>既然服务器的通信条件取决于资源<span class="s3">,"*"</span>请求只是作为<span class="s3">"ping" </span>或<span class="s3"> "no-op</span>类型的方法才有用<span class="s3">;</span>它只能允许客户机测试服务器的性能<span class="s3">.</span>例如<span class="s3">,</span>这能被用来检测一台代理机即是否支持<span class="s3">HTTP/1.1.</span></p>
<p class="p2">如果请求<span class="s3">URI</span>不是一个星号<span class="s3">("*"), OPTIONS</span>请求只是当和资源通信时应用于条件是否可能<span class="s3">.</span></p>
<p class="p2">应答<span class="s3">200</span>应当包括表示服务器实现和可应用于资源的可选择的特征报头域<span class="s3">,.</span>可能包括这种规范定义未定义的扩展<span class="s3">.</span>规范没有定义正文<span class="s3">,</span>但未来<span class="s3">HTTP</span>的扩展可能会定义<span class="s3">,</span>商议内容可能会用于选择适当的应答格式<span class="s3">.</span>如果没有应答体被包括进来<span class="s3">,</span>应答必须包括一个值为零的内容长度域<span class="s3">.</span></p>
<p class="p2">最大转发请求报头域可以用于请求过程中特定的代理机<span class="s3">.</span>当代理机收到可以继续传播的绝对<span class="s3">URI</span>的<span class="s3">OPTIONS</span>请求时<span class="s3">,</span>代理机必须检测最大转发域<span class="s3">.</span>如果最大转发域的值是零<span class="s3">,</span>代理机禁止转发信息<span class="s3">.</span>相反的<span class="s3">,</span>代理机将回答它自己的通信条件<span class="s3">.</span>如果是大于零的整数<span class="s3">,</span>当代理机转发请求时<span class="s3">,</span>该域的值将逐渐减小<span class="s3">.</span>如果请求中没有该域<span class="s3">,</span>则转发请求当中也会没有<span class="s3">.</span></p>
<p class="p1"><span class="s2"><br>
</span>9.3 GET<span class="s1">（获取）</span></p>
<p class="p2"><span class="s3">GET</span>方法重建信息的内容<span class="s3">(</span>正文的形式<span class="s3">)</span>由请求<span class="s3">URI</span>来确定<span class="s3">.</span>如果请求<span class="s3">URI</span>指数据产生的过程<span class="s3">,</span>它是在应答中产生<span class="s3">,</span>被当作正文返回的数据<span class="s3">,</span>而不是过程的源文本<span class="s3">,</span>除非文本碰巧是过程的输出<span class="s3">.</span></p>
<p class="p1"><span class="s1">如果请求信息包括</span> If-Modified-Since, If-Unmodified-Since,If-Match, If-None-Match, or If-Range<span class="s1">报头域</span>, GET<span class="s1">的语义将变成</span>"<span class="s1">条件（</span>conditial<span class="s1">）</span> GET". <span class="s1">只有在条件报头域</span>(conditional header)<span class="s1">所描述的环境下</span>, <span class="s1">条件</span>GET<span class="s1">方法请求实体被传输</span>. "<span class="s1">条件</span>GET"<span class="s1">方法用于减少不必要的网络使用</span>,<span class="s1">这种使用允许在没有多种请求或客户机已经获传输数据的情况下刷新缓存实体</span>.</p>
<p class="p2">如果请求信息包括范围（<span class="s3">Range)</span>报头域<span class="s3">, GET</span>方法的语义将变成<span class="s3">"</span>部分<span class="s3">(partial)GET","</span>部分<span class="s3">GET"</span>请求只要求传输部分实体<span class="s3">,</span>如<span class="s3">14.35</span>节指定的那样<span class="s3">. </span>部分<span class="s3">GET</span>方式通过允许当客户端没有得到全部的传输数据时部分的重建数据来减少不必要的网络使用<span class="s3">.</span></p>
<p class="p2">只有当<span class="s3">GET</span>请求碰到<span class="s3">13</span>章里所描述的支持<span class="s3">HTTP</span>缓存的设备时<span class="s3">,</span>应答才是可缓存的<span class="s3">.</span></p>
<p class="p2">当使用表格形式时<span class="s3">.</span>请参看<span class="s3">15.1.3</span>节关于<a href="http://www.cnpaf.net/class/security/">安全</a>的考虑<span class="s3">.</span></p>
<p class="p1"><span class="s2"><br>
</span>9.4 HEAD<span class="s1">（报头）</span></p>
<p class="p2">除了应答中禁止返回消息正文外<span class="s3">,HEAD</span>方法与<span class="s3">GET</span>方法一样<span class="s3">.</span>包含在<span class="s3">HTTP</span>报头以后应答报头头请求的信息与<span class="s3">POST</span>去应答<span class="s3">GET</span>请求的信息是相同的<span class="s3">.</span>这种方法能用于获得关于实体更多的信息<span class="s3">,</span>没有传输实体正文本身的请求暗示了这种信息<span class="s3">.</span>这个方法常用来检查超文本链接的有效性<span class="s3">,</span>可到达性和最近的修正<span class="s3">.</span></p>
<p class="p2">当包含在应答中的信息可以用来更新以前缓存的来自资源的实体时<span class="s3">,</span>对<span class="s3">HEAD</span>请求的应答是可缓存的<span class="s3">.</span>如果新域的值显示缓存的实体不同于当前的实体时<span class="s3">(</span>这将在内容长度<span class="s3">,</span>内容<span class="s3">-MD5,ETAG</span>或最后更新时间中表现出来<span class="s3">),</span>缓冲区就抛弃缓存的实体<span class="s3">.</span></p>
<p class="p2"><span class="s2"><br>
</span><span class="s3">9.5 POST</span>（张贴）<span class="s2"><br>
</span>在<span class="s3">POST </span>方法适用的请求中<span class="s3">,</span>原服务器接收附加在请求后的实体<span class="s3">,</span>该实体后作为请求行里请求<span class="s3">URI</span>指定的资源的次要部分<span class="s3">,. POST </span>被设计为具有如下的功的统一的方法<span class="s3">:</span></p>
<p class="p2"><span class="s3">- </span>已有资源的注解<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">- </span>在电子布告版<span class="s3">,</span>新闻组<span class="s3">,</span>邮箱或类似的主题组贴一些信息<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">- </span>提供数据块<span class="s3">,</span>像确认表单数据处理的结果<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">- </span>通过附加的操作扩充数据库<span class="s3">.</span></p>
<p class="p2"><span class="s2"><br>
</span><span class="s3">POST</span>方法实现的实际功能取决于服务器<span class="s3">,</span>且往往取决于请求<span class="s3">URI.POST</span>实体属于<span class="s3">URI,</span>就像文档属于包括它的目录<span class="s3">,</span>新闻主题属于它所在的新闻组<span class="s3">,</span>或纪录属于数据库<span class="s3">.</span></p>
<p class="p2"><span class="s3">POST</span>方法实现的操作不会作用于<span class="s3">URI</span>可以鉴识别的资源<span class="s3">.</span>在这种情况下<span class="s3">,</span>无论<span class="s3">2000(OK)</span>还是<span class="s3">2004(</span>无目录<span class="s3">)</span>是合适的应答状态<span class="s3">,</span>取决于应答是否包括描述结果的实体<span class="s3">.</span></p>
<p class="p2">如果原服务器上已经建立了资源<span class="s3">,</span>应答将是<span class="s3">201(</span>建立<span class="s3">)</span>且包括描述请求状态<span class="s3">,</span>指向新的资源的实体和一个本地报头<span class="s3">(</span>看<span class="s3">14.30</span>节<span class="s3">).</span></p>
<p class="p2">这种方法的应答是不可缓存的<span class="s3">,</span>除非应答包括合适的缓冲控制或终止报头域<span class="s3">.</span>然而<span class="s3">,303(</span>看别的<span class="s3">)</span>应答可直接用于用户代理重建可缓存资源<span class="s3">.</span></p>
<p class="p2"><span class="s3">POST </span>请求必须像<span class="s3">8.2</span>节所描述的那样服从消息传输的需要<span class="s3">.</span></p>
<p class="p2">参见<span class="s3">15.1.3</span>节关于<a href="http://www.cnpaf.net/class/security/">安全</a>性的考虑<span class="s3">.</span></p>
<p class="p1">9.6 PUT<span class="s1">（放置）</span></p>
<p class="p2"><span class="s3">PUT</span>方法要求所附实体存储在提供的请求<span class="s3">URI</span>下<span class="s3">.</span>假如请求<span class="s3">URI</span>指的是已经存在的资源<span class="s3">,</span>所附的实体应当被当作原服务器中已修改的版本<span class="s3">. </span>假如请求<span class="s3">URI</span>指的不是已经存在的资源<span class="s3">,</span>而<span class="s3">URI</span>可以被客户代理定义成新的资源<span class="s3">,</span>原服务器可以建立该<span class="s3">URI</span>资源<span class="s3">.</span>假设建立了新资源<span class="s3">,</span>原服务器必须通过<span class="s3">201(</span>建立<span class="s3">)</span>应答通知用户代理<span class="s3">.</span>如果修改了已有资源<span class="s3">,</span>将发送<span class="s3">200(OK)</span>或<span class="s3">204(</span>无内容<span class="s3">)</span>应答表示请求的成功完成<span class="s3">.</span>如果对于该<span class="s3">URI</span>资源不能创建或修正<span class="s3">,</span>将给出合理的出错应答来反映问题所在<span class="s3">.</span>实体容器不能忽视任何不被理解或实现的内容<span class="s3">-*(</span>例如内容范围<span class="s3">)</span>报头<span class="s3">,</span>这时必须返回<span class="s3">501(</span>未实现<span class="s3">)</span>应答<span class="s3">.</span></p>
<p class="p2">如果请求经过高速缓冲存储器和请求<span class="s3">URI</span>标识一个或多个当前缓存的实体<span class="s3">,</span>这些实体将被抛弃<span class="s3">.</span>这个方法的应答是不可缓存的<span class="s3">.</span></p>
<p class="p2"><span class="s3">POST</span>和<span class="s3">PUT</span>请求基本的不同点反映在请求<span class="s3">URI</span>的不同意义<span class="s3">.POST</span>方法中的<span class="s3">URI</span>标识将处理附加实体的资源<span class="s3">.</span>资源可以是数据接收过程<span class="s3">,</span>一个网关和一些<a href="http://www.cnpaf.net/">协议</a><span class="s3">,</span>或一个接收注解的分散的实体<span class="s3">.</span>与之相对照的是<span class="s3">, PUT</span>请求中的<span class="s3">URI</span>标识请求所附的实体<span class="s3">-</span>用户代理了解什么<span class="s3">URI</span>是有意的和服务器禁止试图应用请求于别的资源<span class="s3">.</span>假如服务器希望请求应用于不同的<span class="s3">URI,</span></p>
<p class="p2">它必须是<span class="s3">301(</span>永久移动<span class="s3">)</span>应答<span class="s3">;</span>用户代理可以自己决定关于是否改变请求路由<span class="s3">.</span></p>
<p class="p2">单个的资源可以被许多不同的<span class="s3">URI</span>确定<span class="s3">.</span>例如<span class="s3">,</span>一个主题可以有一个<span class="s3">URI</span>识别当前版本<span class="s3">,</span>这从<span class="s3">URI</span>识别每一个特定的版本分离开来<span class="s3">.</span>在这种情况下<span class="s3">,PUT</span>请求中一般的<span class="s3">URI</span>导致服务器<span class="s3">,</span>而其他的<span class="s3">URI</span>由原服务器定义<span class="s3">.</span></p>
<p class="p2"><span class="s3">HTTP/1.1</span>没有定义<span class="s3">PUT</span>方法如何影响原服务器的状态<span class="s3">.</span></p>
<p class="p2"><span class="s3">PUT</span>请求必须服从<span class="s3">8.2</span>节描述的信息传输需要<span class="s3">.</span></p>
<p class="p2">除了特定的实体报头说明<span class="s3">,POST</span>方法中的实体头应该应用于<span class="s3">POST</span>方法创建或修改的资源<span class="s3">.</span></p>
<p class="p1">9.7 DELETE<span class="s1">（删除）</span></p>
<p class="p2"><span class="s3">DELELE</span>方法要求原服务器释放请求<span class="s3">URI</span>指向的资源<span class="s3">.</span>这种方法可以通过原服务器上人的强行干涉而制止<span class="s3">(</span>括其他手段<span class="s3">).</span>客户机不能担保操作已经实现了<span class="s3">,</span>即使从原服务器返回的状态码说明操作已经成功的完成<span class="s3">.</span>但如果当时应答未给出的话<span class="s3">,</span>服务器不应该表示成功<span class="s3">,</span>它打算释放资源或移到不能访问的位置<span class="s3">.</span></p>
<p class="p2">假如应答包括描述状态的实体<span class="s3">,</span>成功的应答是<span class="s3">200(OK),</span>如果操作仍未制定<span class="s3">,</span>则应答为<span class="s3">202(</span>接收<span class="s3">),</span>如果操作已制定但应答不包括实体<span class="s3">,</span>则应答为<span class="s3">204(</span>无内容<span class="s3">).</span></p>
<p class="p2">如果请求经过缓存和请求<span class="s3">URI</span>识别一个或多个当前缓存的实体<span class="s3">,</span>这些实体将被抛弃<span class="s3">.</span>这个方法的应答是不可缓存的<span class="s3">.</span></p>
<p class="p2">如果请求经过缓存和请求<span class="s3">URI</span>识别一个或多个当前缓存的实体<span class="s3">,</span>这些实体将被抛弃<span class="s3">.</span>这个方法的应答是不可缓存的<span class="s3">.</span></p>
<p class="p2">如果请求经过高速缓冲存储器和请求<span class="s3">URI</span>标识一个或多个当前缓存的实体<span class="s3">,</span>这些实体将被抛弃<span class="s3">.</span>这个方法的应答是不可缓存的<span class="s3">.</span></p>
<p class="p1">9.8 TRACE<span class="s1">（跟踪）</span></p>
<p class="p2"><span class="s3">TRACE</span>方法用于调用远程的<span class="s3">,</span>应用层循环请求消息<span class="s3">.</span>请求最终的接收者应当反射从客户机作为<span class="s3">200</span>应答的实体正文收到的信息<span class="s3">.</span>最终的接收者也是原服务器或在请求中收到最大转发数量值第一个代理服务器或网关<span class="s3"> (</span>看<span class="s3">14.31</span>节<span class="s3">).TRACE</span>请求不包括实体<span class="s3">.</span></p>
<p class="p2"><span class="s3">TRACE</span>允许客户端了解在请求的另一端收到的内容和用数据测试或诊断信息<span class="s3">.</span>经由报头域的值尤其重要<span class="s3">,</span>因为它表示请求过程的路径<span class="s3">.</span>最大转发数域的使用允许客户端限制请求链的长度<span class="s3">,</span>这对在无限循环中找出前向路径的代理服务器是很有用的<span class="s3">.</span></p>
<p class="p2">如果请求有效<span class="s3">,</span>在实体正文中应答包括整个请求信息<span class="s3">,</span>具有<span class="s3">"</span>消息<span class="s3">/http"</span>的<span class="s3"> </span>内容<span class="s3">-</span>形式<span class="s3">.</span>这种方法的应答禁止缓存<span class="s3">.</span></p>
<p class="p2"><span class="s3">9.9 CONNECT</span>（连接）<span class="s2"><br>
</span>本说明中保留<span class="s3">CONNECT</span>方法用于能动态建立起隧道的代理服务器<span class="s3">(</span>例<span class="s3">SSL </span>隧道<span class="s3">[44]).</span></p>
<p class="p1"> </p>
<p class="p2"><span class="s3">10.</span>状态代码定义</p>
<p class="p2"><span class="s3">   </span>每一段状态代码在下面被描述<span class="s3">,</span>包括他所能遵循的方法的描述和在应答中所必需的维护信息<span class="s3">.</span></p>
<p class="p1">10.1 <span class="s1">信息</span> 1xx</p>
<p class="p2">状态代码的类简单描述了一个临时的回答<span class="s3">,</span>只是由状态行和可选择的报头所组成<span class="s3">,</span>并且由空行所决定<span class="s3">,</span>状态代码类没有所需的报头<span class="s3">.</span>自从<span class="s3">HTTP/1.0</span>没有定义任何<span class="s3">1xx</span>状态代码<span class="s3">,</span>在实验的条件下服务器严禁发送一个<span class="s3">1xx</span>应答给<span class="s3">HTTP/1.0</span>客户<span class="s3">.</span><span class="s2"><br>
</span>客户必须准备在接受通常应答之前接受一个或者多个<span class="s3">1xx</span>应答，甚至客户并不期待一个<span class="s3">100</span>状态的报文。不被期待出现的<span class="s3">1xx</span>状态应答也许会被用户端的代理所忽略。<span class="s2"><br>
</span><span class="s3">     </span><span class="s2"><br>
</span>代理服务器必须转寄<span class="s3">1xx</span>应答，除非代理服务器和客户之间的联系被切断，或者除非代理服务器本身请求<span class="s3">1xx</span>应答的发生。（举例说明如果一个代理服务器在它转寄一个请求时会加上一个<span class="s3">"</span>期望<span class="s3">:100-----</span>继续区域<span class="s3">",</span>它接下来就不需要转寄<span class="s3">100</span>回答应答）<span class="s3">.</span></p>
<p class="p1">10<span class="s1">．</span>1<span class="s1">．</span>1   100 <span class="s1">继续</span></p>
<p class="p2"><span class="s3">  </span>客户应该和他自己的请求继续。中间的应答被用于告知客户请求的初始部分已经收到并且还没有被服务器所拒绝。客户应该继续发送剩下的请求，或者如果请求早已完成，那就忽略请求。服务器必须发送一个初始回答应答当请求完成时。如果想知道这部分状态代码用法及操作处理的详细讨论，那么请看<span class="s3">8.2.3</span>章节。</p>
<p class="p1">10<span class="s1">．</span>1<span class="s1">．</span>2 101<span class="s1">转换<a href="http://www.cnpaf.net/">协议</a></span></p>
<p class="p2"><span class="s3">    </span>服务器了解并且愿意顺从客户的请求，经过升级的报文报头区域，为的就是一个应用<a href="http://www.cnpaf.net/">协议</a>的变化使之能够在连接中使用。服务器会转换<a href="http://www.cnpaf.net/">协议</a>使之成为那些通过应答升级报头的区域定义的立即在决定<span class="s3">101</span>应答的空行之后的<a href="http://www.cnpaf.net/">协议</a>。</p>
<p class="p2"><span class="s3">    <a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>应该仅仅在这样做有利的时候实行转换。比如，转换成为一个新版本的<span class="s3">HTTP<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>与老版本相比更加有利，转换成为一个实时同步的<a href="http://www.cnpaf.net/">协议</a>也许会有利<span class="s3">,</span>当被传送的资源需要利用这样的特征</p>
<p class="p1">10<span class="s1">．</span>2 <span class="s1">成功</span> 2xx</p>
<p class="p2">这种状态代码类简要的说明了客户的请求被成功的接收，理解，和接受</p>
<p class="p1">10.2.1 200 OK</p>
<p class="p2"><span class="s3">     </span>请求已经成功。连同应答一起返回的信息是依赖于在请求中使用方法的。例如：</p>
<p class="p2"><span class="s3">GET                    </span>与被请求的资源相应的实体在应答中一起发送。<span class="s2"><br>
</span><span class="s3">HEAD          </span>与被请求资源相对应的没有报文正文的报头区域在应答中发送。<span class="s2"><br>
</span><span class="s3">POST           </span>描述或者包含行动结果的实体。<span class="s2"><br>
</span><span class="s3">TRACE          </span>底端服务器已经接收的包含请求报文的实体</p>
<p class="p1">10.2.2  201 <span class="s1">创建</span></p>
<p class="p2">请求已经完成同时导致新的资源被创造<span class="s3">.</span>新创造的资源和地址报头区域给出资源的最专业的<span class="s3">URI</span>可以被随应答实体返回的<span class="s3">URI</span>参考<span class="s3">.</span>应答应该包含用户或者用户代理可以从中选择出的一系列最最合适资源的特征和地址<span class="s3">.</span>实体的格式通过在内容形式报头区域给出的媒体形式来详细说明<span class="s3">.</span>最初的服务器必须在返回<span class="s3">201</span>状态代码以前创造资源<span class="s3">.</span>如果行动不能马上执行<span class="s3">,</span>服务器应该以<span class="s3">202</span>接受应答来应答它<span class="s3">.</span></p>
<p class="p2">一个<span class="s3">201</span>应答可以由一个为了刚刚创造出的请求变量而显示出来的当前实体标记符的值的<span class="s3">Etag</span>应答报头区域<span class="s3">,</span>参见<span class="s3">14.19</span>节。<span class="s3">.</span></p>
<p class="p1">10.2.3 202 <span class="s1">接受</span>.</p>
<p class="p2">为了处理<span class="s3">,</span>请求被接受<span class="s3">,</span>但是处理并没有完成<span class="s3">.</span>请求最终有可能或者不可能遵照行事<span class="s3">,</span>因为在处理过程实际发生时<span class="s3">,</span>它有可能被不允许<span class="s3">.</span>没有什么设备可以从如此的异步操作中重新发送状态代码</p>
<p class="p2"><span class="s3">202</span>应答是故意无委托的<span class="s3">.</span>它的目的就在于为了其他一些过程<span class="s3">,</span>在没有要求用户代理直到过程执行结束还坚持连接到服务器的情况下<span class="s3">,</span>允许服务器接受请求<span class="s3">(</span>也许是一批有所指向的一天只处理一次<span class="s3">).</span>实体和应答返回应该包括当前的请求状态<span class="s3">,</span>和或者一个指向状态监听器的指针或者关于什么时间用户期待请求完成的估计<span class="s3">.</span></p>
<p class="p2"><span class="s3">.</span><span class="s2"><br>
</span><span class="s3">10.2.4 203  </span>非权威信息<span class="s2"><br>
</span>在实体报头中返回的维护信息并不是原服务器可用的最终的设置<span class="s3">,</span>但是他们是从一个本地的或是第三方的拷贝<span class="s3">.</span>提出的设置也许是原始版本的子集或是父集<span class="s3">.</span>举例来说<span class="s3">,</span>包括有关于也许导致被原服务器识别的维护信息的父集的本地注解信息<span class="s3">.</span>这种应答代码的用法并不必需<span class="s3">,</span>而且只有当应答为<span class="s3">200</span>时才适用<span class="s3">.</span></p>
<p class="p1"><span class="s2"><br>
</span>10.2.5 204 <span class="s1">没有内容</span></p>
<p class="p2">服务器完成请求并不需要返回实体的正文<span class="s3">,</span>并且也许想返回升级过的维护信息<span class="s3">.</span>应答也许包含新的或者是升级过的的实体报头形式的维护信息<span class="s3">,</span>如果这些当前的可以与请求的变量相关联<span class="s3">.</span></p>
<p class="p2">如果客户是个用户代理<span class="s3">,</span>她就不应该改变它的文件观点以区别于那个导致请求被发送的文件观点<span class="s3">.</span>这样的应答主要是故意允许为了行动的输入发生在没有导致对用户代理主动的文件观点改变的情况下<span class="s3">,</span>尽管任何新的或者是升了级的维护信息应该是适应于用户代理现在的主动观点的<span class="s3">.</span></p>
<p class="p2"><span class="s3">204</span>应答严禁包含报文正文<span class="s3">,</span>并且这样总是由在报头区域之后的第一个空行决定的<span class="s3">.</span></p>
<p class="p2"><span class="s3">10.2.6 205 </span>重置内容<span class="s2"><br>
</span><span class="s3">  </span><span class="s2"><br>
</span>服务器已经完成了请求<span class="s3">,</span>用户代理应该重新设置导致请求被发送的文件观点<span class="s3">.</span>这种应答主要是故意允许输入行动通过用户输入发生<span class="s3">,</span>伴随而来的是对给出形式的清理为了让用户可以轻松开始另一个输入行动<span class="s3">.</span>应答严禁包含任何实体<span class="s3">.</span></p>
<p class="p1">10.2.7 206  <span class="s1">局部内容</span></p>
<p class="p2"><span class="s3">   </span>服务器对于资源已经完成了部分<span class="s3">GET</span>请求<span class="s3">.</span>请求必须包含一个范围报头区域<span class="s3">(14.35</span>节<span class="s3">),</span><span class="s2"><br>
</span><span class="s3">   </span>指出了想要的范围<span class="s3">,</span>而且也有可能包含一个使请求条件化如果<span class="s3">-</span>范围报头区域</p>
<p class="p2"><span class="s3">   </span>应答必须包含以下的报头区域<span class="s3">:</span></p>
<p class="p2">或者是一个内容范围报头区域指出包含此现应答的范围<span class="s3">,</span>或者是对每个部分来说一个多部分的<span class="s3">/</span>字节范围的内容形式都包含内容范围报头<span class="s3">.</span>如果内容长度报头区域在当前应答中<span class="s3">,</span>那么它的值必须和实际在报文正文重传送的<span class="s3">OCTET</span>相匹配<span class="s3">.</span></p>
<p class="p2"><span class="s3">     -</span>日期<span class="s2"><br>
</span><span class="s3">     -Etag</span>或者内容位置<span class="s3">,</span>如果能够在一个<span class="s3">200</span>应答中对于同一个请求发送报头<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">     -</span>终止<span class="s3">,</span>缓存控制<span class="s3">,</span>和<span class="s3">/</span>或者变化<span class="s3">,</span>如果区域值与对于同一个变量以前发送的应答中的区域值不一样<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">   </span><span class="s2"><br>
</span>如果<span class="s3">206</span>应答是一个使用强缓存确认的的如果范围请求的结果<span class="s3">,</span>那么应答不应该包含其他实体报头<span class="s3">. </span>如果应答是一个使用弱缓存确认的的如果范围请求的结果<span class="s3">,</span>那么应答严禁包含其他实体报头<span class="s3">,</span>这么做是为了防止缓存实体正文和升级报头之间的矛盾性<span class="s3">.</span>否则<span class="s3">,</span>应答必须包含所有对同一个请求返回的<span class="s3">200</span>应答中的实体报头<span class="s3">.</span></p>
<p class="p2">如果<span class="s3">Etag</span>或者上次更改的报头不严格匹配<span class="s3">,</span>缓存严禁将一个<span class="s3">206</span>请求与其他以前缓存的内容连接起来</p>
<p class="p2">一个并不支持范围和内容范围的缓存严禁缓存<span class="s3">206(</span>部分<span class="s3">)</span>应答<span class="s3">.</span></p>
<p class="p1">10.3 <span class="s1">重新定向</span> 3xx.</p>
<p class="p2">这种状态代码类指出了为了完成请求用户代理而所需要做的更进一步的行动<span class="s3">.</span>必需的行动<span class="s3">          </span>可以被没有与用户发生交互作用的用户代理执行并且在当且仅当在第二个请求中所需的方法是<span class="s3">GET </span>或者是<span class="s3">HEAD.</span>客户应该侦察最终的重新定向环路<span class="s3">,</span>因为对于每一个重新定向来说这样的环路产生网络交通<span class="s3">.</span></p>
<p class="p2">注解<span class="s3">:</span>老版本的规范推荐最大数量为<span class="s3">5</span>的重新定向<span class="s3">.</span>内容开发者应该知道也许有贯彻这样复杂限制的客户<span class="s3">.</span></p>
<p class="p2"><span class="s3">10.3.1 300 </span>多样选择<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">    </span><span class="s2"><br>
</span>被请求的资源符合任何一套表示法之一<span class="s3">,</span>每种资源和她自己的特定地址<span class="s3">,</span>并且为了使用户可以选择一个首选的表示法和依照那个地址重新定向<span class="s3">, </span>代理驱动的协商信息可以被提供出来<span class="s3">.</span><span class="s2"><br>
</span>除非它是一个<span class="s3">HEAD</span>请求<span class="s3">,</span>应答都应该有包含一系列用户或者用户代理可以从中选择的最最合适的资源特性和地址<span class="s3">.</span>实体格式被在内容形式报头区域给出的煤体形式详细说明<span class="s3">.</span>依靠用户代理的格式和容量<span class="s3">,</span>最最合适的那个选择有可能自动完成<span class="s3">.</span>不管怎样<span class="s3">,</span>这种规范并没有定义自动选择的标准<span class="s3">.</span>如果服务器有了一个陈述的首选<span class="s3">,</span>那么它应该包含为了关于那个陈述的特定的<span class="s3">URI;</span>用户代理为了自动重新定向可以使用地址区域值<span class="s3">.</span>除非指出另外的那么应答就可以缓存<span class="s3">.</span></p>
<p class="p1">10.3.2 301 <span class="s1">永久移动</span></p>
<p class="p2">被请求的资源已经分配了一个新的永久的<span class="s3">URI,</span>任何对资源的未来参考应该使用返回的<span class="s3">URI</span>中的一个<span class="s3">.</span>有编辑连接能力的客户应该对于被请求的<span class="s3">URI</span>从可能的服务器中返回的一个或者多个参考中实现自动连接参考<span class="s3">.</span>这种应答是可以缓存的除非它指出其他的<span class="s3">.</span></p>
<p class="p2">新的永久的<span class="s3">URI</span>应该在应答中的地址区域给出<span class="s3">.</span>除非请求方法是<span class="s3">HEAD,</span>应答的实体应该包括一个段指向新的<span class="s3">URI</span>的超文本文本注解</p>
<p class="p2">如果<span class="s3">301</span>状态编码在对应于<span class="s3">HEAD</span>或者<span class="s3">GEI</span>方法中收到<span class="s3">,</span>用户代理严禁自动的重新定向请求除非它可以被用户确认<span class="s3">,</span>因为这样可能会改变请求发生的条件<span class="s3">.</span></p>
<p class="p2">注解<span class="s3">:</span>当在接受到一个<span class="s3">301</span>状态编码后自动重新定向某一邮政请求<span class="s3">,</span>一些现存的<span class="s3">HTTP/1.0</span>用户代理将错误的将它改成<span class="s3">GET</span>方法<span class="s3">.</span></p>
<p class="p1">10.3.3 302 <span class="s1">创立</span></p>
<p class="p2">被请求的资源已经分配了一个新的永久的<span class="s3">URI,</span>任何对资源的未来参考应该使用返回的<span class="s3">URI</span>中的一个<span class="s3">.</span>有编辑连接能力的客户应该对于被请求的<span class="s3">URI</span>从可能的服务器中返回的一个或者多个参考中实现自动连接参考<span class="s3">.</span>这种应答是可以缓存的除非它指出其他的<span class="s3">.</span></p>
<p class="p2">对临时的<span class="s3">URI</span>应该给予地址区域<span class="s3">.</span>除非请求的方法是<span class="s3">HEAD,</span>相应的实体应该包含一个短的指向一个新的<span class="s3">URI</span>的超级连接的超文本提示</p>
<p class="p2">如果<span class="s3">302</span>状态代码在一个应答非<span class="s3">GEI</span>或者<span class="s3">HEAD</span>请求中的过程中被接收到<span class="s3">,</span>那么用户代理严禁自动重新定位除非它可以被用户证实<span class="s3">,</span>因为它可能变化它的请求实现的条件<span class="s3">.</span></p>
<p class="p2">注解<span class="s3">: <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 1945 </span>和<span class="s3"> <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 2068 </span>详细说明了客户不被允许改变在重新定位请求使用的方法<span class="s3">.</span>但是大多数存在的用户代理将<span class="s3">302</span>视为一个<span class="s3">303</span>应答<span class="s3">, </span>不管最初的请求方法而在位置区域值实现一个<span class="s3">GET</span>方法<span class="s3">.</span>状态代码<span class="s3">303</span>和<span class="s3">307</span>被加在服务器上以希望它能够清楚客户所期待的那种反作用<span class="s3">.</span></p>
<p class="p1">10.3.4 303 <span class="s1">观察别的部分</span></p>
<p class="p2">对请求的应答可以在不同的<span class="s3">URI</span>中找到<span class="s3">,</span>并且应答应该在对资源的<span class="s3">GET</span>方法中重新得到<span class="s3">.</span>这种方法存在主要是为了允许邮政活性的输出脚本重新定向用户代理于一个选择的资源<span class="s3">.</span>新的<span class="s3">URI</span>不是一个最初请求资源的替代参考<span class="s3">.303</span>应答严禁缓存<span class="s3">,</span>但是对于第二个请求<span class="s3">(</span>重新定向<span class="s3">)</span>可以缓存<span class="s3">.</span></p>
<p class="p2">不同的<span class="s3">URI</span>应该在相应的位置区域给出除非请求的方法是<span class="s3">HEAD,</span>相应的实体应该包含一个短的指向一个新的<span class="s3">URI</span>的超级连接的超文本提示<span class="s3">.</span></p>
<p class="p2">注解<span class="s3">: </span>许多<span class="s3">HTTP/1.1</span>以前的用户不理解<span class="s3">303</span>状态<span class="s3">.</span>当客户之间的协同工作能力被关注时<span class="s3">,302</span>状态代码也许会作为替代而使用<span class="s3">,</span>因为大多数用户代理就向这里描述的<span class="s3">303</span>那样反作用于<span class="s3">302</span>应答<span class="s3">.</span></p>
<p class="p1">10.3.5 304 <span class="s1">只读</span></p>
<p class="p2">如果客户提出一个条件的<span class="s3">GET</span>请求并且访问也已经允许<span class="s3">,</span>但是文档并没有修改<span class="s3">,</span>服务器应该应答这些状态编码<span class="s3">.304</span>应答严禁包含报文正文<span class="s3">,</span>并且总是由报头区域之后的第一个空行决定的<span class="s3">.</span></p>
<p class="p2">应答必须包括以下报头区域<span class="s3">:</span><span class="s2"><br>
</span><span class="s3">-</span>日期<span class="s3">,</span>除非数据亢长是<span class="s3">14.18.1</span>部分必须的<span class="s3">.</span></p>
<p class="p2">如果一个无时钟原服务器遵守这些规则<span class="s3">,</span>并且代理服务器和客户将自己的日期加入任何成标准的应答中去<span class="s3">,</span>缓存会工作正常<span class="s3">.</span></p>
<p class="p2"><span class="s3">-Etag</span>或者内容位置<span class="s3">,</span>如果能够在一个<span class="s3">200</span>应答中对于同一个请求发送报头<span class="s3">.</span></p>
<p class="p2"><span class="s3">-</span>终止<span class="s3">,</span>缓存控制<span class="s3">,</span>和<span class="s3">/</span>或者变化<span class="s3">,</span>如果区域值与对于同一个变量以前发送的应答中的区域<span class="s3">       </span><span class="s2"><br>
</span><span class="s3">   </span>值不一样<span class="s3">.</span></p>
<p class="p2">如果条件化的<span class="s3">GET</span>使用了强的缓存<span class="s3">??(</span>请参阅<span class="s3">13.3.3</span>部分内容<span class="s3">),</span>那么应答中就不应该有其他实体报头<span class="s3">.</span>否则<span class="s3">,</span>应答中严禁包含其他实体报头<span class="s3">,</span>这样子保护了缓存实体正文和升级报头之间的矛盾性</p>
<p class="p2">如果<span class="s3">304</span>应答指出了当前尚未缓存的实体<span class="s3">,</span>那么缓存就必须忽视应答并且无条件的重复请求</p>
<p class="p2">如果缓存使用成为标准的<span class="s3">204</span>应答取胜疾缓存的入口<span class="s3">,</span>缓存就必须升级自己的入口以反映在应答中给出的任何新的区域值<span class="s3">.</span></p>
<p class="p1">10.3.6 305 <span class="s1">使用代理服务器</span></p>
<p class="p2">地址区域的被请求的资源必须通过代理服务器<span class="s3">.</span>地址区域给除了代理服务器的<span class="s3">URI. </span>期望容纳者通过代理服务器重复这一单一请求<span class="s3">.305</span>应答必须由原服务器产生<span class="s3">.</span></p>
<p class="p2">注解<span class="s3">: <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a>2068</span>并不清晰于<span class="s3">305</span>有意于重新定向一个单一请求<span class="s3">,</span>并且此请求还只能由原服务器产生<span class="s3">.</span>不留心这些限制会产生相当严重的<a href="http://www.cnpaf.net/class/security/">安全</a>后果<span class="s3">.</span></p>
<p class="p1">10.3.7 306(<span class="s1">没有用的</span>)</p>
<p class="p2"><span class="s3">306</span>状态编码在以前的规范中使用<span class="s3">,</span>现在已经不再用了<span class="s3">,</span>代码也保留了下来<span class="s3">.</span></p>
<p class="p1">10.3.8 307<span class="s1">临时重发</span>.</p>
<p class="p2"><span class="s3">  </span>请求的资源临时存在在另一个不同的<span class="s3">URI</span>下<span class="s3">.</span>由于重新定位有时可能变化<span class="s3">,</span>客户应该继续使用请求<span class="s3">URI</span>以备将来用途<span class="s3">.</span>这个应答只有当被缓存控制或是终止报头区域指出时才是可以存储的<span class="s3">.</span></p>
<p class="p2">临时的<span class="s3">URI</span>应该在应答中的地址区域给出<span class="s3">.</span>除非请求的方法是<span class="s3">HEAD,</span>应答的实体应该包括一个短的指向一个新的<span class="s3">URI</span>的超文本提示<span class="s3">, </span>许多<span class="s3">HTTP/1.1</span>以前的用户不理解<span class="s3">307</span>状态<span class="s3">.</span>因此<span class="s3">,</span>提示应该包括用户在新的<span class="s3">URI</span>中为了重复原始请求所必需的信息<span class="s3">.</span></p>
<p class="p2">如果<span class="s3">307</span>状态代码作为应答不仅仅是<span class="s3">GET</span>或者<span class="s3">HEAD</span>等方法而接收<span class="s3">,</span>那么用户严禁重新定向请求除非它可以被用户确认<span class="s3">,</span>这也是可能的<span class="s3">.</span></p>
<p class="p1"><span class="s2"><br>
</span>10.4 <span class="s1">客户错误</span> 4xx</p>
<p class="p2">状态代码<span class="s3">4xx</span>类是专门使用在客户看上去错误的情形下的<span class="s3">.</span>除非当应答一个<span class="s3">HEAD</span>请求时<span class="s3">,</span>服务器因该有一个包括错误情形的解释的实体<span class="s3">,</span>以及它是否一个临时或者终了的条件<span class="s3">.</span>这些状态编码可以应用于任何请求方法<span class="s3">.</span>用户代理应该向用户显示任何包括的实体<span class="s3">.</span></p>
<p class="p2">如果客户在发送数据<span class="s3">,</span>使用<a href="http://www.cnpaf.net/class/tcpandip/"><span class="s3">TCP</span></a>的服务器的实现应该小心以保证在服务器关掉了所有的输入连接时客户承认收到包含应答的包<span class="s3">.</span>在关掉之后如果客户继续发送数据给服务器<span class="s3">,</span>服务器<a href="http://www.cnpaf.net/class/tcpandip/"><span class="s3">TCP</span></a>堆会发送一个重制包<span class="s3">,</span>也许这样子会在服务器开始被访问以及<span class="s3">HTTP</span>应用程序被解释的情况下<span class="s3">,</span>会擦掉客户不知道的输入缓冲<span class="s3">.</span></p>
<p class="p1">10.4.1 400 <span class="s1">坏请求</span></p>
<p class="p2">请求由于畸形的语法而不被服务器所理解<span class="s3">.</span>客户不应该重复自己的请求在没有改变的情况下<span class="s3">.</span></p>
<p class="p1">10.4.2 401 <span class="s1">未授权的</span></p>
<p class="p2">请求需要用户的鉴定<span class="s3">.</span>应答必需有用于对被请求资源的挑战的包含<span class="s3">WWW</span>鉴定报头区域<span class="s3">.</span>如有合适的认证报头区域<span class="s3">,</span>客户可以重复请求<span class="s3">.</span>如果请求已经包含了认证的信任书<span class="s3">,</span>那么<span class="s3">401</span>应答就指出了认证由于这些信任书而被拒绝<span class="s3">.</span>如果<span class="s3">401</span>应答包括和上一个应答同样的挑战并且用户代理已经尝试认证了至少一次<span class="s3">,</span>那么应该给用户在应答中给出的实体<span class="s3">,</span>因为实体中可能包含相应的诊断信息<span class="s3">.HTTP</span>访问认证在<span class="s3">"HTTP Authentication: Basic and Digest Access Authentication" </span>中有所解释<span class="s3">.</span></p>
<p class="p2"><span class="s3">10.4.3 402 </span>必需的支付<span class="s2"><br>
</span><span class="s3">   </span><span class="s2"><br>
</span>这种代码被保存下来以便将来使用<span class="s3">.</span></p>
<p class="p1"><span class="s2"><br>
</span>10.4.4 403 <span class="s1">禁用</span></p>
<p class="p2">服务器理解了请求<span class="s3">,</span>但是拒绝实现它<span class="s3">.</span>认证不会帮助<span class="s3">,</span>请求也不应该重复<span class="s3">.</span>如果请求的方法不是<span class="s3">HEAD</span>并且服务器愿意将请求为什么没有实现告诉大家<span class="s3">,</span>它应该在实体中描述拒绝的理由<span class="s3">.</span>如果服务器并不想将这条信息告诉客户<span class="s3">,</span>状态代码<span class="s3">404(</span>没找到<span class="s3">)</span>可以替代使用之<span class="s3">.</span></p>
<p class="p1"><span class="s2"><br>
</span>10.4.5 404 <span class="s1">没有找到</span></p>
<p class="p2">服务器并没有找到任何可以匹配请求<span class="s3">URI.</span>条件是永久的还是暂时的也没有任何的迹象<span class="s3">.410</span>状态编码应该在服务器知道老的资源是永远不可以得到的并且没有以前的地址的情况下<span class="s3">,</span>通过一些内在的可配置的机构<span class="s3">,</span>才应该使用<span class="s3">.</span>这种状态编码当服务器不想精确展示为什么请求被拒绝或者何时没有其他的应答可以利用的时候被广泛的应用<span class="s3">.</span></p>
<p class="p1"> </p>
<p class="p1">10.4.6 405 <span class="s1">不被允许的方法</span></p>
<p class="p2">在请求行中特殊指定的方法不允许访问由请求<span class="s3">URI</span>指定的资源<span class="s3">.</span>应答必需有一个包括一些对于被请求的资源有效的方法的允许报头<span class="s3">.</span></p>
<p class="p1"><span class="s2"><br>
</span>10.4.7 406 <span class="s1">不接受</span></p>
<p class="p2">请求指定的资源只可能产生依照在发送请求中的接受报头有不接受的内容特性的应答实体<span class="s3">.</span></p>
<p class="p2">除非它是一个<span class="s3">HEAD</span>请求<span class="s3">,</span>应答应该有包括一系列可兹利用的实体特性和位置<span class="s3">,</span>从中用户和用户代理可以找出最最适合的<span class="s3">.</span>实体的格式由在内同形式报头区域给出的媒体形式所指定<span class="s3">.</span>依靠此格式和用户代理的性能<span class="s3">,</span>最佳的选择可能自动的完成<span class="s3">.</span>然而<span class="s3">,</span>这中规范并没有定义任何针对此自动选择的标准</p>
<p class="p2">注解<span class="s3">: HTTP/1.1</span>服务器允许返回依照在请求中发送的接受报头不被接受的应答<span class="s3">.</span>在某些情况下<span class="s3">,</span>发送一个<span class="s3">406</span>应答甚至更加有利<span class="s3">.</span>用户代理被鼓励去检查输入应答的报头以判断是否可以接受<span class="s3">.</span></p>
<p class="p2">如果应答不被接受<span class="s3">,</span>那么用户代理应该暂时停止接收更多数据并且向用户查询是否需要更进一步的行动决定<span class="s3">.</span></p>
<p class="p1"><span class="s2"><br>
</span>10.4.8 407 <span class="s1">代理服务器认证所必需</span></p>
<p class="p2">这种代码很相近于<span class="s3">401,</span>但是它指出了客户必须和代理服务器之间认证自己<span class="s3">.</span>代理服务器必需返回一个代理服务器<span class="s3">----</span>认证报头区域<span class="s3">,</span>该区域包括是为了被请求的资源而用于代理服务器的挑战<span class="s3">.</span>客户可能随着一个合适的代理服务器认证报头区域一起重复它的请求<span class="s3">.  HTTP</span>访问认证在<span class="s3">" HTTP Authentication: Basic and Digest Access Authentication"</span>中有解释<span class="s3">.</span></p>
<p class="p1"><span class="s2"><br>
</span>10.4.9 408 <span class="s1">请求超时</span></p>
<p class="p2">在服务器准备等待的时间段内<span class="s3">,</span>客户并没有产生请求<span class="s3">.</span>客户也许会在以后的任意一时间内重复请求<span class="s3">.</span></p>
<p class="p1">10.4.10 409 <span class="s1">冲突</span></p>
<p class="p2">由于与资源的现在状态的冲突请求游客能不能完成<span class="s3">.</span>代码只有在用户被期待有可能解决冲突和提交请求的地方的情况下允许使用<span class="s3">.</span>应答体应该包括对于用户认识冲突来源的足够多的信息<span class="s3">.</span>理想的<span class="s3">,</span>应答体应该有对于用户和用户代理可以解决问题的足够多的信息量<span class="s3">.</span>然而<span class="s3">,</span>这也许是不可能的或者是不必需的<span class="s3">.</span></p>
<p class="p2">冲突通常会发生在应答<span class="s3">PUT</span>请求的时候<span class="s3">.</span>例如<span class="s3">,</span>版本正在被使用而且正在<span class="s3">PUT</span>的实体有和以前请求<span class="s3">(</span>第三方<span class="s3">)</span>冲突的资源的变更的话<span class="s3">,</span>服务器会使用<span class="s3">409</span>应答来指出它不能完成请求<span class="s3">.</span>在这种情形下<span class="s3">,</span>应答实体可能会包括一系列在内容形式应答中定义的两种版本的区别之处<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">10.4.11 410 </span>停止<span class="s2"><br>
</span>服务器上的被请求的资源不再可用<span class="s3">,</span>而且不知道以前的地址<span class="s3">.</span>我们期望此条件被认为是永远的<span class="s3">.</span>有连接编辑能力的客户在用户同意的情况下<span class="s3">,</span>应该删掉对请求<span class="s3">URI</span>的参考<span class="s3">.</span>如果服务器并不知道<span class="s3">,</span>或者没有设备去决定是否条件是永久的<span class="s3">,</span>状态代码<span class="s3">404(</span>未找到<span class="s3">)</span>此时应该使用<span class="s3">.</span>这种应答是不可被缓存的除非另外指出<span class="s3">.</span></p>
<p class="p2"><span class="s3">410</span>应答主要是通过通告请求者资源有意不可获得和服务器主人希望那些远方连接到资源的连接都被请除掉这两条信息用于援助<span class="s3">WEB</span>维护<span class="s3">.</span>这样的事情很普通发生在时间受限<span class="s3">,</span>增加的服务和不再服务器端工作的的属于私人性质的资源这些情况下<span class="s3">.</span>我们并不需要标注所有的永久不可用的资源<span class="s3">"</span>没了<span class="s3">"</span>或是标注上任意一段长度的时间<span class="s3">-----</span>这些交给那些服务器的主人自己去判断吧<span class="s3">.</span></p>
<p class="p1"><span class="s2"><br>
</span>10.4.12 411 <span class="s1">必需的长度</span></p>
<p class="p2">服务器拒绝接受没有定义的内容长度的请求<span class="s3">. </span>如果加上了一个有效的<span class="s3">"</span>包含有请求报文正文中的长度<span class="s3">"</span>的内容长度报头区域<span class="s3">,</span>那么客户可能重复请求<span class="s3">.</span></p>
<p class="p1"><span class="s2"><br>
</span>10.4.13 412 <span class="s1">预处理失败</span></p>
<p class="p2">在一个或者多个请求中给出的预处理在被服务器验证的时候会被评价为错误的<span class="s3">.</span>这种应答代码允许客户将预处理放在当前资源维护信息<span class="s3">(</span>报头区域数据<span class="s3">),</span>并且这样作以防止有其他的适应资源请求的法的而非所要的那一个<span class="s3">.</span></p>
<p class="p1"><span class="s2"><br>
</span>10.4.14 413 <span class="s1">请求实体太大</span></p>
<p class="p2">服务器拒绝处理一个请求因为请求比服务器所能和所愿处理的还要大<span class="s3">.</span>服务器可能关掉连接以防止客户继续请求<span class="s3">.</span></p>
<p class="p2">如果条件是暂时的<span class="s3">,</span>服务器应该有一个重新试<span class="s3">-</span>在之后报头区域以便于指出这是暂时的在什么时间以后客户可以再试一次<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">10.4.15 414 </span>请求的<span class="s3">URI</span>过长</p>
<p class="p2">服务器拒绝请求的服务因为请求的<span class="s3">URI</span>比服务器所愿意解释的要长<span class="s3">.</span>这种比较珍稀的条件之可能发生在党课互补恰当的将<span class="s3">POST</span>请求变为有长查询信息的<span class="s3">GET</span>请求的情况下<span class="s3">,</span>或是客户落到了一个重新定向的<span class="s3">URI</span>黑洞中时<span class="s3">,</span>再或者是在一些使用固定长度缓冲区用以读或者处理请求的<span class="s3">URI</span>的服务器遭到钻<a href="http://www.cnpaf.net/class/security/">安全</a>漏洞的黑客的攻击的时候<span class="s3">.</span></p>
<p class="p1"><span class="s2"><br>
</span>10.4.16 415 <span class="s1">不被支持的媒体类型</span></p>
<p class="p2">服务器拒绝提供服务给请求因为请求的实体所请求的方法是在一种不被请求资源支持的格式下<span class="s3">.</span></p>
<p class="p1">10.4.17 416 <span class="s1">请求范围不满足</span></p>
<p class="p2">如果请求包括范围请求报头区域<span class="s3">,</span>或者是在区域内没有范围说明符的值溢出当前选择资源的延伸<span class="s3">,</span>再或者是请求没有包含如果<span class="s3">--</span>范围请求<span class="s3">--</span>报头区域<span class="s3">,</span>服务器应该返回连同状态代码的一个应答<span class="s3">.(</span>对于字节<span class="s3">-</span>范围<span class="s3">,</span>它意味着所有的字节范围说明中的第一字节<span class="s3">???</span>的值比当前选择资源的长度要大<span class="s3">)</span></p>
<p class="p2">当状态代码返回一个字节范围请求时<span class="s3">,</span>应答应该包含一个详细说明选择资源的长度的内容范围区域<span class="s3">.(</span>请参阅<span class="s3">14.16).</span>应答严禁使用多部分<span class="s3">/</span>字节范围的内容形式<span class="s3">.</span></p>
<p class="p1">10.4.18 417 <span class="s1">期望失败</span></p>
<p class="p2">在请求报头区域给出的预料不可能被服务器实现<span class="s3">,</span>或者<span class="s3">,</span>如果服务器是代理服务器<span class="s3">,</span>服务器有请求不可能被下一个<span class="s3">??</span>服务器实现的模糊的证据</p>
<p class="p1"><span class="s2"><br>
</span>10.5 <span class="s1">服务器错误</span> 5xx</p>
<p class="p2">应答状态代码用阿拉伯数字<span class="s3">"5"</span>表示服务器知道它自己有错误或者自己不能实现请求等这些情况<span class="s3">.</span>除了当应答一个<span class="s3">HEAD</span>请求<span class="s3">,</span>服务器应该有一个包括错误形式的解释的实体和它是否暂时或者永久的条件的解释的实体<span class="s3">.</span>用户代理应该显示任何包括的实体给用户<span class="s3">.</span>这些应答代码对于任何请求的方法都是适用的<span class="s3">.</span></p>
<p class="p1"><span class="s2"><br>
</span>10.5.1 500 <span class="s1">服务器内部错误</span></p>
<p class="p2">服务器遇到预料到的防止它完成请求的情况<span class="s3">.</span></p>
<p class="p1"><span class="s2"><br>
</span>10.5.2 501 <span class="s1">不能实现</span></p>
<p class="p2">服务器不支持完成请求所必需的功能性<span class="s3">. </span>当服务器并不认识请求的方法并且没有能力对于任何资源支持时<span class="s3">,</span>这是合适的应答</p>
<p class="p1"><span class="s2"><br>
</span>10.5.3 502 <span class="s1">坏网关</span></p>
<p class="p2">服务器<span class="s3">,</span>当被用作一个网关或者是代理服务器时<span class="s3">,</span>就会从上流的服务器收到无效的应答以试图完成请求的访问<span class="s3">.</span></p>
<p class="p1"><span class="s2"><br>
</span>10.5.4 503 <span class="s1">难以获得的服务</span>.</p>
<p class="p2">由于暂时的过载或者服务器维护<span class="s3">,</span>服务器此时不能处置请求<span class="s3">.</span>这说明了这是一个暂时的条件过一些耽搁会减轻<span class="s3">.</span>如果知道<span class="s3">,</span>耽搁的长度应会在重新试<span class="s3">-</span>在之后报头中指出<span class="s3">.</span>如果没有重新试<span class="s3">-</span>在之后给出<span class="s3">,</span>客户应该处理处置应答就像处理一个<span class="s3">500</span>应答一样。</p>
<p class="p2">注解：<span class="s3">503</span>状态代码的存在并不暗示着服务器必需使用它当它变得过载时。有些服务器只想简单的拒绝连接。</p>
<p class="p1">10.5.5 504 <span class="s1">网关超时</span></p>
<p class="p2">服务器<span class="s3">,</span>当被用作是网关或者是代理服务器时<span class="s3">, </span>由于<span class="s3">URI</span>指定的上游服务器或者其他一些辅助服务器以有资格尝试完成请求<span class="s3">,</span>并没有收到及时的应答<span class="s3">.</span></p>
<p class="p2">注解<span class="s3">:</span>设备注解<span class="s3">:</span>一些展开的代理服务器都知道返回<span class="s3">400</span>或者<span class="s3">500</span>当<a href="http://www.cnpaf.net/class/dns/"><span class="s3">DNS</span></a>查找时间过长时<span class="s3">.</span></p>
<p class="p1">10.5.6 505 HTTP<span class="s1">版本不支持</span></p>
<p class="p2">服务器并不支持<span class="s3">,</span>或者拒绝支持<span class="s3">,</span>在请求信息中用到了<span class="s3">HTTP<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>版本<span class="s3">.</span>服务器指出它不能或是不愿完成使用与客户端一样的版本的请求<span class="s3">,</span>就像在章节<span class="s3">3.1</span>中描述的那样<span class="s3">,???????.</span>应答应该包含描述为什么那个版本不为支持而为什么其他<a href="http://www.cnpaf.net/">协议</a>被服务器支持的实体<span class="s3">..</span></p>
<p class="p2"><span class="s2"><br>
</span><span class="s3">11.</span>入口验证</p>
<p class="p2"><span class="s3">HTTP</span>提供了一些可以选择的用于服务器挑战用户请求和用户提供验证信息的的挑战<span class="s3">-</span>应答验证机制<span class="s3">.</span>入口验证的大体框架<span class="s3">,</span>和基础及分类验证的规范在<span class="s3">" HTTP </span>规范<span class="s3">:"</span>基础及分类入口验证<span class="s3">"</span>中详细说明<span class="s3">.</span>这份说明从规范中采用了<span class="s3">"</span>挑战<span class="s3">"</span>和<span class="s3">"</span>外交国书<span class="s3">"</span>的定义</p>
<p class="p2"><span class="s2"><br>
</span><span class="s3">12.</span>内容谈判</p>
<p class="p2">大多数<span class="s3">HTTP</span>应答都有一个包括人类用户解释信息的实体<span class="s3">.</span>自然地<span class="s3">,</span>相对于请求它需要提供给用户<span class="s3">"</span>最佳利用<span class="s3">"</span>的实体<span class="s3">.</span>很不幸的是<span class="s3">,</span>对于服务器和存储器来说<span class="s3">,</span>不是所有的用户都有同样的关于<span class="s3">"</span>什么是最好的<span class="s3">"</span>的判断准则<span class="s3">,</span>并且并不是所有的用户代理有相同的解释实体形式的能力<span class="s3">.</span>为此<span class="s3">,HTTP</span>为了<span class="s3">"</span>内容谈判<span class="s3">"</span>提供了一些机制<span class="s3">-----</span>当有很多种可能的表示时如何选择对于一个请求的最佳的表示<span class="s3">.</span></p>
<p class="p2">注解<span class="s3">: </span>这不是所谓的<span class="s3">"</span>格式谈判<span class="s3">,</span>因为变化的表现也许是相同的媒体形式<span class="s3">,</span>但是使用那种型号的不同性能的<span class="s3">,</span>还也许是使用了不同的语言<span class="s3">.</span><span class="s2"><br>
</span>任何包含一个实体正文的的应答都有可能受配于谈判<span class="s3">,</span>甚至包括那些错误的应答<span class="s3">.</span></p>
<p class="p2">在<span class="s3">HTTP</span>中有两种可能的内容谈判<span class="s3">:</span>服务器驱动的和代理驱动的谈判<span class="s3">.</span>这两种谈判是相互正交的<span class="s3">,</span>这样他们可以单独或者混合使用<span class="s3">.</span>混合使用的一种被称为透明的谈判的方法<span class="s3">,</span>发生在当缓存使用由最初的为了后来的请求而提供服务器驱动谈判的服务器提供的代理驱动谈判信息时<span class="s3">.</span></p>
<p class="p2"><span class="s3">12.1 </span>服务器驱动谈判</p>
<p class="p2">如果对于一个请求的最佳表示的选择由服务器提供的运算法则来完成<span class="s3">,</span>我们就叫它是服务器驱动谈判<span class="s3">.</span>选择是基于应答中可行的解释和在请求报文的特定报头区域的内容或是其他一些适合请求的信息<span class="s3">(</span>如客户的网络地址<span class="s3">).</span></p>
<p class="p2">服务器驱动在从所有可行的表示法中挑选最佳的运算法则对于客户很难描述时是有利的<span class="s3">,</span>或者是当服务器要求将它的<span class="s3">"</span>最佳估计<span class="s3">"</span>和第一应答一起送给客户端时有利<span class="s3">.</span>为了提高服务器的估计能力<span class="s3">,</span>用户代理可以包含为了这样一个应答描述自己参数选择的请求报头区域<span class="s3">.</span></p>
<p class="p2"><span class="s2"><br>
</span>服务器驱动谈判有这些缺点<span class="s3">:</span></p>
<p class="p2"><span class="s3">1. </span>对于任何用户来说决定什么是最佳的实际上是不可能的<span class="s3">,</span>因为那样需要有关于用户代理能力和应答所想要发挥的用途的所有完整的信息<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">2. </span>让用户代理在每一个请求中描述自己的能力也是很低效的并且对于用户的隐私也是潜在的威胁<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">3. </span>它复杂了原服务器的实现和相对于请求的运算法则<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">4.</span>它可能会限制一个公共缓存的能力<span class="s3">,</span>因为缓存对于不同的请求将使用同样的应答<span class="s3">.</span></p>
<p class="p2"><span class="s3">HTTP/1.1 </span>包含以下通过描述用户代理的性能和用户的参数选择使服务器驱动谈判成为可能的请求报头区域<span class="s3">: </span>接受<span class="s3">(</span>章节<span class="s3">14.1),???(</span>章节<span class="s3">14.2),</span>接受编码<span class="s3">(14.3),</span>接受语言<span class="s3">(14.4),</span>以及用户代理<span class="s3">(14.43).</span>然而<span class="s3">,</span>原服务器并不受限于这些尺寸<span class="s3">,</span>并且可能会基于请求的各各方面而变化不同的应答<span class="s3">,</span>包括在请求报头区域之外的信息或者在此规范中没有定义的扩展报头区域<span class="s3">.</span></p>
<p class="p2">不同的报头区域可以用作表达<span class="s2"><br>
</span>服务器用作选择服从服务器驱动谈判的表示法的变量<span class="s3">.</span>请查阅章节<span class="s3">13.6</span>关于缓存中不同报头区域的用法和章节<span class="s3">14.44</span>关于服务器不同报头区域的用法<span class="s3">.</span></p>
<p class="p2"><span class="s3">12.2 </span>代理驱动谈判<span class="s2"><br>
</span>在代理驱动谈判中<span class="s3">,</span>对于一个应答的最佳表示法的选择是在代理从原服务器端收到最初的应答后实现的<span class="s3">.</span>选择是基于一系列可用的应答的通过自己<span class="s3">URI</span>鉴定的表示法<span class="s3">,</span>其中包括初应答的报头区域和实体正文<span class="s3">.</span>从表示法中的选择可以自动实现<span class="s3">(</span>如果用户有能力这么做<span class="s3">)</span>或者人工的用户从产生的菜单<span class="s3">(</span>可能是超文本<span class="s3">)</span>中选择<span class="s3">.</span></p>
<p class="p2">代理驱动的谈判<span class="s3">,</span>当应答有可能不同于普通使用的尺寸时或者是原服务器不能够从检查请求中决定用户代理的性能时<span class="s3">,</span>并且一般说来当公共的缓存被用作分散服务器负载和减少网络用法<span class="s3">.</span></p>
<p class="p2">代理驱动的谈判也有需要二次请求以获得最佳替换表示法这样一个缺点<span class="s3">.</span>只有当缓存在使用时二次应答才有效<span class="s3">.</span>作为补充<span class="s3">,</span>规范中并没有定义支持自动选择的任何机制<span class="s3">,</span>虽然它也没有阻止任何机制被发展如像在<span class="s3">HTTP/1.1</span>中的扩展那样<span class="s3">.</span></p>
<p class="p2">在当服务器不愿或是不能提供不同的使用服务器驱动谈判的应答时<span class="s3">,HTTP/1.1</span>定义了<span class="s3">300(</span>多种选择<span class="s3">)</span>和<span class="s3">406(</span>不接受<span class="s3">)</span>这两种状态编码以使代理驱动谈判成为可能<span class="s3">.</span></p>
<p class="p1">12.3 <span class="s1">透明的判断</span></p>
<p class="p2">透明的判断是服务器驱动和代理驱动谈判的结合体<span class="s3">.</span>当缓存被供给了一系列可兹利用的应答的表示法并且变量的尺寸被缓存充分理解时<span class="s3">,</span>缓存可以执行代表为了资源的后来请求的原服务器服务器驱动的判断<span class="s3">.</span></p>
<p class="p2">透明的谈判有分散这样的优点<span class="s3">, </span>否则是原服务器必需的谈判工作<span class="s3">,</span>以及当缓存可以正确估计应答时可去除用户代理二次请求的沿时<span class="s3">.</span></p>
<p class="p2">此规范没有定义任何关于透明判断的机制<span class="s3">,</span>虽然它也没有像在<span class="s3">HTTP/1.1</span>中使用的扩展那样阻止发展机制<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">13 HTTP</span>中的缓存<span class="s2"><br>
</span><span class="s3">    HTTP</span>典型应用于能通过采用缓存技术而提高性能的分布式信息系统。<span class="s3">HTTP/1.1<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>包括的许多元素都尽可能的进行缓存操作。因为这些元素与<a href="http://www.cnpaf.net/">协议</a>的其他方面有着千丝万缕的联系，而且他们相互作用、影响。因此，独立于算法、报头、响应代码等的细节描述来讲述<span class="s3">HTTP</span>中缓存的基本设计是大有裨益的。<span class="s2"><br>
</span><span class="s3">    </span>如果不对缓存技术做明显改善，他将一无用处。<span class="s3">HTTP/1.1</span>中缓存的目的是降低在众多情况下发送请求的需要，同时降低在其他情况下发送完整响应的需要。前者使众多操作中往返流程减少，我们用<span class="s3">"</span>过期<span class="s3">" </span>机制来达到这一目的（见<span class="s3">13.2</span>节）；后者使网络带宽需求降低，我们用<span class="s3">"</span>认证<span class="s3">"</span>机制来达到这一目的（见<span class="s3">13.3</span>节）。</p>
<p class="p2"><span class="s3">  </span><span class="s2"><br>
</span><span class="s3">    </span>对性能<span class="s3">,</span>可用性和分离操作的需要要求我们能放宽语义透明度的要求<span class="s3">.HTTP1.1<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>允许源服务器<span class="s3">,</span>缓存和代理客户在必要时明确降低透明度<span class="s3">.</span>然而<span class="s3">,</span>因为不透明操作会迷惑不专业的用户<span class="s3">,</span>而且可能同某些服务器应用不兼容<span class="s3">(</span>如<span class="s3">).</span>在下列情况下<span class="s3">,<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>需要透明度被降低<span class="s3">:</span><span class="s2"><br>
</span><span class="s3">    </span>仅当代理或源服务器提出明确的<a href="http://www.cnpaf.net/">协议</a>层次的放宽请求<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">    </span>仅当缓存或代理向终端用户提出明确的放宽警告<span class="s3">.</span></p>
<p class="p2">因此<span class="s3">,HTTP1.1<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>满足如下要素<span class="s3">:</span><span class="s2"><br>
</span><span class="s3">      1.</span>当各部分都提出要求时<span class="s3">,<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>提供完全的语义透明度<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">      2.<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>允许源服务器或用户代理明确请求且控制不透明操作<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">      3.<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>允许缓存对未达到要求的语义透明度的响应发出警告<span class="s3">.        </span><span class="s2"><br>
</span>说明<span class="s3">:</span>服务器<span class="s3">,</span>缓存<span class="s3">,</span>或代理设备可能面临的设计决策不在本说明书讨论范围之内<span class="s3">.</span>如果有关于语义透明度的决策<span class="s3">,</span>此设备应尽力保持语义透明度除非有仔细而完整的<a href="http://www.cnpaf.net/">分析</a>表明破坏透明度将有重大好处<span class="s3">.</span></p>
<p class="p2"><span class="s3">13.1.1</span>缓存<span class="s3"> </span>正确性<span class="s2"><br>
</span><span class="s3">   </span>在如下列情况下<span class="s3">,</span>一个正确的缓存必须从他所存储的内容中选出最新者来响应请求<span class="s3">. (</span>参见<span class="s3">13.2.5,13.2.6,13.12</span>节<span class="s3">)</span><span class="s2"><br>
</span><span class="s3">     </span><span class="s2"><br>
</span><span class="s3">1. </span>经过检验<span class="s3">,</span>源服务器对收到响应重新确认生效返回的结果与原来相同<span class="s3">.</span>（参见<span class="s3">13.3</span>节）</p>
<p class="p2"><span class="s3">2</span>．<span class="s3">."</span>足够保鲜<span class="s3">"(</span>参见<span class="s3">13.2</span>节<span class="s3">).</span>在缺省值情况下<span class="s3">,</span>它表示对代理<span class="s3">,</span>源服务器和缓存<span class="s2"><br>
</span>的最低的保鲜性要求<span class="s3">(</span>参见<span class="s3">14.9</span>节<span class="s3">);</span>如果源服务器详细说明<span class="s3">,</span>那么保鲜性要求仅是对源服务器本身而言有效<span class="s3">.</span>如果某一存储的响应对代理和源服务器的最低保鲜要求仍不满足<span class="s3">,</span>慎重考虑<span class="s3">,</span>缓存应返回响应并加入适当警告报头<span class="s3">(</span>参见<span class="s3">13.1.5,14.46</span>节<span class="s3">),</span>除非这种响应是被禁止的<span class="s3">(</span>参见<span class="s3">14.9</span>节<span class="s3">).</span></p>
<p class="p1">3.  304(<span class="s1">未修改</span>),305(<span class="s1">代理人重寄</span>),<span class="s1">或</span> <span class="s1">错误</span>(4xx,5xx)<span class="s1">响应信息</span>.</p>
<p class="p2"><span class="s3">  </span><span class="s2"><br>
</span><span class="s3">        </span>如果缓存无法与源服务器通信<span class="s3">,</span>则当响应能正确的从缓存发出时<span class="s3">,</span>缓存应<span class="s2"><br>
</span>如上响应<span class="s3">;</span>如果不能<span class="s3">,</span>则缓存应发出错误或警告信息以说明存在通信故障<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">        </span>如果缓存收到响应<span class="s3">(</span>不论是一个完整响应还是一个<span class="s3">304</span>响应<span class="s3">),</span>它会将其转寄<span class="s2"><br>
</span>给请求客户<span class="s3">,</span>当收到的响应被刷新时<span class="s3">,</span>缓存应该转寄给请求客户而不须加入新的警告<span class="s2"><br>
</span>信息<span class="s3">(</span>且无需去掉已经存在的警告报头<span class="s3">).</span>缓存不能仅仅因为某一响应在传送过程中<span class="s2"><br>
</span><span class="s3">"</span>过时<span class="s3">"</span>了而令响应重新生效<span class="s3">,</span>这将引入一个死循环<span class="s3">.</span>一个用户代理收到没有警告的过<span class="s2"><br>
</span>时响应应对用户显示警告<span class="s3">.   </span></p>
<p class="p2"><span class="s2"><br>
</span><span class="s3">13.1.2 </span>警告信息<span class="s2"><br>
</span><span class="s3">        </span>当缓存器返回响应既不是第一手的也不是最保鲜<span class="s3">(fresh)</span>的<span class="s3">,</span>此响应必须附加警告<span class="s3">,</span><span class="s2"><br>
</span>使用一般警告报头<span class="s3">.</span>此警告报头信息和刚刚定义的警告在<span class="s3">14.46</span>中有详述<span class="s3">,</span>此警告允许<span class="s2"><br>
</span>客户采取适当行动<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">        </span>警告信息可以被用作他途<span class="s3">,</span>不论是否与缓存有关<span class="s3">.</span>警告的使用<span class="s3">,</span>而非错误状<span class="s2"><br>
</span>态代码区分了前述响应和实际错误<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">        </span>警告信息由三类阿拉伯数字代码表示<span class="s3">.</span>第一个数字表明当重发成功后警告信<span class="s2"><br>
</span>息是否必须或必须不被删除<span class="s3">.</span></p>
<p class="p2"><span class="s3">   See section 14.46 for the definitions of the codes themselves.</span><span class="s2"><br>
</span><span class="s3">1xx </span>这是描述响应刷新或重发状态的警告信息<span class="s3">,</span>因此在重发成后功必须被删除掉<span class="s2"><br>
</span><span class="s3">    1xx</span>警告信息仅当确认一个缓存实体时才由缓存器产生<span class="s3">.</span>它不能由代理端产生<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">2xx </span>一个描述实体内容或报头的警告信息<span class="s3">,</span>它不因重新确认而被矫正<span class="s3">,</span>而且在成功的<span class="s2"><br>
</span><span class="s3">     </span>重新确认后也不能被删除<span class="s3">.</span></p>
<p class="p1"><span class="s1">代码定义见</span>14.46</p>
<p class="p2"><span class="s3">        HTTP1.0 </span>缓存器存储响应中的所有警告信息<span class="s3">,</span>且不会删除第一类警告<span class="s3">.</span><span class="s2"><br>
</span>传给<span class="s3">HTTP1.0</span>的警告信息带有一个附加的警告数据区<span class="s3">,</span>它阻碍了未来的<span class="s3">HTTP1.1</span>兼<span class="s2"><br>
</span>容错误缓存警告<span class="s3">.  </span><span class="s2"><br>
</span><span class="s3">        </span>警告信息也传送一个警告文本<span class="s3">.</span>此文本可以使用任何自然语言<span class="s3">,</span>而且可以<span class="s2"><br>
</span>随意选择准用的字符<span class="s3">.</span></p>
<p class="p2"><span class="s3">        </span>响应可以附加多重警告<span class="s3">,</span>包括属于同一类代号的警告<span class="s3">.</span>例如<span class="s3">,</span>服务器可能<span class="s2"><br>
</span>提供同样的错误而文本包括英语和巴斯克语两种<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">        </span>当响应附加了多重警告信息时<span class="s3">,</span>把所有的信息都显示给用户是不合理的<span class="s2"><br>
</span>也是不现实的<span class="s3">.</span>此版本的<span class="s3">HTTP</span>并未指定严格规定警告显示的优先权和顺序<span class="s3">,</span>但却<span class="s2"><br>
</span>给出了一些提示<span class="s3">.</span></p>
<p class="p2"><span class="s3">13.1.3 </span>缓存控制机制<span class="s2"><br>
</span>在<span class="s3">HTTP1.1<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>中的基本缓存机制是隐含指示给缓存器<span class="s3">.</span>在某些情况下<span class="s3">,</span><span class="s2"><br>
</span>一服务器或代理可能需要给缓存器以明确的指示<span class="s3">,</span>我们用缓存器控制报头来达到<span class="s2"><br>
</span>这一目的<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">          </span>缓存器控制报头允许代理或服务器传送多种指示<span class="s3">,</span>既可以是请求<span class="s3">,</span>也可<span class="s2"><br>
</span>以是响应<span class="s3">.</span>这些指示代替缺省的缓存算法<span class="s3">.</span>作为一般规律<span class="s3">,</span>当出现明显的报头内<span class="s2"><br>
</span>容冲突时<span class="s3">,</span>最根本的协调办法是实用性原则<span class="s3">(</span>即为<span class="s3">,</span>选择能最好保持予以透明度<span class="s2"><br>
</span>的报头<span class="s3">),</span>可是<span class="s3">,</span>在某些情况下<span class="s3">,</span>缓存控制指示明显的削弱了语义透明度<span class="s3">.</span></p>
<p class="p1">        <span class="s1">缓存器控制指示详述于</span>14.9<span class="s1">节</span></p>
<p class="p2"><span class="s3">13.1.4</span>直接的用户代理警告<span class="s2"><br>
</span><span class="s3">        </span>很多用户代理允许用户覆盖基本缓存机制<span class="s3">.</span>例如，用户代理可能允许用户<span class="s2"><br>
</span>指定缓存实体是无效的。或者，用户代理还可能习惯于加上缓存控制：对任何请<span class="s2"><br>
</span>求最大值<span class="s3">=3600</span>。用户代理不应该默许非透明的行为或造成明显低效率的行为，但<span class="s2"><br>
</span>可以由用户的明确行动来外在配置。<span class="s2"><br>
</span><span class="s3">        </span>如果用户已经覆盖了基本缓存机制，用户代理应向用户明确指出，一旦<span class="s2"><br>
</span>此改变作用于信息显示，可能与透明度要求发生冲突。<a href="http://www.cnpaf.net/">协议</a>通常允许用户代理来<span class="s2"><br>
</span>决定响应是否已经失效，当实际发生时，该指示需要单独显示。该指示不必是对<span class="s2"><br>
</span>话框，它可以是一个图标。<span class="s2"><br>
</span><span class="s3">        </span>如果用户对缓存机制的覆盖使缓存器效率反常降低，用户代理应连续的<span class="s2"><br>
</span>将这一状态提示给用户以防止用户无意中占用了额外资源或面临过长的延迟。</p>
<p class="p2"><span class="s3">13.1.5 </span>规则和警告的例外情况<span class="s2"><br>
</span><span class="s3">           </span>在某些情况下，缓存操作员会选择设置缓存当用户未提出请求时发出过时<span class="s2"><br>
</span>的响应。这一决定不应草率作出，但有时为了提高性能，尤其当缓存与源服务器<span class="s2"><br>
</span>不良连接时，又是必须的。一旦缓存器返回一个失效的响应，这一定标明（使用<span class="s2"><br>
</span>警告报头）令代理端软件生效来警告用户，可能存在潜在的问题。</p>
<p class="p2"><span class="s3">        <a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>还允许用户代理采取措施来获得第一手的或最新的响应。因此，<span class="s2"><br>
</span>如果用户代理明确请求第一手的或最新的，缓存器不能返回过时响应，除非由于<span class="s2"><br>
</span>技术上或政策上的原因而无法实现。<span class="s2"><br>
</span><span class="s3">13.1.6 </span>由客户控制的行为<span class="s2"><br>
</span><span class="s3">           </span>当源服务器是满期信息的最初来源，在某些情况下，客户将需要控制<span class="s2"><br>
</span>缓存器决定是否回复缓存的响应而不使其生效。客户需要使用缓存器控制报头的<span class="s2"><br>
</span>几项指示来作此工作。<span class="s2"><br>
</span><span class="s3">   </span><span class="s2"><br>
</span><span class="s3">        </span>一个客户的请求可以指定它能接受的未确认响应的最长时限；指定一个<span class="s2"><br>
</span>零点控制确认所有响应。一客户还可以指定响应期满前的最小时限。所有这些操<span class="s2"><br>
</span>作增强了对缓存行为的控制，所以将不能放宽缓存器的语义透明度。<span class="s2"><br>
</span><span class="s3">   </span><span class="s2"><br>
</span><span class="s3">        </span>一客户也可以指定它接受失效响应，直到达到最大值。这放松了对缓存<span class="s2"><br>
</span>器的控制，也就可能与源服务器对语义透明度的限制发生冲突。但对不良连接<span class="s2"><br>
</span>时支持分离操作和提高性能来说又是必须的。</p>
<p class="p2"><span class="s2"><br>
</span><span class="s3">13.2          </span>过期<span class="s3">(Expiration)</span>模型<span class="s2"><br>
</span><span class="s3">13.2.1         </span>服务器指定模型<span class="s2"><br>
</span><span class="s3">           </span>当缓存器能完全避免向源服务器发送请求时，它工作于最佳状态。<span class="s2"><br>
</span>避免请求的根本机制是源服务器给出一个明确的未来过期时间，这样响应信<span class="s2"><br>
</span>息或许可以满足后来的请求。换句话说，缓存器不必首先联系服务器就能回复<span class="s2"><br>
</span>一个最新响应。<span class="s2"><br>
</span><span class="s3">  </span><span class="s2"><br>
</span><span class="s3">        </span>我们期望服务器能指定一个对响应的明确预期过期时间，以确保在到达期<span class="s2"><br>
</span>限之前，实体没有发生变化。当过期时间仔细选择时，这通常可以保持语义透明度。<span class="s2"><br>
</span><span class="s3">   </span>此过期机制仅应用于缓存器作出的响应，而不针对直接传递给请求客户的<span class="s2"><br>
</span>第一手响应。<span class="s2"><br>
</span><span class="s3">   </span><span class="s2"><br>
</span><span class="s3">        </span>如果一源服务器要强制一个语义透明的缓存器来确认每一个请求，它可<span class="s2"><br>
</span>以指定一个明确的已过去过期时间。这表明响应总是失时效的，因此缓存器应在用<span class="s2"><br>
</span>其答复后来的请求之前确认之。（见<span class="s3">14.9.4</span>）<span class="s3">       </span></p>
<p class="p2"><span class="s3">   </span><span class="s2"><br>
</span><span class="s3">        </span>如果源服务器想强制<span class="s3">HTTP1.1</span>缓存器无论如何配置都确认每条请求<span class="s3">,</span>则应<span class="s2"><br>
</span>该使用<span class="s3">"</span>必须再确认<span class="s3">"</span>缓存器控制指示<span class="s3">.(</span>见<span class="s3">14.9)</span></p>
<p class="p2"><span class="s3">        </span>服务器指定明确的过期时间既可以使用过期报头<span class="s3">,</span>也可以使用最大期限<span class="s3">(Max_age)</span><span class="s2"><br>
</span>报头<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">        </span>过期时间不能用来强制用户代理刷新其显示或重载其资源；它只应用于缓<span class="s2"><br>
</span>存机制，当一个对某资源的新请求发出时，此机制仅须检测该资源的过期状态。<span class="s2"><br>
</span>（见<span class="s3">13.13</span>）</p>
<p class="p2"><span class="s3">13.2.2         </span>启发式过期<span class="s2"><br>
</span><span class="s3">        </span>由于源服务器并不总是提供明确的过期时间<span class="s3">,HTTP</span>缓存器典型设置为启发<span class="s2"><br>
</span>式过期时间<span class="s3">,</span>采取使用其他报头值的算法来估计一个近似的过期时间。<span class="s3">HTTP1.1</span>说明<span class="s2"><br>
</span>书中并未给出详细算法，但却利用最坏情况来限制其结果。由于启发式过期次数可<span class="s2"><br>
</span>能影响语义透明度，故应慎重使用，而且我们鼓励源服务器提供尽可能大的过期<span class="s2"><br>
</span>次数。</p>
<p class="p2"><span class="s3">13.2.3 </span>年龄<span class="s3">(Age)</span>计算<span class="s2"><br>
</span><span class="s3">           </span>为了解缓存实体是否为最新，缓存器需要知道其年龄是否已超过保鲜时<span class="s2"><br>
</span>限。我们在<span class="s3">13.2.4</span>节中讨论如何计算后者，本节讨论如何计算响应或缓存实体的<span class="s2"><br>
</span>年龄。<span class="s2"><br>
</span><span class="s3">        </span>在此讨论中我们用<span class="s3">“NOW”</span>来表示<span class="s3">“</span>主机进行计算时时钟的当前值<span class="s3">”</span>。<span class="s2"><br>
</span>使用<span class="s3">HTTP<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>的主机，除了运行源服务器和缓存器的主机，应当使用<span class="s3">NTP[28]</span><span class="s2"><br>
</span>或其他类似<a href="http://www.cnpaf.net/">协议</a>来将其时钟同步到一个全球性的精确时间标准上来。</p>
<p class="p2"><span class="s3">        HTTP1.1<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>要求源服务器尽可能在发送每条响应时都附加一个日期<span class="s2"><br>
</span>报头来标明此响应产生的时间<span class="s3">.(</span>见<span class="s3">14.18)</span>我们用<span class="s3">"</span>日期值<span class="s3">"</span>这一短语来表示日期报<span class="s2"><br>
</span>头的值<span class="s3">----</span>一种适于算术操作的形式<span class="s3">.</span></p>
<p class="p2"><span class="s3">        </span>当从缓存获得响应消息时<span class="s3">,HTTP1.1</span>用年龄响应报头来传达其年龄信息<span class="s3">.</span><span class="s2"><br>
</span>年龄值是缓存器估计的源服务器生成或重新确认响应的时间值<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">        </span>本质上<span class="s3">,</span>年龄值是响应信息在从源服务器开始的所有缓存器驻留的时间<span class="s2"><br>
</span>加上其在网络路径上传输的时间<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">        </span>我们用年龄值（<span class="s3">"age_value"</span>）来标明年龄报头的值<span class="s3">----</span>一种适于算术操作的表示方法<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">        </span>一个人的年龄可以通过两种完全独立的途径来计算<span class="s3">:</span><span class="s2"><br>
</span><span class="s3">        1.</span>如果本地时钟与源服务器时钟同步的相当好<span class="s3">,</span>则用<span class="s3">"NOW"-</span>日期值<span class="s3">,</span>若结果<span class="s2"><br>
</span>为负<span class="s3">,</span>则取零<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">        2.</span>如果从源服务器开始的所有缓存器均执行<span class="s3">HTTP1.1</span>则就取年龄值（<span class="s3">age_value</span>）<span class="s3">.</span></p>
<p class="p2"><span class="s3">        </span>如上我们有两种方法计算响应的年龄<span class="s3">,</span>我们合并二者如下<span class="s3">:</span><span class="s2"><br>
</span>矫正后接收到的年龄值<span class="s3">=MAX(NOW-DATA_VALUE,AGE_VALUE)</span><span class="s2"><br>
</span><span class="s3">        </span>而且无论那种方法都能得到可靠的结果<span class="s3">.</span></p>
<p class="p2"><span class="s3">        </span>由于网络附加延时<span class="s3">,</span>一些重要时隙会在服务器产生响应和下一个缓存器或客<span class="s2"><br>
</span>户收到它之间被忽略<span class="s3">.</span>如果不经修订<span class="s3">,</span>这一延迟会带来不正常的低年龄<span class="s3">.       </span></p>
<p class="p1">      corrected_initial_age = corrected_received_age<span class="s2"><br>
</span>                            + (now - request_time)</p>
<p class="p1">        <span class="s1">因为导致返回年龄值的请求一定在年龄值的产生之前就发出了，我们可以</span><span class="s2"><br>
</span><span class="s1">通过记录请求发出的时间来矫正网络附加延时。则当收到一个年龄值时，它必将被</span><span class="s2"><br>
</span><span class="s1">认为与发出请求的时间有关，而不是收到响应的时间。这将保证不论经历多少延时，</span><span class="s2"><br>
</span><span class="s1">其表现都是稳定的。</span><span class="s2"><br>
</span><span class="s1">当缓存收到响应时的算法摘要：</span><span class="s2"><br>
</span>      /*<span class="s2"><br>
</span>       * age_value<span class="s2"><br>
</span>       *      is the value of Age: header received by the cache with<span class="s2"><br>
</span>       *              this response.<span class="s2"><br>
</span>       * date_value<span class="s2"><br>
</span>       *      is the value of the origin server's Date: header<span class="s2"><br>
</span>       * request_time<span class="s2"><br>
</span>       *      is the (local) time when the cache made the request<span class="s2"><br>
</span>       *              that resulted in this cached response<span class="s2"><br>
</span>       * response_time<span class="s2"><br>
</span>       *      is the (local) time when the cache received the<span class="s2"><br>
</span>       *              response<span class="s2"><br>
</span>       * now<span class="s2"><br>
</span>       *      is the current (local) time<span class="s2"><br>
</span>       */</p>
<p class="p1">      apparent_age = max(0, response_time - date_value);<span class="s2"><br>
</span>      corrected_received_age = max(apparent_age, age_value);<span class="s2"><br>
</span>      response_delay = response_time - request_time;<span class="s2"><br>
</span>      corrected_initial_age = corrected_received_age + response_delay;<span class="s2"><br>
</span>      resident_time = now - response_time;<span class="s2"><br>
</span>      current_age   = corrected_initial_age + resident_time;<span class="s2"><br>
</span>        <span class="s1">以上段落英文更明白一些。</span></p>
<p class="p2"><span class="s3">        </span>缓存实体的当前年龄是从缓存实体最后被服务器确认的时间（以秒记）<span class="s2"><br>
</span>加上校正初始年龄。当缓存实体产生一条响应，它必须包含一个年龄报头区：与缓<span class="s2"><br>
</span>存实体当前年龄一样的值。</p>
<p class="p2"><span class="s3">        </span>响应中存在年龄报头区意味着这不是第一手响应。但反之未必，因为那仅<span class="s2"><br>
</span>当所有缓存器均使用<span class="s3">HTTP1.1</span>时才成立。<span class="s2"><br>
</span><span class="s3">13.2.4         </span>过期计算：<span class="s2"><br>
</span><span class="s3">           </span>为了确定一条响应是新是旧，我们需要将其保鲜期限和年龄进行比较，年龄的计算见<span class="s3">13</span>。<span class="s3">2</span>。<span class="s3">3</span>节，本节讲解怎样计算保鲜期限，以及一条响应是否已经被排出。在下面的讨论中，数值可以用任何适于算术操作的形式表示。<span class="s2"><br>
</span><span class="s3">        </span>我们用<span class="s3">“</span>过期数值<span class="s3">”</span>（<span class="s3">"expires_value"</span>）来标明过期报头，我们用<span class="s3">“</span>最大年龄值<span class="s3">”</span>来标明缓存控制报头的秒数。（<span class="s3">question?</span>）<span class="s2"><br>
</span><span class="s3">   </span><span class="s2"><br>
</span>最大年龄在过期之前指示，所以一旦响应中出现最大年龄，计算将变得非常简单。</p>
<p class="p1">      freshness_lifetime = max_age_value</p>
<p class="p1">  <span class="s1">否则，若缓存中出现</span>“Expires”<span class="s1">，计算如下：</span><span class="s2"><br>
</span>      freshness_lifetime = expires_value - date_value</p>
<p class="p2"><span class="s3">        </span>注意上述运算不受时钟误差影响，因为所有信息均来自源服务器。<span class="s2"><br>
</span><span class="s3">   </span>如果<span class="s3"> Expires, </span>缓存控制<span class="s3">: max-age, </span>或<span class="s3"> </span>缓存控制<span class="s3">: s-maxage (</span>见<span class="s3"> 14.9.3) </span>均未在响应中出现<span class="s3">,</span>且响应对缓存没有其他限制，<span class="s3"> </span>缓存可以用启发式算法计算<span class="s3">freshness lifetime</span>。缓存器必须对年龄大于<span class="s3">24</span>小时又不带警告的响应附加<span class="s3">113</span>号警告。</p>
<p class="p2">而且，如果响应有最后修改时间，启发式过期值应不大于时间片。典型设置为片断的<span class="s3">10%</span><span class="s2"><br>
</span><span class="s3">   </span>计算响应是否过期非常简单：</p>
<p class="p1">      response_is_fresh = (freshness_lifetime &gt; current_age)</p>
<p class="p2"><span class="s3">13.2.5 </span>澄清过期值<span class="s2"><br>
</span><span class="s3">        </span>由于过期值不是严格制定的，所以可能两个缓存器对相同资源制定的刷新值不同。<span class="s2"><br>
</span><span class="s3">   </span><span class="s2"><br>
</span><span class="s3">        </span>如果客户对一个在其缓存中以刷新的请求作出一个恢复的非第一手响应，而且缓存实体中的日期值比响应中的新。，则客户可以忽略此响应。如果这样，将要求<span class="s3">“</span>缓存控制<span class="s3">”</span>：<span class="s3">max-age=0 </span>来强迫检查源服务器。<span class="s2"><br>
</span><span class="s3">           </span>如果缓存器有两个描述相同而确认器不同的响应，它必须使用有最近日期报头的那个。<span class="s2"><br>
</span><span class="s3">13.2.6 </span>澄清多重响应<span class="s2"><br>
</span><span class="s3">        </span>因为客户可能收到经多重路径来的响应，所以有些响应流经一簇缓存器，而另一些响应流经另一簇缓存器，客户收到响应的顺序可能与源服务器发响应的顺序不同，我们希望客户能选用最新的响应。<span class="s2"><br>
</span><span class="s3">        </span>实体标签和过期值都不能影响响应顺序，晚一点的响应可能带有早的过期时间。日期值的精度也只有一秒。<span class="s2"><br>
</span><span class="s3">        </span>当缓存器要重新确认一个缓存实体，而且受到响应的日期报头晚于已存在的实体，则客户应无条件的重复请求。</p>
<p class="p1">       Cache-Control: max-age=0</p>
<p class="p2">强制任何中间缓存器确认它们的副本。</p>
<p class="p1">       Cache-Control: no-cache</p>
<p class="p2">或者强制它们从源服务器获取一个新的副本。<span class="s2"><br>
</span>如果日期值相同，可以使用任何一个响应。</p>
<p class="p2"><span class="s3">13.3        </span>确认模式<span class="s2"><br>
</span><span class="s3">           </span>当缓存器想要用一个失时效的条目来相应客户的请求<span class="s3">,</span>他首先必须向源<span class="s2"><br>
</span>服务器<span class="s3">(</span>如果可能则向一中间缓存器<span class="s3">)</span>检验这一缓存条目是否仍然可用<span class="s3">.</span>我们称之为<span class="s2"><br>
</span><span class="s3">"</span>确认<span class="s3">"</span>缓存条目<span class="s3">.</span>由于我们不想当缓存条目为可用时必须为再传送整条响应而付出<span class="s2"><br>
</span>代价<span class="s3">,</span>而且不想当缓存条目不可用时也必须多传一圈<span class="s3">,HTTP1.1<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>支持使用条件反应方法<span class="s3">.</span></p>
<p class="p2"><span class="s3">          <a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>支持条件响应方法的关键特征围绕<span class="s3">"</span>缓存确认器<span class="s3">"</span>展开<span class="s3">.</span>当源服务器<span class="s2"><br>
</span>生成一个完整响应时<span class="s3">,</span>它同时传送一类确认器一直伴随着缓存条目<span class="s3">.</span>当一客户<span class="s3">(</span>用户<span class="s2"><br>
</span>代理或代理缓存器<span class="s3">)</span>对含有缓存条目的资源做出条件请求时<span class="s3">,</span>他同时在请求中包含有相互关联的确认器<span class="s3">.</span></p>
<p class="p2"><span class="s3">          </span>服务器则核对此确认器和当前确认器<span class="s3">,</span>如果他们匹配<span class="s3">(</span>见<span class="s3">13.3.3),</span>则返回<span class="s2"><br>
</span>一个特定状态码<span class="s3">(</span>通常为<span class="s3">304)</span>且不含条目内容<span class="s3">.</span>否则<span class="s3">,</span>返回整个响应<span class="s3">(</span>包含条目内容<span class="s3">)</span><span class="s2"><br>
</span>这样<span class="s3">,</span>我们避免了在确认器匹配时传送整条响应<span class="s3">,</span>同时也避免了在不匹配时往返传输<span class="s3">.</span></p>
<p class="p2"><span class="s3">        </span>在<span class="s3">HTTP1.1<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>中<span class="s3">,</span>一个条件请求除了带有特别的报头<span class="s3">(</span>包含确认器<span class="s3">)</span>来暗中<span class="s2"><br>
</span>的将它转入条件算法以外<span class="s3">,</span>和普通报头没有差别<span class="s3">.</span></p>
<p class="p2"><span class="s3">        <a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>中包括缓存确认机制的主动和被动两种状态<span class="s3">.</span>具体说来<span class="s3">,</span>请求可以在<span class="s2"><br>
</span>当且仅当又匹配确认时执行<span class="s3">,</span>也可以在当且仅当没有匹配确认时执行<span class="s3">.</span></p>
<p class="p2"><span class="s3">        </span>说明<span class="s3">:</span>没有确认器的响应也可以缓冲存储且接受服务直至被排出<span class="s3">,</span>除非这是<span class="s2"><br>
</span>被缓存控制指令明确禁止的<span class="s3">.</span>可是<span class="s3">,</span>如果没有确认器<span class="s3">,</span>则缓存不能有条件的恢复它<span class="s3">,</span>这表明无法刷新除非被排出<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">        </span><span class="s2"><br>
</span><span class="s3">13.3.1 </span>最后修改日期<span class="s3">        (Last-Modified Dates)</span><span class="s2"><br>
</span><span class="s3">        </span>最后修改报头值经常被用作确认器<span class="s3">.</span>简言之<span class="s3">,</span>一缓存条目在最后修改期后<span class="s2"><br>
</span>未经修改则被认为是有效的<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">13.3.2         </span>标签缓存确认器<span class="s3">(Entity Tag Cache Validators)</span><span class="s2"><br>
</span><span class="s3">           </span>标签响应报头值<span class="s3">,</span>一个实体标签<span class="s3">,</span>提供了一个<span class="s3">"</span>模糊<span class="s3">"</span>缓存确认器<span class="s3">.</span>这将允许<span class="s2"><br>
</span>在不便存储修改信息的情况下进行可靠的确认<span class="s3">,</span>包括<span class="s3">HTTP</span>日期数据不充足和源服<span class="s2"><br>
</span>务器不想因使用修改日期而带来麻烦的情况<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">          </span>实体标签描述见<span class="s3">3.11</span>节<span class="s3">,</span>有关其报头的描述见<span class="s3">14.19,14.24,14.26,14.44.</span><span class="s2"><br>
</span><span class="s3">13.3.3         </span>强<span class="s3">,</span>弱确认器<span class="s2"><br>
</span><span class="s3">        </span>由于源服务器和缓存器会比较两个确认器来确定他们是否代表相同的条目<span class="s3">,</span>所以通常希望实体发生任何变化<span class="s3">,</span>确认器也相应变化<span class="s3">,</span>这样的确认器为强确认器<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">        </span>同时还会有这样的情况<span class="s3">,</span>服务器倾向于仅在发生重要的语义变化时才改变确认器<span class="s3">.</span>在资源变化时确认器未必变化的称为弱确认器<span class="s3">.</span><span class="s2"><br>
</span>实体标签通常是强确认<span class="s3">,</span>但<a href="http://www.cnpaf.net/">协议</a>提供一种机制来标志弱　<span class="s3">Copyright  www.cnpaf.net (2007).          All Rights Reserved.</span><span class="s2"><br>
</span>确认<span class="s3">.</span>可以认为<span class="s3">,</span>强确认在实体的每一字节变化时均变化<span class="s3">,</span>而弱确认仅在实体含义变化时才变化<span class="s3">,</span>强确认是某一特定实体的标志<span class="s3">,</span>而弱确认是某一类同义实体的标志<span class="s3">.</span><span class="s2"><br>
</span>注<span class="s3">: </span>强确认的例子<span class="s3">:</span>一个整数<span class="s3">,</span>他随着每次实体发生变化而定值增长<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">        </span>一个实体的修改时间<span class="s3">(</span>以秒计算<span class="s3">)</span>可以作为弱确认器<span class="s3">,</span>因为实体可能在一秒内变化两次<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">        </span>对弱确认的支持是可选的<span class="s3">.</span>支持弱确认可带来等价体的高效缓存<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">        </span>当客户生成一个在确认报头中包含确认器的请求或服务器进行比较时均要用到确认器<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">        </span>强确认可在任何情况下使用<span class="s3">,</span>而弱确认仅在不依赖严格相等时才可用<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">        </span>客户可以发出简单<span class="s3">GET</span>请求<span class="s3">,</span>伴随强<span class="s3">,</span>弱确认器均可<span class="s3">.</span>客户在发其他请求时<span class="s3">,</span>不能用弱确认<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">HTTP1.1<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>定义确认的唯一功能是比较<span class="s3">.</span>有两种比较功能<span class="s3">,</span>这依赖于是否允许弱确认<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">        -- </span>为了同等考虑<span class="s3">,</span>两确认器必须完全一样且均非弱确认<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">        -- </span>两确认器必须完全相同<span class="s3">,</span>且至少有一个被标明为<span class="s3">"</span>弱<span class="s3">".</span></p>
<p class="p2"><span class="s3">        </span>除非被明确标清<span class="s3">,</span>实体标签是强的<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">        </span>最后修改时间被用作请求的确认器时默认为弱的<span class="s3">,</span>除非从下列规则导出强的结论<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">        </span>确认器不会在一秒内变化两次<span class="s3">.</span><span class="s2"><br>
</span>或者<span class="s2"><br>
</span><span class="s3">      </span><span class="s2"><br>
</span><span class="s3">      -</span>确认器可能被用户用于<span class="s3">If-Modified-Since </span>或者<span class="s3"> If-Unmodified-Since</span>报头。<span class="s2"><br>
</span><span class="s3">      -</span>此缓存实体包含一日期值，他给出源服务器发出响应的时间。<span class="s2"><br>
</span><span class="s3">      -</span>最后修改时间至少比日期值早六十秒。<span class="s2"><br>
</span>或者<span class="s2"><br>
</span><span class="s3">      -</span>确认器已经被中间缓存器同缓存实体比较过<span class="s3"> </span><span class="s2"><br>
</span><span class="s3">      -</span>此缓存实体包含日期值，给出源服务器发出响应的时间。<span class="s3"> </span><span class="s2"><br>
</span><span class="s3">      -</span>最后修改时间至少比日期值早六十秒。</p>
<p class="p2"><span class="s3">        </span>此种方法基于以下事实<span class="s3">:</span>如果两条响应在同一秒内被发出但有相同的最后修改时间<span class="s3">,</span>则至少有一条响应日期值和最后修改时间是相同的<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">        </span>如果客户在仅有最后修改时间没有模糊确认器的情况下执行子范围修复<span class="s3">,</span><span class="s2"><br>
</span>则仅当最后修改时间是强确认时才可以<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">        </span>若缓存器或源服务器收到一个条件请求<span class="s3">,</span>而不是完整<span class="s3">GET</span>响应<span class="s3">,</span>则必须使用强比较函数<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">          </span>此规定允许<span class="s3">HTTP1.1<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>下<span class="s3">,</span>缓存器和客户可以对从<span class="s3">HTTP1.0</span>中得到的值<a href="http://www.cnpaf.net/class/security/">安全</a>的进行子域恢复<span class="s3">.</span></p>
<p class="p2"><span class="s3">13.3.4         </span>关于何时使用实体标签和最后修改时间的规则<span class="s2"><br>
</span><span class="s3">           </span>我们对源服务器，客户和缓存器采用一套规则和建议来规定在何时，出<span class="s2"><br>
</span>于何种目的，应采用何种确认器。<span class="s2"><br>
</span><span class="s3">   HTTP/1.1 </span>源服务器：<span class="s2"><br>
</span><span class="s3">        -</span>应该发送一实体标签除非它做不到。<span class="s2"><br>
</span><span class="s3">        -</span>可以发送弱实体标签如果其满足性能要求或不能发送强确认。<span class="s2"><br>
</span><span class="s3">        </span>换句话说，对<span class="s3">http1.1</span>服务器来说<span class="s3">,</span>比较好的做法是同时发送强实体标签和最后修改值<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">        </span>说明<span class="s3">:</span>为保证语义透明缓存<span class="s3">,</span>服务器必须避免两个不同实体重复利用同一<span class="s2"><br>
</span>强实体标签值或者两类不同语义的实体重复使用同一弱实体标签值<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">   HTTP/1.1 </span>客户：<span class="s2"><br>
</span><span class="s3">        -</span>若服务器用实体标签<span class="s3">,</span>则必须对任何缓存条件请求都使用此实体标签<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">        -</span>仅当服务器提供最后修改值时<span class="s3">,</span>它应该在非子域条件请求中使用该值<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">        -</span>仅当<span class="s3">HTTP1.0</span>服务器提供了最后修改值时<span class="s3">,</span>他可以在子域缓存条件请求<span class="s2"><br>
</span><span class="s3">        </span>中使用该值<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">        -</span>若两者均被提供<span class="s3">,</span>则两者均应使用<span class="s3">.</span></p>
<p class="p2"><span class="s3">        </span>当一服务器收到的请求既包括最后修改时间也包括一个或多个实体标签<span class="s3">,</span><span class="s2"><br>
</span>则它一定不能发出<span class="s3">304</span>代码<span class="s3">,</span>除非这是协调好的<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">        </span>当一个<span class="s3">HTTP1.1</span>缓存代理收到上述请求时<span class="s3">,</span>一定不能返回一个本地缓存响<span class="s2"><br>
</span>应给客户<span class="s3">,</span>除非它对所有请求都是一致的<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">        </span>说明<span class="s3">:</span>一般规律是传送尽量多的非冗余信息<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">        HTTP1.0</span>客户和缓存器忽略实体标签<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">13.3.5 </span>不确认条件<span class="s2"><br>
</span><span class="s3">           </span>其他报头的比较不被用于确认缓存实体<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">13.4 </span>缓存能力响应<span class="s2"><br>
</span><span class="s3">             </span>除非被明确限制<span class="s3">,</span>缓存系统可以将一成功的响应作为缓存实体一直存储<span class="s3">,</span>如果它是保鲜的可以不确认而返回它<span class="s3">,</span>如果成功确认<span class="s3">,</span>也可以返回它<span class="s3">.</span></p>
<p class="p2"><span class="s3">        </span>说明<span class="s3">:</span>某些<span class="s3">HTTP1.0</span>缓存器可能违反这一条而不提示警告<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">        </span>还有<span class="s3">,</span>某些情况下可能不便保留一实体<span class="s3">,</span>或将其返回给后续请求<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">   </span>注意<span class="s3">14.8</span>节防止共享缓存存储和回复一个早先的包含授权报头的请求<span class="s3">.        </span><span class="s2"><br>
</span><span class="s3">          </span>包含状态码<span class="s3">200,203,206,300,301</span>或<span class="s3">410</span>的响应可能会被用于回复后面的响应<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">        </span>带有其他一些状态码的响应不能用于回复后面的请求<span class="s3">,</span>除非有明确的缓存控制<span class="s2"><br>
</span>或其他报头允许之<span class="s3">.</span></p>
<p class="p2"><span class="s3">13.5 </span>从缓存器构造响应<span class="s2"><br>
</span><span class="s3">           </span>缓存器的目的是存储响应请求的信息来响应后面的请求<span class="s3">.</span>再很多情况下<span class="s3">,</span>缓<span class="s2"><br>
</span>存器仅返回响应的适当部分给请求者<span class="s3">.</span>如果缓存器保有一个基于前面请求的实体<span class="s3">,</span>它<span class="s2"><br>
</span>可能必须将其与新响应合并<span class="s3">.</span></p>
<p class="p1">13.5.1 <span class="s1">端到端和</span>Hop-by-hop<span class="s1">报头</span><span class="s2"><br>
</span>        <span class="s1">为定义缓存器行为</span>,<span class="s1">我们将报头分成两类</span>:<span class="s2"><br>
</span>        <span class="s1">端到端报头和</span>hop_by_hop<span class="s1">报头（仅对简单的传输层连接有意义，不被缓存，</span><span class="s2"><br>
</span>                                    <span class="s1">也不被代理服务器向前传递）</span><span class="s2"><br>
</span>              <span class="s2"><br>
</span>    hop-by-hop <span class="s1">报头</span>:</p>
<p class="p1">      - Connection                   <span class="s1">连接</span><span class="s2"><br>
</span>      - Keep-Alive                <span class="s1">保活</span>        <span class="s2"><br>
</span>      - Proxy-Authenticate        <span class="s1">代理人鉴别</span><span class="s2"><br>
</span>      - Proxy-Authorization        <span class="s1">代理人授权</span><span class="s2"><br>
</span>      - TE<span class="s2"><br>
</span>      - Trailers                <span class="s1">轨迹</span><span class="s2"><br>
</span>      - Transfer-Encoding        <span class="s1">传输编码</span><span class="s2"><br>
</span>      - Upgrade                        <span class="s1">升级</span></p>
<p class="p1"><span class="s1">所有其他均为端到端报头</span><span class="s2"><br>
</span>13.5.2         <span class="s1">不可更改报头</span><span class="s2"><br>
</span>           HTTP1.1<span class="s1">的某些特征</span>,<span class="s1">如分类鉴定</span>,<span class="s1">基于某一端到端报头值</span>.<span class="s1">一透明代理不能</span><span class="s2"><br>
</span><span class="s1">修改端到端报头除非报头要求或明确许可</span>.<span class="s2"><br>
</span>   <span class="s2"><br>
</span><span class="s1">传输代理不能修改下列各项，如果他们不存在，也不能添加。</span><span class="s2"><br>
</span>      - Contents location<span class="s2"><br>
</span>         <span class="s1">目录区</span><span class="s2"><br>
</span>      - Content-MD5<span class="s2"><br>
</span>        <span class="s2"><br>
</span>      - ETag</p>
<p class="p1">      - Last-Modified<span class="s2"><br>
</span>        <span class="s1">最后修改时间</span></p>
<p class="p1">              - Expires</p>
<p class="p2"><span class="s3">        </span>但它可以添加这些区域<span class="s3">.</span>如果排除报头被添加<span class="s3">,</span>则必须赋值来标明次响应的<span class="s2"><br>
</span>日期报头<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">       </span><span class="s2"><br>
</span><span class="s3">        </span>包括不变形缓存控制指示或有请求<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">      - Content-Encoding</span><span class="s2"><br>
</span><span class="s3">        </span>内容编码<span class="s2"><br>
</span><span class="s3">      - Content-Range</span><span class="s2"><br>
</span><span class="s3">        </span>内容区<span class="s2"><br>
</span><span class="s3">      - Content-Type</span><span class="s2"><br>
</span><span class="s3">        </span>内容类型<span class="s2"><br>
</span><span class="s3">        </span>警告<span class="s3">:</span>对端到端报头的不必要修改可能导致在今后高版本<a href="http://www.cnpaf.net/">协议</a>引入更强的鉴<span class="s2"><br>
</span>定机制后鉴定失败<span class="s2"><br>
</span><span class="s3">        </span>内容长度区的去留规则见<span class="s3">4.4</span>节<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">13.5.3         </span>联合报头（<span class="s3">Combining Headers</span>）<span class="s2"><br>
</span><span class="s3">        </span>但缓存向服务器发出确认请求<span class="s3">,</span>若服务器回复<span class="s3">304</span>或<span class="s3">206</span>响应<span class="s3">,</span>则缓存器构<span class="s2"><br>
</span>造响应回复给请求客户<span class="s3">.        </span><span class="s2"><br>
</span><span class="s3">        </span>若状态码为<span class="s3">304,</span>则缓存器使用缓存实体的报文构造响应<span class="s3">,</span>若状态码为<span class="s3">206</span><span class="s2"><br>
</span>且标签和最后修改时间恰好匹配<span class="s3">,</span>则缓存器可以将存储的和刚收到的实体和并作为<span class="s2"><br>
</span>新响应的报文<span class="s3">(</span>见<span class="s3"> 13.5.4).</span></p>
<p class="p2">缓存实体中的端到端报头用于构造响应<span class="s3">,</span>排除以下内容<span class="s3">:</span><span class="s2"><br>
</span><span class="s3">        -1xx</span>警告报头被删除<span class="s2"><br>
</span><span class="s3">        -2xx</span>保留<span class="s2"><br>
</span><span class="s3">        -304</span>或<span class="s3">206</span>响应中的报头代替缓存实体中的相应部分。<span class="s2"><br>
</span>除非要删除缓存实体，缓存器必须用收到的响应报头取代端到端报头。换句话说，<span class="s2"><br>
</span>接收到的端到端报头覆盖缓存实体中已有的端到端报头。<span class="s2"><br>
</span><span class="s3">      </span><span class="s2"><br>
</span>注意：此规则允许源服务器用<span class="s3">304</span>或<span class="s3">206</span>响应来刷新缓存器中的相应实体。</p>
<p class="p2"><span class="s2"><br>
</span><span class="s3">13.5.4 </span>联合字节范围<span class="s2"><br>
</span><span class="s3">        </span>一条响应可能仅传送一条正文的一部分，经过几次这种传送，一缓存器可能会<span class="s2"><br>
</span>收到同一条正文的好几部分。<span class="s2"><br>
</span><span class="s3">   </span><span class="s2"><br>
</span><span class="s3">        </span>如果缓存器已经收到正文的一部分，且又收到了另一部分，缓存器可以<span class="s2"><br>
</span>将新收到的内容与已有内容合并，当所有收到的响应及缓存实体含有强确认时。</p>
<p class="p2"><span class="s3">13.6 </span>缓存谈判响应<span class="s2"><br>
</span><span class="s3">     </span>使用服务器驱动内容转让<span class="s3">(</span>见<span class="s3">12.1),</span>由响应中的变化报头区说明<span class="s3">, </span>改变了缓存器能用响应回复后续请求的条件和过程<span class="s3">.(</span>服务器使用变化报头区见<span class="s3">14.44)      </span><span class="s2"><br>
</span><span class="s3">   </span><span class="s2"><br>
</span><span class="s3">     </span>服务器要用变化报头区告知缓存器在众多可缓存响应类型用什么样的请求<span class="s2"><br>
</span>报头区来用服务器驱动转让<span class="s3">.</span>变化区命名此类报头区为<span class="s3">"</span>选择<span class="s3">"</span>请求报头<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">  </span><span class="s2"><br>
</span><span class="s3">        </span>当缓存器收到指定一个或　<span class="s3">Copyright  www.cnpaf.net (2007).          All Rights Reserved.</span><span class="s2"><br>
</span>更多包含变化报头区的缓存实体的后续请求<span class="s3">,</span>缓存器不能用这样的缓存实体来构造新请求的响应<span class="s3">,</span>除非新请求中所有选中的请求报头与初始请求相应部分匹配<span class="s3">.   </span><span class="s2"><br>
</span><span class="s3">   </span><span class="s2"><br>
</span><span class="s3">        </span>当且仅当两个请求中的选择请求报头可以从前一请求变形为后一请求时称为匹配<span class="s3">.</span>变形指<span class="s3">,</span>在相应的<span class="s3">BNF</span>允许的位置增加或删除<span class="s3">LWS,</span>或者按照<span class="s3">4.2</span>节中的消息报头规则合并合并同名的多个消息报头区<span class="s3">.</span></p>
<p class="p2"><span class="s3">   </span><span class="s2"><br>
</span><span class="s3">        </span>一个变化报头区数值<span class="s3">"*"</span>一般不能匹配而且对该资源的后续请求<span class="s3">,</span>服务器只能粗略解释<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">  </span><span class="s2"><br>
</span><span class="s3">        </span>如果旧的请求报头不能匹配新的<span class="s3">,</span>缓存器不能用相应缓存实体来回复响应<span class="s2"><br>
</span>除非它第一个将请求发给服务器且服务器回复<span class="s3">304,</span>包括实体标签或内容地址说明<span class="s2"><br>
</span>实体可用<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">   </span><span class="s2"><br>
</span><span class="s3">        </span>如果一实体标签用于标志缓存的代表<span class="s3">,</span>向前传递的请求应该是条件的且包<span class="s2"><br>
</span>括实体标签<span class="s3">.</span>这给服务器揭示了缓存器刚刚缓存的所有实体<span class="s3">,</span>所以如果其中任何实体与请求实体匹配<span class="s3">,</span>服务器可以用<span class="s3">304</span>响应中的<span class="s3">ETag</span>报头区来稿置缓存实体可达<span class="s3">.</span>如果新请求中的实体标签与已存在实体匹配<span class="s3">,</span>则新响应应该用于刷新存在实体的报头区<span class="s3">, </span>并将结果返回给客户<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">   </span><span class="s2"><br>
</span><span class="s3">        </span>如果任何已存在缓存实体仅包括相关实体的部分内容<span class="s3">,</span>它的实体标签不能<span class="s2"><br>
</span>包含于<span class="s3">If-None-Match</span>报头区中<span class="s3">, </span>除非此请求是对一个被该实体完全满足的区域<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">  </span><span class="s2"><br>
</span><span class="s3">        </span>如果缓存器收到一个成功响应<span class="s3">,</span>已存在实体不能回复将来的响应且应该被删除<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">  </span><span class="s2"><br>
</span><span class="s3">13.7 </span>共享和非共享缓存</p>
<p class="p2"><span class="s3">        </span>出于<a href="http://www.cnpaf.net/class/security/">安全</a>和保密考虑，有必要区分共享和非共享缓存。非共享缓存是仅<span class="s2"><br>
</span>供一个用户使用的缓存器，此种情况下，可用性由适当的<a href="http://www.cnpaf.net/class/security/">安全</a>机制控制。其它缓<span class="s2"><br>
</span>存器均被认为是共享缓存。此<a href="http://www.cnpaf.net/">协议</a>的其它部分给出了其它的一些限制以防止隐私<span class="s2"><br>
</span>的丢失和可达控制的失败。</p>
<p class="p2"><span class="s3">13.8 </span>错误和不完全响应缓存行为</p>
<p class="p2"><span class="s3">        </span>缓存器收到不完整响应时也可以存储它，但是必须把它看作部分响应。<span class="s2"><br>
</span>部分相应可以合并（见<span class="s3">13.5.4</span>）<span class="s3">;</span>合并结果可能是完整的或仍是部分的<span class="s3">.</span>缓存器<span class="s2"><br>
</span>不能把部分相应回复给客户<span class="s3">,</span>除非有明确要求<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">        </span>如果缓存器在试图重新确认一实体时收到<span class="s3">5xx</span>响应，它既可以将其传送给<span class="s2"><br>
</span>客户也可以认为服务器响应失败。后一种情况，它可以回复一个以前接收到的响应<span class="s2"><br>
</span>除非缓存实体明确要求<span class="s3">“</span>必须确认<span class="s3">”</span></p>
<p class="p1">13.9  GET <span class="s1">和</span> HEAD <span class="s1">的副作用：</span></p>
<p class="p2"><span class="s3">        </span>除非服务器明确禁止缓存它们的响应，对任何资源应用<span class="s3">GET</span>和<span class="s3">HEAD</span>算法，<span class="s2"><br>
</span>如果响应曲子缓存器，都不会引起能导致错误的副作用。他们确实有副作用，但<span class="s2"><br>
</span>缓存器在决定缓存时不必考虑。缓存器总是<span class="s3">“</span>看源服务器的脸色行事<span class="s3">”</span>。<span class="s2"><br>
</span><span class="s3">   </span><span class="s2"><br>
</span>一个例外：有些应用习惯于在<span class="s3">query URLs</span>时使用<span class="s3">GET</span>和<span class="s3">HEAD</span>，从而带来显著的副作用，<span class="s2"><br>
</span>缓存器不能认为对他们的响应是刷新的，除非服务器明确给出过期时间。这说明不能<span class="s2"><br>
</span>从缓存器取出<span class="s3">HTTP1.0</span>服务器对<span class="s3">URIs</span>的响应。</p>
<p class="p2"><span class="s3">13.10 </span>刷新或删除后的无效性<span class="s2"><br>
</span><span class="s3">        </span>某些算法对源服务器资源的操作将使一个或多个已存在的缓存实体不可<span class="s2"><br>
</span>用，即为，虽然他们还是<span class="s3">“</span>新鲜<span class="s3">”</span>的，但却不能准确反映源服务器想回复给请求<span class="s2"><br>
</span>的信息。</p>
<p class="p2"><span class="s3">        HTTP<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>无法保证所有此类实体均被标明无效。例如，引起源服务器变<span class="s2"><br>
</span>化的请求可能没到达存贮缓存实体的代理服务器，但是，有一些规则帮助减少类<span class="s2"><br>
</span>似的错误。</p>
<p class="p2"><span class="s3">   </span><span class="s2"><br>
</span><span class="s3">        </span>本节中，<span class="s3">“</span>使一个实体失效<span class="s3">”</span>表示缓存器或者删除该实体的所有<span class="s3">instances</span>，或者标明其为不可用，而且在重新用于回复后面的响应前必须有重新确认命令。</p>
<p class="p2"><span class="s3">        </span>某些<span class="s3">HTTP</span>算法必将导致缓存器使一个实体失效。这是实体被<span class="s3">URI</span>请求或内<span class="s2"><br>
</span>容区域报头提到。这些算法是<span class="s3">:</span></p>
<p class="p1">      - PUT<span class="s2"><br>
</span>      - DELETE<span class="s2"><br>
</span>      - POST</p>
<p class="p2"><span class="s3">        </span>为了防止服务器拒绝处理，基于<span class="s3">URI</span>或内容区域报头的失效处理仅当主机<span class="s2"><br>
</span>部分与<span class="s3">URI</span>请求相同时才进行。</p>
<p class="p2"><span class="s3">          </span>缓存器向它不理解的算法传递请求时令所有被<span class="s3">URI</span>请求指明的实体失效。</p>
<p class="p2"><span class="s3">13.11 </span>强制写通过（<span class="s3"> Write-Through</span>）<span class="s2"><br>
</span><span class="s3">        </span>所有可能对源服务器资源进行修改的算法都要写给源服务器。这通常包括<span class="s2"><br>
</span>所有算法除了<span class="s3">GET</span>和<span class="s3">HEAD</span>。缓存在将此种请求转给内地服务器并获得相应答复前不<span class="s2"><br>
</span>能对请求客户做出响应。</p>
<p class="p2"><span class="s3">        </span>相反情况（<span class="s3">write-back</span>）在<span class="s3">HTTP1.1</span>中是不允许的，这是由于提供一致更新<span class="s2"><br>
</span>非常困难且服务器缓存和网络的故障比<span class="s3">“write-back”</span>早。</p>
<p class="p2"><span class="s2"><br>
</span><span class="s3">13.12 </span>缓存替换<span class="s2"><br>
</span><span class="s3">        </span>如果收到一个新的响应，它的同源响应均已被缓存，缓存器就要用新响应<span class="s2"><br>
</span>回复当前请求，且将其插入缓存器存储区，并用其回复所有被退回的旧响应。<span class="s2"><br>
</span><span class="s3">        </span>说明：一个日期报头比已存响应旧的新响应是不可缓存的。</p>
<p class="p1"><span class="s2"><br>
</span>13.13 <span class="s1">历史纪录</span></p>
<p class="p2"><span class="s3">        </span>用户代理经常使用历史体制来重新获得以前的实体。<span class="s2"><br>
</span><span class="s3">        </span>历史机制和缓存是不同的，尤其历史对资源的当前状态是不透明的，更准<span class="s2"><br>
</span>确地说就是历史纪录明示用户在获得资源时看到了什么。<span class="s2"><br>
</span><span class="s3">        </span>默认情况，过期时间不用在历史机制中。若实体仍然在存，即使它过期<span class="s2"><br>
</span>历史机制仍可以显示它，除非用户明确提出要代理刷新过期纪录。<span class="s2"><br>
</span><span class="s3">           </span>这并不能解释为禁止历史体制告诉用户事情已经过时。</p>
<p class="p2"><span class="s3">      </span><span class="s2"><br>
</span><span class="s3">        </span>说明：如果历史纪录未必阻止用户看过时资源，这将强制服务提供者避免<span class="s2"><br>
</span>使用<span class="s3">HTTP</span>过期控制和缓存控制。</p>
<p class="p2"><span class="s3">                            </span>　<span class="s2"><br>
</span><span class="s3">14 </span>报头域定义<span class="s2"><br>
</span><span class="s3">  </span>本节定义了所有<span class="s3">HTTP/1.1</span>种标准头域的语法和语义。对于实体头域，发送者和接收者指的是客户端和服务器，它是由实体的发送和接收者来定义的。</p>
<p class="p1"><span class="s2"><br>
</span>14<span class="s1">．</span>1<span class="s1">接受（</span>Accept<span class="s1">）</span></p>
<p class="p2">接受请求报头区域可以同作详细说明特定对于响应来说可以接受的媒体形式<span class="s3">.</span>接<span class="s2"><br>
</span>受报头可以同作说明<span class="s3">,</span>请求对于一小组需要的形式来说是受限的<span class="s3">,</span>就像在为了内<span class="s2"><br>
</span>嵌图像的请求的情况下一样<span class="s3">.</span></p>
<p class="p1">  Accept         = "Accept" ":"<span class="s2"><br>
</span>                        #( media-range [ accept-params ] )</p>
<p class="p1">       media-range    = ( "*/*"<span class="s2"><br>
</span>                        | ( type "/" "*" )<span class="s2"><br>
</span>                        | ( type "/" subtype )<span class="s2"><br>
</span>                        ) *( ";" parameter )<span class="s2"><br>
</span>       accept-params  = ";" "q" "=" qvalue *( accept-extension )<span class="s2"><br>
</span>       accept-extension = ";" token [ "=" ( token | quoted-string ) ]</p>
<p class="p2">星号字符用作将媒体形式聚集成为一个范围<span class="s3">."*/*"</span>指出了所有的媒体形式<span class="s3">,"type/</span><span class="s2"><br>
</span><span class="s3">*"</span>指出了某种形式的图表类形<span class="s3">.</span>媒体范围可能包含适用于那个范围的媒体形式参数<span class="s3">.</span><span class="s2"><br>
</span>每个媒体范围可能跟随着一个或者多个接受<span class="s3">-</span>参数<span class="s3">.</span>开始为字母<span class="s3">"q"</span>的参数指出相关<span class="s2"><br>
</span>质量的因素<span class="s3">.</span>任何一个开头字母为<span class="s3">"q"</span>将媒体范围参量和接受参量区分开来<span class="s3">.</span>质量要<span class="s2"><br>
</span>因素允许用户或者是用户代理使用从零到一的值来指出对于此媒体形式来说喜欢<span class="s2"><br>
</span>的相关程度<span class="s3">,</span>缺省时<span class="s3">q</span>的值是<span class="s3">1.</span></p>
<p class="p2">注释<span class="s3">:q</span>参数名字可以用来将媒体形式从接受扩展参量中分辨出来<span class="s3">,</span>这是由于以前的<span class="s2"><br>
</span>练习<span class="s3">.</span>虽然这保护了任何任何首字母为<span class="s3">q</span>的参量被煤体范围一起使用<span class="s3">,</span>这样的事件被<span class="s2"><br>
</span>认为不太可能在<span class="s3">LANA</span>注册中被给与缺少的<span class="s3">"q"</span>参量或者在<span class="s3">Accept</span>中任何媒体形式的<span class="s2"><br>
</span>珍稀用法<span class="s3">.</span>未来的媒体形式从注册和<span class="s3">"q"</span>参量中气馁了<span class="s3">.</span><span class="s2"><br>
</span>例子<span class="s3">:</span><span class="s2"><br>
</span><span class="s3">Accept: audio/*; q=0.2, audio/basic</span><span class="s2"><br>
</span>该例应该被解释作<span class="s3">"</span>我喜欢<span class="s3">audio/basic,</span>但是如果在质量中<span class="s3">€</span>标记向下之后是最佳<span class="s2"><br>
</span>可利用的话<span class="s3">,</span>就给我发送任何音频形式<span class="s3">.</span>如果当前没有接受报头区域<span class="s3">,</span>那么可以认为<span class="s2"><br>
</span>是客户接受了所有的媒体形式<span class="s3">.</span>如果当前有　<span class="s3">Copyright  www.cnpaf.net (2007).          All Rights Reserved.</span><span class="s2"><br>
</span>接受报头区域并且如果服务器不能发送<span class="s2"><br>
</span>根据组合接受区域的值可以接受的响应的话<span class="s3">,</span>那么服务器应该发送一个<span class="s3">406</span>响应<span class="s3">.</span><span class="s2"><br>
</span>一个精心挑选的例子<span class="s2"><br>
</span><span class="s3">Accept: text/plain; q=0.5, text/html,</span><span class="s2"><br>
</span><span class="s3">        text/x-dvi; q=0.8, text/x-c</span><span class="s2"><br>
</span>口头上的<span class="s3">,</span>这个可以被解释作<span class="s3">"text/html</span>和<span class="s3">text/x-c</span>是首选的媒体形式<span class="s3">,</span>但是如果他<span class="s2"><br>
</span>们并不存在<span class="s3">,</span>那么给他们发送<span class="s3">text/x-dvi</span>实体<span class="s3">,</span>如果它不存在<span class="s3">,</span>则发送<span class="s3">text/plain</span>实<span class="s2"><br>
</span>体<span class="s3">."</span><span class="s2"><br>
</span>媒体范围可以不被更多特定媒体范围或者特定媒体形式考虑<span class="s3">.</span>如果多余一个的媒体<span class="s2"><br>
</span>范围适用于一个给出的形式的话<span class="s3">,</span>那么最最特定的参考优先<span class="s3">.</span>比如<span class="s3">"Accept: text</span><span class="s2"><br>
</span><span class="s3">/*, text/html, text/html;level=1, */*"</span>就有以下的优先<span class="s3">:</span><span class="s2"><br>
</span><span class="s3">1) text/html;leve=1</span><span class="s2"><br>
</span><span class="s3">2) text/html</span><span class="s2"><br>
</span><span class="s3">3) text/*</span><span class="s2"><br>
</span><span class="s3">4) */*</span></p>
<p class="p1"><span class="s1">和一个给出的形式相关联的媒体形式质量要素就是由寻找有和形式相匹配的的最</span><span class="s2"><br>
</span><span class="s1">最优先的媒体形式来决定的</span>,<span class="s1">比如</span>:<span class="s2"><br>
</span>Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,<span class="s2"><br>
</span>        text/html;level=2;q=0.4, */*;q=0.5<span class="s2"><br>
</span><span class="s1">会使以下的值有关联</span><span class="s2"><br>
</span>text/html;level=1         = 1<span class="s2"><br>
</span>text/html                 = 0.7<span class="s2"><br>
</span>text/plain                = 0.3<span class="s2"><br>
</span>image/jpeg                = 0.5<span class="s2"><br>
</span>text/html;level=2         = 0.4<span class="s2"><br>
</span>text/html;level=3         = 0.7</p>
<p class="p2">注释<span class="s3">:</span>一个用户代理可能会被提供一套默认的针对于特定媒体范围的值<span class="s3">.</span>然而<span class="s3">,</span>除非<span class="s2"><br>
</span>用户代理是个关闭的系统并且不可以和其他翻译代理相互作用<span class="s3">,</span>这套缺省可以由用<span class="s2"><br>
</span>户自己来配置<span class="s3">.</span></p>
<p class="p2"><span class="s3">14</span>．<span class="s3">2 </span>接受<span class="s3">-</span>字符集（<span class="s3">Accept-Charset</span>）<span class="s2"><br>
</span><span class="s3">   </span>接受<span class="s3">-</span>字符集请求报头区域可以用来指出什么特性装置可以为响应所接受<span class="s3">.</span>这个区域允许有能力理解更复杂或者是特定目的特性的装置的客户通知给在那些特性装置中有能力描述文档的服务器服务器是否具有上述所述的能力<span class="s3">.</span></p>
<p class="p1">Accept-Charset = "Accept-Charset" ":"<span class="s2"><br>
</span>              1#( ( charset | "*" )[ ";" "q" "=" qvalue ] )</p>
<p class="p2">特性装置的值在<span class="s3">3.4</span>章节中描述<span class="s3">.</span>每一个<span class="s3">??</span>可以分配一个表示用户对<span class="s3">??</span>喜爱程度的相关联质量的值<span class="s3">.</span>缺升值是<span class="s3">q=1.</span>一个例子是<span class="s3">:</span></p>
<p class="p1">Accept-Charset: iso-8859-5, unicode-1-1;q=0.8</p>
<p class="p2">特殊的值<span class="s3">"*",</span>如果在接受<span class="s3">-??</span>区域显示的话<span class="s3">,</span>则可以与每一个并没有在接受<span class="s3">??</span>中其他<span class="s2"><br>
</span>什么地方提起的特性装置相匹配<span class="s3">.</span>如果没有<span class="s3">'*'</span>在当前接受<span class="s3">-??</span>区域<span class="s3">,</span>那么所有没有明<span class="s2"><br>
</span>确提出的特性装置都回得到一个为零的质量值<span class="s3">,</span>除去在相同情况下可以得到<span class="s3">1</span>的<span class="s2"><br>
</span><span class="s3">iso-8859-1.</span>如果没有接受<span class="s3">-??</span>报头在当前<span class="s3">,</span>那么缺省设置就是任何特性装置都是可<span class="s2"><br>
</span>接受的<span class="s3">.</span>如果当前存在接受<span class="s3">-??</span>报头并且服务器不能发送根据接受<span class="s3">-??</span>报头可以接受<span class="s2"><br>
</span>的响应的话<span class="s3">,</span>那么服务器就会发送一个错误响应和<span class="s3">406</span>状态代码<span class="s3">,</span>在不可接受响应在<span class="s2"><br>
</span>发送过程中时也是允许的<span class="s3">,</span></p>
<p class="p1">14<span class="s1">．</span>3 <span class="s1">接收编码</span>(Accept-Encoding)<span class="s2"><br>
</span><span class="s1">接收编码</span>(Accept-Encoding)<span class="s1">请求报头域和接收</span>(Accept)<span class="s1">相似</span>,<span class="s1">但限定响应中可接收的内容码</span>(content-codings)(3.5<span class="s1">节</span>).<span class="s2"><br>
</span>        Accept-Encoding  = "Accept-Encoding" ":"<span class="s2"><br>
</span>                      1#( codings [ ";" "q" "=" qvalue ] )<span class="s2"><br>
</span>       codings          = ( content-coding | "*" )<span class="s2"><br>
</span>Examples of its use are:<span class="s2"><br>
</span>       Accept-Encoding: compress, gzip<span class="s2"><br>
</span>       Accept-Encoding:<span class="s2"><br>
</span>       Accept-Encoding: *<span class="s2"><br>
</span>       Accept-Encoding: compress;q=0.5, gzip;q=1.0<span class="s2"><br>
</span>       Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0<span class="s2"><br>
</span><span class="s1">根据接收编码</span>(Accept-Encoding)<span class="s1">域测试内容码</span>(content-coding)<span class="s1">是否可接受的服务器采用这些规则</span>:<span class="s2"><br>
</span><span class="s1">如果内容码</span>(content-coding)<span class="s1">是接收编码</span>(Accept-Encoding)<span class="s1">域中列出的一系列内容码</span>(content-codings)<span class="s1">中的一种</span>,<span class="s1">则它是可接受的</span>,<span class="s1">除非它跟着</span> a qvalue of 0.(<span class="s1">定义在</span>3.9<span class="s1">节</span>, a qvalue of 0.<span class="s1">意思是不可接受的</span>)<span class="s2"><br>
</span><span class="s1">接收编码</span>(Accept-Encoding)<span class="s1">域中的特殊符号</span>”*”<span class="s1">匹配任何报头域中没有明确列出的可利用的内容码</span>(content-coding).<span class="s2"><br>
</span><span class="s1">如果多种内容码</span>(content-codings)<span class="s1">是可接受的</span>,<span class="s1">则具有最高非零</span>qvalue<span class="s1">的内容码</span>(content-codings)<span class="s1">是优先的</span>.<span class="s2"><br>
</span>"identity"<span class="s1">内容码</span>(content-codings)<span class="s1">总是可接受的</span>,<span class="s1">除非特定的说明其是不可接受的</span>,<span class="s1">因为接收编码</span>(Accept-Encoding)<span class="s1">域包括</span>"identity;q=0"<span class="s1">或者因为域中包括</span>"*;q=0"<span class="s1">和不明确的包括</span>"identity"<span class="s1">内容编码</span>.<span class="s1">如果接收编码域的值为空</span>,<span class="s1">则只有</span>"identity"<span class="s1">编码是可接收的</span>.<span class="s2"><br>
</span><span class="s1">如果接收编码域出现在请求中</span>,<span class="s1">且根据接收编码报头服务器不能发送可接收的响应</span>,<span class="s1">则服务器应当发送带有</span>406(Not Acceptable)<span class="s1">状态码的出错响应</span>.</p>
<p class="p2">如果请求中没有接收编码域<span class="s3">,</span>服务器可以假定客户机将接收任意的内容编码<span class="s3">.</span>在这种情况下<span class="s3">,</span>如果<span class="s3">"identity"</span>是可利用的内容编码之一<span class="s3">,</span>则服务器应该采用<span class="s3">"identity"</span>内容编码<span class="s3">,</span>除非有额外的信息说明别的内容编码对客户机更有用<span class="s3">.</span></p>
<p class="p2"><span class="s3">  </span>注意<span class="s3">:</span>如果请求中没有包括接收编码域<span class="s3">,</span>且<span class="s3">"identity"</span>内容码是不可利用的<span class="s3">,</span>则能被<span class="s3">HTTP/1.0</span>客户机解读<span class="s3">(i.e."gzip" and "compress")</span>的内容码一般是优先的<span class="s3">.</span>当发送别的内容码是<span class="s3">,</span>一些老的客户机显示不正确的信息<span class="s3">.</span>服务器也许会以关于用户代理或客户机的信息为基础做出决定<span class="s3">.</span></p>
<p class="p1">  <span class="s1">注意</span>:<span class="s1">大多数</span>HTTP/1.0<span class="s1">应用程序不承认或遵守域内容码相关的</span>qvalues.<span class="s1">这意味着</span>qvalues<span class="s1">将不工作或被</span>x-gzip or x-compress<span class="s1">允许</span>.</p>
<p class="p1"><span class="s2"><br>
</span>14<span class="s1">．</span>4 <span class="s1">认可术语</span><span class="s2"><br>
</span>   The Accept-Language request-header field is similar to Accept, but<span class="s2"><br>
</span>   restricts the set of natural languages that are preferred as a<span class="s2"><br>
</span>   response to the request. Language tags are defined in section 3.10.<span class="s2"><br>
</span><span class="s1">认可术语请求报头区与认可是相近的，但规定了一套自然语言用来响应请求</span>.<span class="s1">术语</span><span class="s2"><br>
</span><span class="s1">标识在</span>3.10<span class="s1">节说明</span>.<span class="s2"><br>
</span>       Accept-Language = "Accept-Language" ":"<span class="s2"><br>
</span>                         1#( language-range [ ";" "q" "=" qvalue ] )<span class="s2"><br>
</span>       language-range  = ( ( 1*8ALPHA *( "-" 1*8ALPHA ) ) | "*" )<span class="s2"><br>
</span><span class="s1">每个语言范围均被赋以一个品质因数</span>,<span class="s1">它代表用户用这种语言的钟爱程度</span>.<span class="s1">品质因</span><span class="s2"><br>
</span><span class="s1">数默认值为一</span>.<span class="s1">例如</span>:<span class="s2"><br>
</span>   <span class="s2"><br>
</span>       <span class="s1">认可语言</span>: da, en-gb;q=0.8, en;q=0.7</p>
<p class="p2"><span class="s3">   </span>表示<span class="s3">:</span>我喜欢丹麦语<span class="s3">,</span>但也接受不列颠英语和其它种英语<span class="s3">.</span>一种语言范围对应一<span class="s2"><br>
</span>种术语标识如果它正好等于标识<span class="s3">,</span>或者如果它正好等于标识的前缀<span class="s3">,</span>例如第一个跟<span class="s2"><br>
</span>在前缀后面的标识符是<span class="s3">'-'.</span>特殊范围<span class="s3">"*",</span>如果在认可术语区中出现，对应所有标<span class="s2"><br>
</span>识符。</p>
<p class="p2">说明：使用前缀匹配规则并不表示如果用户理解一戴又标识的术语，他就也理解<span class="s2"><br>
</span>所有代前缀标识的术语。<span class="s2"><br>
</span><span class="s3">        </span>认可术语区指定给语言标识的语言品质因数是匹配标识的最大语言范围<span class="s2"><br>
</span>的品质数值。如果在此区内没有语言范围匹配此标识，则品质因数制定为<span class="s3">0</span>。如果<span class="s2"><br>
</span>请求中没有认可术语报头，服务器应假设所有语言被等同接受。如够出现了认可<span class="s2"><br>
</span>术语报头，则所有品质因数大于<span class="s3">0</span>的语言均是可接受的。</p>
<p class="p2"><span class="s3">        </span>在每个请求中发送认可术语报头说明可接受语言与保护用户隐私识背道而<span class="s2"><br>
</span>驰的，对此问题的专门讨论见<span class="s3">15.1.4</span><span class="s2"><br>
</span><span class="s3">        </span>鉴于可理解性高度依赖于个别用户<span class="s3">,</span>推荐客户应用用户理解的语言<span class="s3">.</span>如果<span class="s2"><br>
</span>选择用户不理解的<span class="s3">,</span>则请求中不能加入认可术语报头区<span class="s3">.</span><span class="s2"><br>
</span>说明<span class="s3">:</span>当选择用户可接受语言时<span class="s3">,</span>我们提醒实现者如下事实<span class="s3">,</span>用户并不熟悉术语匹<span class="s2"><br>
</span>配的细节<span class="s3">,</span>所以应给出适当提示<span class="s3">.</span></p>
<p class="p1"> </p>
<p class="p1"><span class="s2"><br>
</span>14<span class="s1">．</span>5<span class="s1">接收范围</span>(Accept-Range)<span class="s2"><br>
</span><span class="s1">接收范围</span>(Accept-Range)<span class="s1">响应报头域允许服务器给出对资源请求的接收范围</span>:<span class="s2"><br>
</span>           Accept-Ranges     = "Accept-Ranges" ":" acceptable-ranges<span class="s2"><br>
</span>          acceptable-ranges = 1#range-unit | "none"<span class="s2"><br>
</span><span class="s1">接收</span>byte-range<span class="s1">请求的源服务器可以发送</span><span class="s2"><br>
</span>           Accept-Ranges: bytes<span class="s2"><br>
</span><span class="s1">但没必要那样做</span>.<span class="s1">客户机可以产生</span>byte-range<span class="s1">请求</span>,<span class="s1">即使是它没有收到相关的报头域</span>.<span class="s2"><br>
</span>Range units<span class="s1">定义在</span>3.12<span class="s1">节</span>.</p>
<p class="p1"><span class="s1">不接收任何种类对资源的范围</span>(range)<span class="s1">请求的服务器可以发送</span><span class="s2"><br>
</span>            Accept-Ranges: none<span class="s2"><br>
</span><span class="s1">来建议客户机不要尝试范围</span>(range)<span class="s1">请求</span>.</p>
<p class="p1">14<span class="s1">．</span>6 <span class="s1">年龄（</span>Age<span class="s1">）</span><span class="s2"><br>
</span>Age<span class="s1">响应报头域表示发送者对传输时间的估计</span>,<span class="s1">既然响应是由源服务器产生的</span>.<span class="s1">假如缓存的响应没有超过它的寿命</span>,<span class="s1">则认为它是有活力的</span>(fresh).13.2.3<span class="s1">节说明了</span>Age<span class="s1">值的计算</span>.<span class="s2"><br>
</span>                 Age = "Age" ":" age-value<span class="s2"><br>
</span>                 age-value = delta-seconds<span class="s2"><br>
</span>Age<span class="s1">值是十进制非负整数</span>,<span class="s1">以秒为单位</span>.</p>
<p class="p2">如果高速缓存存储器收到一个大于它所能表示的上限整数的值<span class="s3">,</span>或它的<span class="s3">Age</span>计算溢出<span class="s3">,</span>它必须传送值为<span class="s3">2147483648 (2^31)</span>的<span class="s3">Age</span>报头域<span class="s3">. </span>带有高速缓存存储器的<span class="s3">HTTP/1.1</span>服务器产生的每一个响应<span class="s3">(</span>从它本身的高速缓存存储器中<span class="s3">)</span>都必须包括<span class="s3">Age</span>报头域<span class="s3">. </span>高速缓存存储器应当采用至少<span class="s3">31</span>位的算法<span class="s3">.</span></p>
<p class="p1"><span class="s2"><br>
</span>14<span class="s1">．</span>7 <span class="s1">允许（</span>Allow<span class="s1">）</span></p>
<p class="p2">允许<span class="s3"> (Allow)</span>实体报头域中列出了由　<span class="s3">Copyright  www.cnpaf.net (2007).          All Rights Reserved.</span><span class="s2"><br>
</span>请求指定资源支持的几种方法<span class="s3">--URI</span>。这一报头域的目的严格限于通知接收者与资源相联系的方法有哪些。允许报头域必须出现在<span class="s3">405</span>（方法不被允许）应答中。</p>
<p class="p1"><span class="s1">允许</span>="<span class="s1">允许</span>""<span class="s1">：</span>" #<span class="s1">方法</span></p>
<p class="p2">使用示例：</p>
<p class="p1">          <span class="s1">允许</span>: GET, HEAD, PUT</p>
<p class="p2">这一报头域不能阻止用户使用其他方法。然而允许域给出的指示应予以执行。由原服务器在处理每一请求时定义允许的方法集。<span class="s3"> </span><span class="s2"><br>
</span>允许域可由<span class="s3">PUT</span>请求提供，以建议新资源支持某些方法。服务器不必一定支持这些方法，且应在允许域中给出实际支持的方法。<span class="s2"><br>
</span>因为用户有其他与原服务器通信的渠道，故代理服务器即便不理解域中指明的所有方法，也不得修改允许报头域</p>
<p class="p1">14<span class="s1">．</span>8         <span class="s1">授权（</span>Authorization<span class="s1">）</span><span class="s2"><br>
</span><span class="s1">用户代理往往希望服务器自我验证</span>,<span class="s1">但在收到</span>401<span class="s1">响应后则没有必要了</span>.<span class="s1">用户代理通过包括</span>Authorization<span class="s1">请求报头域的请求那样做</span>. Authorization<span class="s1">请求报头域的值由包含用户代理验证信息的信任状所组成</span>,<span class="s1">这些用户代理处于请求资源的领域</span>.<span class="s2"><br>
</span>             Authorization  = "Authorization" ":" credentials<span class="s2"><br>
</span>HTTP Authentication<span class="s1">中描述了</span>HTTP<span class="s1">访问的身份鉴定</span>: Basic and Digest Access Authentication" [43].<span class="s1">假如请求在特定的领域中通过了验证</span>,<span class="s1">则同样的信任状对该领域内所有其它请求都是有效的</span>(<span class="s1">假定验证方案本身不需要</span>,<span class="s1">否则信任状依照亟待解决的问题或用同步时钟而不同</span>)</p>
<p class="p2">当共享的高速缓冲存储器<span class="s3">(</span>看<span class="s3">13.7</span>节<span class="s3">)</span>接收具有验证<span class="s3">(Authorization)</span>域的请求时<span class="s3">,</span>必须返回相应的响应作为其他请求的应答<span class="s3">,</span>除非是接下来的特殊情况之一<span class="s3">.</span><span class="s2"><br>
</span>如果响应包括<span class="s3">s-maxage</span>缓存控制指示信息<span class="s3">,</span>高速缓存可以用响应来应答并发的请求<span class="s3">.</span>但<span class="s3">(</span>如果已超过了特定的最大生存期<span class="s3">)</span>代理服务器的高速缓存首先必须重新生效<span class="s3">,</span>用来自新请求的请求报头允许源服务器验证新的请求<span class="s3">.(</span>这是为<span class="s3">s-maxage</span>定义的行为<span class="s3">.)</span>假如响应包括<span class="s3">"s-maxage=0",</span>代理服务器必须在重新利用之前使之生效<span class="s3">.</span></p>
<p class="p2">如果响应包括<span class="s3">must-revalidate</span>缓存控制指示信息<span class="s3">,</span>高速缓存可用响应来应答并发请求<span class="s3">.</span>但如果响应失去时效<span class="s3">,</span>所有缓存首先必须使它重新生效河源服务器一致<span class="s3">,</span>用来自新请求的请求报头允许源服务器验证新的请求<span class="s3">.</span></p>
<p class="p2">假如响应包括<span class="s3">public</span>缓存控制指示信息<span class="s3">,</span>它可以被返回来应答并发请求<span class="s3">.</span></p>
<p class="p1">14<span class="s1">．</span>9 <span class="s1">缓存</span>-<span class="s1">控制（</span>Cache-control<span class="s1">）</span></p>
<p class="p2">缓存<span class="s3">-</span>控制通用<span class="s3">-</span>报头域用于标明请求<span class="s3">/</span>应答链上所有缓存机制必须遵守的指令。这些指令规定了一些意在预防缓存对请求或应答造成不良影响的行为。它们通常覆盖了缺省的缓存算法。<span class="s3"> </span>缓存指令是单方向的，因为请求中指令的存在并不意味着应答中也会有同样的指令。</p>
<p class="p2">请注意<span class="s3">HTTP/1</span>。<span class="s3">0</span>缓存机可能并不实现缓存<span class="s3">-</span>控制，而是只实现<span class="s2"><br>
</span><span class="s3">Pragma:</span>无<span class="s3">-</span>缓存（参见<span class="s3">14</span>。<span class="s3">31</span>节）。</p>
<p class="p2">代理服务器或网关的应用程序必须不顾缓存指令对其本身的意义，毫无例外的让它们通过，因为这些指令可能对请求<span class="s3">/</span>应答链上的所有接收者都适用。</p>
<p class="p1"><span class="s1">缓存</span>-<span class="s1">控制</span>="<span class="s1">缓存</span>-<span class="s1">控制</span>""<span class="s1">：</span>" 1#<span class="s1">缓存</span>-<span class="s1">指令</span><span class="s2"><br>
</span><span class="s1">缓存</span>-<span class="s1">指令</span>="<span class="s1">缓存</span>-<span class="s1">请求</span>-<span class="s1">指令</span>|<span class="s1">缓存</span>-<span class="s1">应答</span>-<span class="s1">指令</span><span class="s2"><br>
</span><span class="s1">缓存</span>-<span class="s1">请求</span>-<span class="s1">指令</span>=<span class="s2"><br>
</span>           "<span class="s1">无</span>-<span class="s1">缓存</span>"                           ; 14.9.1<span class="s1">节</span><span class="s2"><br>
</span>         | "<span class="s1">无</span>-<span class="s1">存储</span>"                           ; 14.9.2<span class="s1">节</span>              <span class="s2"><br>
</span>         | "<span class="s1">最大</span>-<span class="s1">时限</span>""=" delta-<span class="s1">秒</span>                         ; 14.9.3, 14.9.4<span class="s1">节</span><span class="s2"><br>
</span>         | "<span class="s1">最大</span>-<span class="s1">陈旧</span>" ["="delta-<span class="s1">秒</span>]                       ; 14.9.3<span class="s1">节</span><span class="s2"><br>
</span>         | "<span class="s1">最小</span>-<span class="s1">保鲜</span>"["="] delta-<span class="s1">秒</span>                       ; 14.9.3<span class="s1">节</span><span class="s2"><br>
</span>         | "<span class="s1">不传输</span>"                            ; 14.9.5<span class="s1">节</span><span class="s2"><br>
</span>         | "<span class="s1">仅当缓存时</span>"                        ; 14.9.4<span class="s1">节</span><span class="s2"><br>
</span>         |   <span class="s1">缓存</span>-<span class="s1">扩展</span>                         ; 14.9.6<span class="s1">节</span></p>
<p class="p1"><span class="s1">缓存</span>-<span class="s1">应答</span>-<span class="s1">指令</span>=<span class="s2"><br>
</span>"<span class="s1">公共</span>" ;                                                                 14<span class="s1">。</span>9<span class="s1">。</span>1<span class="s1">节</span><span class="s2"><br>
</span>|"<span class="s1">私有</span>"["="&lt;"" 1#<span class="s1">域名〈</span>"<span class="s5">〉</span>];                               14<span class="s1">。</span>9<span class="s1">。</span>1<span class="s1">节</span>                                        |"<span class="s1">无缓存</span>" ["="&lt;"" 1#<span class="s1">域名〈</span>"<span class="s5">〉</span>]<span class="s1">；</span>                           14<span class="s1">。</span>9<span class="s1">。</span>1<span class="s1">节</span><span class="s2"><br>
</span>|"<span class="s1">不存储</span>"                                              14<span class="s1">。</span>9<span class="s1">。</span>2<span class="s1">节</span><span class="s2"><br>
</span>|"<span class="s1">不传输</span>"                                              14<span class="s1">。</span>9<span class="s1">。</span>5<span class="s1">节</span><span class="s2"><br>
</span>|"<span class="s1">必须经重新确定有效</span>"                                          14<span class="s1">。</span>9<span class="s1">。</span>4<span class="s1">节</span> <span class="s2"><br>
</span>|"<span class="s1">代理服务器重新确定有效</span>"                                      14<span class="s1">。</span>9<span class="s1">。</span>4<span class="s1">节</span><span class="s2"><br>
</span>|"<span class="s1">最大时限</span>""="delta-<span class="s1">秒</span>                                         14<span class="s1">。</span>9<span class="s1">。</span>3<span class="s1">节</span><span class="s2"><br>
</span>|"s-<span class="s1">最大时限</span>""="delta-<span class="s1">秒</span>                                       14<span class="s1">。</span>9<span class="s1">。</span>3<span class="s1">节</span><span class="s2"><br>
</span>|<span class="s1">缓存</span>-<span class="s1">扩展</span>                                                  14<span class="s1">。</span>9<span class="s1">。</span>6<span class="s1">节</span></p>
<p class="p2">当指令不伴有<span class="s3">1#</span>域名参数出现时，该指令适用于整个请求或应答。</p>
<p class="p2">当指令伴有<span class="s3">1#</span>域名参数出现时，它仅适用于被命名的域，而不适于请求或应答的其他部分。这一机制支持可扩展性；<span class="s3">HTTP<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>将来的版本可以通过将指令应用于<span class="s3">HTTP/1</span>。<span class="s3">1</span>中未定义的域来实现。</p>
<p class="p2">缓存<span class="s3">-</span>控制指令<span class="s3"> </span>可分为如下几类：</p>
<p class="p2"><span class="s3">-- </span>对可缓存的范围的限制；这可能只由原服务器指定。<span class="s2"><br>
</span><span class="s3">-- </span>对缓存内容的限制；这可由原服务器或用户代理指定。<span class="s2"><br>
</span><span class="s3">-- </span>对基本过期无效机制的改进；这可由原服务器或用户代理指定。<span class="s2"><br>
</span><span class="s3">-- </span>对缓存重新确认有效及重载的控制；这可能仅由用户代理指定。<span class="s2"><br>
</span><span class="s3">-- </span>对实体传输的控制<span class="s2"><br>
</span><span class="s3">-- </span>缓存系统的扩展。</p>
<p class="p2"><span class="s3">14</span>．<span class="s3">9</span>．<span class="s3">1 </span>何谓可缓存的</p>
<p class="p2">缺省情况下，若请求方法，请求报头域和应答状态指明了应答为可缓存的，则它就是可以缓存的。<span class="s3"> 13</span>。<span class="s3">4</span>节总结了这些可缓存性的缺省情况。<span class="s3"> </span>下列缓存<span class="s3">-</span>控制应答指令允许原服务器覆盖缺省的应答的可缓存性：</p>
<p class="p2">公共</p>
<p class="p2">指明应答可被任意高速缓存机缓存，即便在该应答通常是不可缓存的或只可由不共享的高速缓存机缓存的情况下也是如此。（参见<span class="s3">14</span>。<span class="s3">8</span>节，关于认证的附加详述）</p>
<p class="p2">私有</p>
<p class="p2">表明应答报文的所有部分都是为单一用户准备的且不得被共享缓存机缓存。</p>
<p class="p2">这使原服务器可以申明应答的特定部分是针对单一用户的，对其他用户的请求而言并非有效应答。<span class="s3"> </span>私有（不共享）缓存可以缓存应答。</p>
<p class="p2">注：私有一词仅用来控制应答在何处可被缓存，<span class="s3"> </span>而不能保证报文内容的私有性。</p>
<p class="p2">不缓存</p>
<p class="p2">若指令<span class="s3">"</span>不缓存<span class="s3">"</span>没有指定域名，则缓存机不得应答那些未经原服务器重新确认有效的后继的请求。</p>
<p class="p2">这使得原服务器即便对设置为回送陈旧应答给客户请求的高速缓存机也能防止缓存。</p>
<p class="p2">若指令<span class="s3">"</span>不缓存<span class="s3">"</span>确实指定了一个或多个域名，则高速缓存机可以在其他的缓存要求限制下应答后继请求。<span class="s3"> </span>然而，指定的域名不得在用于应答那些未经原服务器重新确认有效的后继请求。这使得原服务器防止了应答中某些报头域重复使用，同时又允许缓存应答的剩余部分。</p>
<p class="p2">注：大多数<span class="s3">HTTP/1</span>。<span class="s3">0</span>高速缓存机不会认出或遵守这一指令。</p>
<p class="p2"><span class="s3">14</span>．<span class="s3">9</span>．<span class="s3">2 </span>哪些可被高速缓存机保存</p>
<p class="p2">不保存</p>
<p class="p2"><span class="s3">"</span>不保存<span class="s3">"</span>指令的目的在于防止无意中泄露或滞留了敏感信息（比如存在备用磁带上了）。</p>
<p class="p2"><span class="s3">"</span>不保存<span class="s3">"</span>指令适用于整个报文，可在请求或　<span class="s3">Copyright  www.cnpaf.net (2007).          All Rights Reserved.</span><span class="s2"><br>
</span>应答中发送。<span class="s3"> </span>若由请求方发送，则高速缓存机不得保存该请求或其应答的任何部分。若由应答方发送，高速缓存机不得保存该应答和相应请求的任何部分。该指令对非共享与共享高速缓存机都适用。<span class="s3"> "</span>不得保存<span class="s3">"</span>在这里意味着缓存机不得有意地将信息保存在非易逝存储器上，且必须尽最大努力将信息在转发后尽快从易逝存储器上转移。</p>
<p class="p2">即使这一指令是与应答相联系的，用户也可能明言要在缓存系统之外保存该应答（比如通过<span class="s3">"</span>另存为<span class="s3">"</span>对话框）。<span class="s3"> </span>历史缓存区可作为例行公事保存这些应答。</p>
<p class="p2">这一指令地目的在于满足某些在意信息经未知渠道偶然泄漏到缓存数据区的用户与服务程序作者提出的要求。虽然这一指令的使用可能改善了保密性，但值得提醒的是，它又绝非保证保密性的充分的或可靠的机制。</p>
<p class="p2"><span class="s3">14</span>．<span class="s3">9</span>．<span class="s3">3 </span>对基本过期失效机制的改进</p>
<p class="p2">实体的过期时间可由原服务器的<span class="s3">"</span>过期<span class="s3">"</span>报头（参见<span class="s3">14</span>。<span class="s3">21</span>节）指定。<span class="s3"> </span>或者，它也可由应答中的<span class="s3">"</span>最大<span class="s3">-</span>年龄<span class="s3">"</span>指令说明。当被缓存的应答含有<span class="s3">"</span>最大<span class="s3">-</span>年龄<span class="s3">"</span>缓存<span class="s3">-</span>控制指令时，应答若现有年龄大于出现对同一资源的新请求中所给年龄值（以秒为单位）则被视为陈旧。应答中的<span class="s3">"</span>最大<span class="s3">-</span>年龄<span class="s3">"</span>指令意味着该应答是可缓存的（如，<span class="s3">"</span>公共<span class="s3">"</span>），除非存在其他更严格的缓存指令。</p>
<p class="p2">若应答同时含有过期报头与<span class="s3">"</span>最大<span class="s3">-</span>年龄<span class="s3">"</span>指令，最大<span class="s3">-</span>年龄指令覆盖过期报头，即便过期报头中的描述更严格也不例外。这一规则使原服务器可就给定应答为<span class="s3">HTTP/1</span>。<span class="s3">1</span>（或更新的版本）缓存机提供比<span class="s3">HTTP/1</span>。<span class="s3">0</span>缓存机更长的过期时间。这在某一<span class="s3">HTTP/1</span>。<span class="s3">0</span>缓存机出于诸如类似同步时钟的原因错算了年龄或过期时间的情况下可能有用。</p>
<p class="p2">许多<span class="s3">HTTP/1</span>。<span class="s3">0</span>缓存机会按照与缓存<span class="s3">-</span>控制应答指令<span class="s3">"</span>不缓存<span class="s3">"</span>等价的方式来处理小于或等于应答日期值的过期值。若<span class="s3">HTTP/1</span>。<span class="s3">1</span>缓存机接到这种应答，且应答不含缓存<span class="s3">-</span>控制报头域，则它应视应答为不可缓存，从而保持与<span class="s3">HTTP/1</span>。<span class="s3">0</span>服务器的兼容性。</p>
<p class="p2">注：在兼有不懂新特性的旧版缓存机的网络上，一台原服务器可能愿意采用较新的<span class="s3">HTTP</span>缓存控制功能，如<span class="s3">"</span>私有<span class="s3">"</span>指令。这样，原服务器就需要将新特性与其值小于等于日期值的过期报头域结合起来。这将防止旧版缓存机误缓存应答。</p>
<p class="p2"><span class="s3">s-</span>最大年龄</p>
<p class="p2">若应答包含<span class="s3">s-</span>最大年龄指令，则对共享缓存机（而非私有缓存机）而言，由该指令指定的最大年龄覆盖其他最大年龄指令或过期报头的指定。<span class="s3"> S-</span>最大年龄指令也暗示了代理服务器<span class="s3">-</span>重新确定有效指令的句法（参见<span class="s3">14</span>。<span class="s3">9</span>。<span class="s3">4</span>节），也就是说，在首先经原服务器重新确认为有效之前，共享缓存机不得用那些变得陈旧了的目录来应答后继请求。<span class="s3"> </span>私有高速缓存机忽略此<span class="s3">s-</span>最大年龄指令。</p>
<p class="p2">请注意，大多数与此规范不相适的旧版缓存机并不执行任何缓存<span class="s3">-</span>控制指令。<span class="s3"> </span>想要使用缓存<span class="s3">-</span>控制指令来限制而非避免遵守<span class="s3">HTTP/1</span>。<span class="s3">1</span>的缓存机进行缓存得原服务器可以利用最大<span class="s3">-</span>年龄指令覆盖过期报头的条件以及早于<span class="s3">HTTP/1</span>。<span class="s3">1</span>的缓存机不检查最大<span class="s3">-</span>年龄指令这一事实。</p>
<p class="p2">其他指令允许用户代理修改基本过期失效机制。<span class="s3"> </span>这些指令可由请求指定：</p>
<p class="p2">最大<span class="s3">-</span>年龄</p>
<p class="p2">表明客户机愿接受其年龄不大于指定时间（以秒计算）的应答。除非也含<span class="s3">"</span>最大<span class="s3">-</span>陈旧<span class="s3">"</span>指令，否则客户机不愿接受陈旧应答。</p>
<p class="p2">最小<span class="s3">-</span>保鲜</p>
<p class="p2">表明客户机愿接受其保鲜寿命不小于现有年龄与指定时间之和（以秒计算）的应答。也就是说，客户机想要一至少在一定时间内保持保鲜的应答。</p>
<p class="p2">最大<span class="s3">-</span>陈旧</p>
<p class="p2">表明客户机愿接受已经过期的应答。<span class="s3"> </span>若指定最大<span class="s3">-</span>陈旧为某值，则客户机愿接受过期时间不超过给定秒数的应答。若未指定最大<span class="s3">-</span>陈旧的值，则客户机愿接受任意年龄的陈旧应答。</p>
<p class="p2">若缓存机或出于请求的最大<span class="s3">-</span>陈旧指令，或出于缓存机被设置为覆盖应答过期时间的原因，最终返回了一个陈旧的应答，缓存机都必须在旧应答上添加一警告报头，采用警告<span class="s3">110</span>（应答是陈旧的）。</p>
<p class="p2">高速缓存机可被设置成不经确认就返回陈旧应答，但这不应与任何<span class="s3">"</span>必须<span class="s3">"</span>等级的关于缓存重确认的要求（如<span class="s3">"</span>必须<span class="s3">-</span>重新确认有效<span class="s3">"</span>缓存<span class="s3">-</span>控制指令）冲突。</p>
<p class="p2">若新请求与缓存的条目均包括<span class="s3">"</span>最大<span class="s3">-</span>年龄<span class="s3">"</span>指令，则取两者间较小值来决定该请求的缓存条目的保鲜程度。</p>
<p class="p2"><span class="s2"><br>
</span><span class="s3">14</span>．<span class="s3">9</span>．<span class="s3">4  </span>缓存重新确认有效和重载控制</p>
<p class="p2">有时用户代理可能希望或出于需要坚持让　<span class="s3">Copyright  www.cnpaf.net (2007).          All Rights Reserved.</span><span class="s2"><br>
</span>缓存机与原服务器之间重新确认缓存条目的有效性（而不只是通向原服务器的传输路径中的下一高速缓存机），或是从原服务器处重载缓存条目。端到端的重新确认有效手续在缓存机或原服务器高估了缓存应答的过期时间时可能需要。端到端重载在缓存条目由于某些原因被侵蚀时可能需要。</p>
<p class="p2">如果客户机没有自己的本地缓存拷贝，即所谓<span class="s3">"</span>未指明的端到端重新确认有效<span class="s3">"</span>，或客户机没有本地的缓存拷贝，即所谓<span class="s3">"</span>经指明的端到端重新确认有效<span class="s3">"</span>，<span class="s3"> </span>都有可能要求端到端的重新确认有效。</p>
<p class="p2">客户机可用缓存<span class="s3">-</span>控制请求指令来指明三种行动中的一种：</p>
<p class="p2">端到端重载</p>
<p class="p2">请求包括<span class="s3">"</span>不缓存<span class="s3">"</span>缓存<span class="s3">-</span>控制指令，或是与<span class="s3">HTTP/1</span>。<span class="s3">0</span>客户机兼容的<span class="s3">"Pragma:</span>不缓存<span class="s3">"</span>。</p>
<p class="p2">请求的<span class="s3">"</span>不缓存<span class="s3">"</span>指令中不得含有域名。服务器应答这种请求时不得使用缓存的拷贝。</p>
<p class="p2">经指明的端到端重新确认有效</p>
<p class="p2">请求包括<span class="s3">"</span>最大<span class="s3">-</span>年龄<span class="s3">=0"</span>缓存<span class="s3">-</span>控制指令，从而迫使通向原服务器路径上的每一高速缓存机都与下一缓存机或服务器之间重新确认自身条目的有效性。初始请求包括由客户机现有的确认模块决定的缓存有效性确认过程。</p>
<p class="p2">未指明的端到端重新确认有效</p>
<p class="p2">请求包括<span class="s3">"</span>最大<span class="s3">-</span>年龄<span class="s3">=0"</span>缓存<span class="s3">-</span>控制指令，从而迫使通向原服务器路径上的每一高速缓存机都与下一缓存机或服务器之间重新确认自身条目的有效性。初始请求中不包括缓存条件有效性确认过程。沿途第一个含有此资源缓存条目缓存机（如果存在的话）包括决定于现有的有效性确认模块的缓存<span class="s3">-</span>有效性确认。</p>
<p class="p2">最大<span class="s3">-</span>年龄</p>
<p class="p2">当中转缓存机被<span class="s3">"</span>最大<span class="s3">-</span>年龄<span class="s3">=0"</span>的指令迫使重新确认其缓存条目有效性，且客户机在请求中提供了自己的有效性确认器时，所供的有效性确认器可能不同于缓存条目中现存的有效性确认模块。在这一情况下，缓存机可以在不影响句法透明性的前提下将其中的任一有效性确认模块用于自己的请求。<span class="s2"><br>
</span>然而，对有效性确认器的选择可能影响性能。<span class="s3"> </span>最好的方法是让中转缓存机采用自己的有效性确认模块来构造请求。若服务器应答以<span class="s3">304</span>（未经修改），则缓存机可以将自己的确认后拷　<span class="s3">Copyright  www.cnpaf.net (2007).          All Rights Reserved.</span><span class="s2"><br>
</span>贝连同<span class="s3">200</span>（<span class="s3">OK</span>）应答一起发回给客户机。但若服务器发回新的实体和有效性确认器，则中转缓存机可使用强比较函数比较返回的有效性确认器与客户机请求中提供的有效性确认器。若客户机的有效性确认器与原服务器的一致，则中转缓存机仅需发送回<span class="s3">304</span>（未经修改）。<span class="s3"> </span>否则，它就发回新的实体和<span class="s3">200</span>（<span class="s3">OK</span>）应答。<span class="s2"><br>
</span>若请求含有<span class="s3">"</span>不缓存<span class="s3">"</span>指令，则它不得包括最小<span class="s3">-</span>保鲜，最大<span class="s3">-</span>陈旧或最大<span class="s3">-</span>年龄指令。</p>
<p class="p2">仅当经缓存时</p>
<p class="p2">在某些情况下，如网络连接极为糟糕时，客户机可能想要缓存机只返回它现存的应答，而不要与原服务器之间进行重载或重新确认有效性。为实现这一点，客户机可以在请求中包括<span class="s3">"</span>仅当经缓存时<span class="s3">"</span>指令。若它收到这一指令，缓存机应该应答以符合请求其他限制的缓存条目，或是应答以<span class="s3">504</span>（网关超时）状态。<span class="s3"> </span>然而，当一组缓存机是作为呢部内部联系良好的同一系统来操作的话，这样的请求可能会在那组缓存机内部转发。</p>
<p class="p2">必须<span class="s3">-</span>重新确认有效性</p>
<p class="p2">由于缓存机可能被设置为忽略服务器指定的过期时间，且客户机请求可能包括最大<span class="s3">-</span>陈旧指令（与前者效用相似），<a href="http://www.cnpaf.net/">协议</a>还包括了一种由原服务器要求后继使用中重新确认缓存条目有效性的机制。</p>
<p class="p2">当缓存机接到的应答中有必须<span class="s3">-</span>重新确认有效性指令时，<span class="s3"> </span>该缓存机不得在条目变得陈旧后不经与原服务器重新确认有效性就用来应答后继请求。（也就是说，<span class="s3"> </span>若仅由原服务器的<span class="s3">"</span>过期<span class="s3">"</span>报头或<span class="s3">"</span>最大<span class="s3">-</span>年龄<span class="s3">"</span>取值确定缓存的应答已陈旧，缓存机就每次都必须执行端到端有效性重新确认。）</p>
<p class="p2"><span class="s3">"</span>必须重新确认有效性<span class="s3">"</span>指令对支持某些<a href="http://www.cnpaf.net/">协议</a>特性可靠运作是必要的。在所有情况下，<span class="s3">HTTP/1</span>。<span class="s3">1</span>缓存机必须遵守<span class="s3">"</span>必须重新确认有效性<span class="s3">"</span>指令；特别是，若缓存机出于任何原因无法到达原服务器，则它必须产生<span class="s3">504</span>（网关超时）应答。</p>
<p class="p2">当且仅当对实体的请求的有效性重确认的失败会导致错误的操作（比如未申明但未被执行的最终事务）时，服务器应该发送<span class="s3">"</span>必须重新确认有效性<span class="s3">"</span>指令。<span class="s3"> </span>接收者不得采取任何违背该指令的自动行动，也不得在重确认失败时自动提供未经确认的实体拷贝。</p>
<p class="p2">虽不提倡如此，但受到严格的连接限制的用户代理还是可以违背这一指令，但在这么做的同时必须明确警告用户提供的是未经有效性确认的应答。每一未确认的访问都必须伴有警告，且应要求明确的用户许可。</p>
<p class="p2">代理服务器<span class="s3">-</span>重新确认有效性</p>
<p class="p2">除了不适于非共享用户代理缓存机之外，<span class="s3"> "</span>代理服务器<span class="s3">-</span>重新确认有效性<span class="s3">"</span>指令与<span class="s3">"</span>必须重新确认有效性<span class="s3">"</span>指令含义相同。<span class="s3"> </span>它可用于对经认证的请求的应答，以允许用户的缓存机保存应答，并在稍后无须重新确认就返回应答（因为它已经被该用户认证了），同时仍然要求服务于多个用户的代理每次都重新确认有效性（从而确保每一用户都通过认证）。<span class="s3"> </span>请注意这种经认证的应答还需要<span class="s3">"</span>公共<span class="s3">"</span>缓存<span class="s3">-</span>控制指令，使得它们可以被缓存。</p>
<p class="p2"><span class="s2"><br>
</span><span class="s3">14</span>．<span class="s3">9</span>．<span class="s3">5 </span>不得转换指令<span class="s2"><br>
</span>不得转换</p>
<p class="p2">中转缓存机（代理服务器）的实现者们发现转换某些实体正文的媒体类型是很有用的。<span class="s3"> </span>比如，一台非透明的代理服务器可以在图象格式之间进行转换，以节省缓存空间或减少慢速链路上的数据通信量。</p>
<p class="p2">然而，当这些转换应用于某些应用的实体正文时，会引发严重的操作方面的问题。比如，医学图象应用，科学数据<a href="http://www.cnpaf.net/">分析</a>和端到端认证都依赖于接收到与原实体正文一比特都不差的实体正文。</p>
<p class="p2">所以，如果报文包括了<span class="s3">"</span>不得转换<span class="s3">"</span>指令，<span class="s3"> </span>中转缓存机或代理服务器就不得改变<span class="s3">13</span>。<span class="s3">5</span>。<span class="s3">2</span>节中列出的受<span class="s3">"</span>不得转换<span class="s3">"</span>指令影响的报头。这意味着缓存机或代理服务器不得改变由这些报头定义的实体正文的任何方面，包括实体正文值本身。</p>
<p class="p2"><span class="s3">14</span>．<span class="s3">9</span>．<span class="s3">6 </span>缓存控制扩展</p>
<p class="p2">缓存<span class="s3">-</span>控制报头域可通过一个或多个缓存<span class="s3">-</span>扩展标志的使用来实现扩展。其中每一标志都赋予一可选的值。<span class="s3"> </span>信息性的扩展（那些无须改变缓存机行为的）可以不经改变其他指令的句法而添加。</p>
<p class="p2">行为性扩展被设计为现有基本缓存指令的修正。<span class="s3"> </span>新指令与标准指令都有提供，于是不理解新指令的应用程序会缺省地按采用标准指令规定的行为，而理解新指令的应用程序则将其认作标准指令提出的要求的修正。这样，缓存<span class="s3">-</span>控制指令可以无须改变基本<a href="http://www.cnpaf.net/">协议</a>就得到扩展。</p>
<p class="p2">这一扩展机制依赖于<span class="s3">HTTP</span>缓存机对所有初始<span class="s3">HTTP</span>版本中缓存<span class="s3">-</span>控制指令和某些扩展方式的遵守，以及对所有它不理解的指令的忽略。</p>
<p class="p2">例如，考虑一个假想中的名为<span class="s3">"</span>共同体<span class="s3">"</span>的新应答指令，作为<span class="s3">"</span>私有<span class="s3">"</span>这里指令的修正。我们定义这个新的指令以表明除了非共享缓存机之外，任何只可被同一共同体成员共享的缓存机都可以缓存此应答。原服务器若想允许<span class="s3">UCI</span>共同体在它们的共享缓存机之间使用本来是私有的应答，只需在该应答中添入：</p>
<p class="p2">缓存<span class="s3">-</span>控制：私有，<span class="s3"> </span>共同体<span class="s3">="UCI"</span></p>
<p class="p2">见到这一报头域的缓存机即便不理解<span class="s3">"</span>共同体<span class="s3">"</span>缓存<span class="s3">-</span>扩展也能正确操作，因为它还见到并理解<span class="s3">"</span>私有<span class="s3">"</span>指令，就会按缺省的<a href="http://www.cnpaf.net/class/security/">安全</a>方式行事。</p>
<p class="p2">未经认出的缓存<span class="s3">-</span>指令必须被忽略；按照假定，任何可能未被<span class="s3">HTTP/1</span>。<span class="s3">1</span>高速缓存机认出的缓存<span class="s3">-</span>指令都与标准指令（或应答的缺省可缓存性）相结合使用，从而是缓存机的行为即便在它不理解扩展指令时也尽可能保持正确。</p>
<p class="p1">14<span class="s1">．</span>10 <span class="s1">连接</span></p>
<p class="p2">连接这一概括报头域允许发送者指定某一特定连接中的选项设置，且不得由代理服务器在以后的连接中传送。</p>
<p class="p2">连接报头遵循如下语法：</p>
<p class="p2">连接<span class="s3">="</span>连接<span class="s3">""</span>：<span class="s3">" 1#</span>（连接<span class="s3">-</span>标志）<span class="s2"><br>
</span>连接<span class="s3">-</span>标志<span class="s3">=</span>标志</p>
<p class="p2"><span class="s3">HTTP/1</span>。<span class="s3">1</span>代理服务器必须在转发报文之前即解析连接报头域，针对域中每一连接<span class="s3">-</span>标志，从报文中移开所有与连接<span class="s3">-</span>标志同名的报头域。<span class="s3"> </span>连接选项是由连接报头域中的连接<span class="s3">-</span>标志指明的，而非任何附加的报头域，因为这些附加报头在缺少与连接选项相关的参数时无法被传送。</p>
<p class="p2">连接报头中列出的报文报头不得含有诸如缓存<span class="s3">-</span>控制之类的端到端报头。</p>
<p class="p2"><span class="s3">HTTP/1</span>。<span class="s3">1</span>定义了<span class="s3">"close"</span>选项，以供发送者宣布连接在完成应答后将被关闭。例如</p>
<p class="p1"><span class="s1">连接：</span>close</p>
<p class="p2">无论是出现在请求或应答的报头域中，都表明连接不应被视为在完成现有请求<span class="s3">/</span>应答后是<span class="s3">"</span>持续的<span class="s3">"</span>（参见<span class="s3">8</span>。<span class="s3">1</span>节）。</p>
<p class="p2">不支持持续连接的<span class="s3">HTTP/1</span>。<span class="s3">1</span>应用程序必须在每一报文中都添上<span class="s3">"close"</span>连接选项。</p>
<p class="p2">接收到含有连接报头的<span class="s3">HTTP/1</span>。<span class="s3">0</span>（或更低版本）报文的系统必须为每一连接<span class="s3">-</span>标志都去除或忽略报文中与之同名的报头域。这样做避免了早于<span class="s3">HTTP/1</span>。<span class="s3">1</span>版本的代理服务器误转发这些报头域。</p>
<p class="p1">14<span class="s1">．</span>11 <span class="s1">内容编码</span></p>
<p class="p2"><span class="s3">"</span>内容编码<span class="s3">"</span>实体报头域是作为媒体类型的修正。此域存在时，其值表明对实体正文采用了何种附加的内容编码，从而须采用何种解码机制以获取<span class="s3">"</span>内容类型<span class="s3">"</span>报头域中指出的媒体类型。<span class="s3">"</span>内容编码<span class="s3">"</span>的主要目的是使文件可以在不丧失其基本媒体类型身份的同时被压缩。</p>
<p class="p2">内容编码<span class="s3">="</span>内容编码<span class="s3">" "</span>：<span class="s3">" 1#</span>内容译码</p>
<p class="p2">内容译码由<span class="s3">3</span>。<span class="s3">5</span>节定义。其应用示例为：</p>
<p class="p2">内容编码：<span class="s3">gzip</span></p>
<p class="p2">内容译码是由请求定义（<span class="s3">URI</span>）的实体特性。通常，实体正文以编码方式存储，只在翻译或类似使用前才解码。然而，非透明代理服务器在确知新译码可被接受者认可的情况下可能会改变内容译码，除非报文中含有<span class="s3">"</span>不得转换<span class="s3">"</span>的缓存控制谓词。</p>
<p class="p2">若实体的内容译码不具备同一性，则应答必须包含列有所用非同一内容译码的内容编码实体报头（<span class="s3">14</span>。<span class="s3">11</span>节）。</p>
<p class="p2">若请求报文中的实体内容编码对原服务器而言不可接受，则服务器应以<span class="s3">415</span>（不被支持的媒体类型）状态码应答。</p>
<p class="p2">若实体采用多种编码，则内容译码应按它们的使用顺序列出。</p>
<p class="p2">关于编码参数的其他信息和由未被此说明定义的实体报头域给出。</p>
<p class="p1">14<span class="s1">．</span>12 <span class="s1">内容语言</span></p>
<p class="p2">内容语言实体报头域描述了实体面向的受众的使用语言。请注意，这不一定等同于实体正文中用到的所有语言。</p>
<p class="p2">实体语言<span class="s3">="</span>实体语言<span class="s3">""</span>：<span class="s3">"1#</span>语言标记</p>
<p class="p2">语言标记由<span class="s3">3</span>。<span class="s3">10</span>节定义。内容语言的主要目的在于让用户根据自己喜用的语言确认并区别众实体。由是，若正文内容只是针对懂荷兰语的人的话，相应的域应为：</p>
<p class="p2">内容语言：<span class="s3">da</span></p>
<p class="p2">若未指明内容语言，缺省值为内容针对所有语种的受众。这既可能指发送者认为内容与任意自然语言无关，也可能指发送者不知此内容应面向何种语言。</p>
<p class="p2">要面向多种听众，可列出多种语言。例如，同时用毛里土语和英语发行的<span class="s3">"Waitangi</span>之约<span class="s3">"</span>就可以用：</p>
<p class="p1"><span class="s1">内容语言：</span>mi,en</p>
<p class="p2">然而，实体中有多个语种并不代表它一定是为多语种的观众准备的。比如<span class="s3">"</span>初学拉丁文<span class="s3">"</span>之类的语言启蒙教程，显然是针对英语观众的。这里，恰当的<span class="s3">"</span>内容语言<span class="s3">"</span>应只包括<span class="s3">"en"</span>。</p>
<p class="p2">内容语言可用于任意媒体类型<span class="s3"> -- </span>它不限于文本式文件。</p>
<p class="p1">14<span class="s1">．</span>13 <span class="s1">内容长度</span></p>
<p class="p2">内容长度实体报头域按十进制或八位字节数指明了发给接收者的实体正文的大小，或是在使用<span class="s3">HEAD</span>方法的情况下，指明若请求为<span class="s3">GET</span>时将发送实体正文的大小。</p>
<p class="p1"><span class="s1">内容长度</span>="<span class="s1">内容长度</span>""<span class="s1">：</span>"1*DIGIT</p>
<p class="p2">示例：</p>
<p class="p2">内容长度：<span class="s3">3495</span></p>
<p class="p2">除非按<span class="s3">4</span>。<span class="s3">4</span>节的规则被禁用，应用程序应使用此域指明报文正文的传输长度。</p>
<p class="p2">任何不小于零的内容长度均为有效值。<span class="s3"> 4</span>。<span class="s3">4</span>节描述了如何在未知内容长度时测定报文长度的方法。</p>
<p class="p2">请注意此域的含义域<span class="s3">MIME</span>中的相应定义迥异。<span class="s3">MIME</span>中，它是<span class="s3">"</span>报文<span class="s3">/</span>扩展正文<span class="s3">"</span>内容类型的可选域；在<span class="s3">HTTP</span>中，除非按<span class="s3">4</span>。<span class="s3">4</span>节的规则被禁用，一旦报文长度在传送前被确定，就应发送此域。</p>
<p class="p1">14<span class="s1">．</span>14 <span class="s1">内容位置</span></p>
<p class="p2">内容位置可用来在从一独立于请求资源的<span class="s3">URI</span>的位置访问实体时提供报文中实体的资源位置。服务器应根据应答实体为此变量提供一内容位置；尤其是在资源和多个实体相联系，而这些实体各享独立位置，可被分别访问时，服务器应为特定的返回变量提供内容位置。</p>
<p class="p2">内容位置<span class="s3">="</span>内容位置<span class="s3">""</span>：<span class="s3">"</span>（绝对<span class="s3">URI|</span>相对<span class="s3">URI</span>）</p>
<p class="p2">内容位置的值也决定了实体的基础<span class="s3">URI</span>。</p>
<p class="p2">内容位置值并非原请求<span class="s3">URI</span>的替代；它只是申明了请求中对应特定实体的资源位置。</p>
<p class="p2">此后的请求若想确定特定实体的来源，可以指定内容位置<span class="s3">URI</span>为请求的<span class="s3">URI</span>。</p>
<p class="p2">缓冲存储机不能以为若实体的内容位置<span class="s3">URI</span>异于访问<span class="s3">URI</span>就可用此实体来应答那一内容位置<span class="s3">URI</span>下的后续请求。但如<span class="s3">13</span>。<span class="s3">6</span>节所述，内容位置可用于区分从同一请求资源得到的多个实体。</p>
<p class="p2">若内容位置是相对<span class="s3">URI</span>，则此相对<span class="s3">URI</span>是相对于请求<span class="s3">URI</span>来解释的。</p>
<p class="p2"><span class="s3">PUT</span>或<span class="s3">POST</span>请求中内容位置报头的含义未定；服务器可自由忽略。</p>
<p class="p1">14<span class="s1">．</span>15 <span class="s1">内容</span>-MD5</p>
<p class="p2">如<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 1864[23]</span>中所定义的，内容<span class="s3">-MD5</span>实体报头域是实体正文的<span class="s3">MD5</span>摘要，以期提供端到端的实体正文的报文完整性检验（<span class="s3">MIC</span>）。（注：<span class="s3">MIC</span>有利于检测实体正文传送中的偶发改动，但不一定能防范恶意袭击。）</p>
<p class="p1"><span class="s1">内容</span>-MD5="<span class="s1">内容</span>-MD5""<span class="s1">：</span>" MD5-<span class="s1">摘要</span><span class="s2"><br>
</span>MD5-<span class="s1">摘要</span>=&lt; <span class="s1">由<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a></span> 1864 <span class="s1">定义的的</span> <span class="s1">基</span>64<span class="s1">的</span>128<span class="s1">比特</span>MD5<span class="s1">摘要</span>&gt;</p>
<p class="p2">内容<span class="s3">-MD5</span>报头域可由原服务器或客户机生成，用作实体正文的完整性检验。只有原服务器或客户机可生成内容<span class="s3">-MD5</span>报头域；不得由代理服务器和网关生成，否则会有悖于其作为端到端完整性检验的价值。任何实体正文的接收者，包括代理服务器和网关，都可检查此域中摘要值与实体正文是否相符。</p>
<p class="p2"><span class="s3">MD5</span>摘要的计算基于实体正文的内容，包括任何所用的内容译码，但不包括任何对报文正文进行的传输编码。若接到的报文有传输编码，则必须在核对内容<span class="s3">-MD5</span>与所收正文之前解除编码。</p>
<p class="p2">这样造成的后果是：摘要完全按照它们若未经传输编码而被发出的顺序进行逐字节计算。</p>
<p class="p1">HTTP <span class="s1">将<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a></span> 1864<span class="s1">拓宽到允许对</span>MIME<span class="s1">组成的媒体类型（如</span>multipart/*,message/rfc822<span class="s1">）计算摘要，但这并不改变如前所述的摘要计算方法。</span></p>
<p class="p2">由此产生了一系列影响。组件类型的实体正文可能会包括多个正文部分，每一部分都有自己的<span class="s3">MIME</span>和<span class="s3">HTTP</span>报头（包括内容<span class="s3">-MD5,</span>内容<span class="s3">-</span>传输<span class="s3">-</span>编码，和内容编码报头）。如果正文部分有内容<span class="s3">-</span>传输<span class="s3">-</span>编码或内容编码报头，则被假定为正文部分的内容已经过编码处理，且正文部分依样包括在内容<span class="s3">-MD5</span>摘要中。<span class="s3"> </span>正文部分不得含有传输编码报头域。</p>
<p class="p2">不可在摘要计算或核对之前就将任何断线转换为<span class="s3">CRLF</span>：实际传输的文本中使用的断线转换协定必须原封不动的参与摘要计算。</p>
<p class="p2">注：虽然<span class="s3">HTTP</span>的内容<span class="s3">-MD5</span>定义和<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 1864</span>中关于<span class="s3">MIME</span>实体正文的完全一样，<span class="s3"> </span>但<span class="s3">HTTP </span>实体正文在对内容<span class="s3">-MD5</span>的应用上仍然有几处与<span class="s3">MIME</span>实体正文有所区别。首先，<span class="s3">HTTP</span>不象<span class="s3">MIME</span>会用内容<span class="s3">-</span>传输编码，而是使用传输编码与内容编码。<span class="s3"> </span>其次，<span class="s3">HTTP</span>比<span class="s3">MIME</span>更多地使用二进制内容类型，故值得提出的是：<span class="s3"> </span>在此种情况下，用于计算摘要的字节序也即由类型定义的传输字节顺序。最后，<span class="s3">HTTP</span>允许文本类传输时采用数种断线协定，而不只是规范的使用<span class="s3">CRLF</span>的形式。</p>
<p class="p1">14<span class="s1">．</span>16 <span class="s1">内容</span>-<span class="s1">范围</span></p>
<p class="p2">内容<span class="s3">-</span>范围实体报头与部分实体正文一起发送，用于指明在全部实体正文中，那一部分正文应该应用于何处。<span class="s3"> </span>范围的单位在<span class="s3">3</span>。<span class="s3">12</span>节中有定义。</p>
<p class="p1"><span class="s1">内容</span>-<span class="s1">范围</span> = "<span class="s1">内容</span>-<span class="s1">范围</span>""<span class="s1">：</span>"<span class="s1">内容</span>-<span class="s1">范围</span>-<span class="s1">说明</span><span class="s2"><br>
</span><span class="s1">内容</span>-<span class="s1">范围</span>-<span class="s1">说明</span> = <span class="s1">字节</span>-<span class="s1">内容</span>-<span class="s1">范围</span>-<span class="s1">说明</span><span class="s2"><br>
</span><span class="s1">字节</span>-<span class="s1">内容</span>-<span class="s1">范围</span>-<span class="s1">说明</span> =<span class="s1">字节</span>-<span class="s1">单位</span> SP<span class="s2"><br>
</span>                     <span class="s1">字节</span>-<span class="s1">范围</span>-<span class="s1">方面</span>-<span class="s1">说明</span> "/"<span class="s2"><br>
</span>                    <span class="s1">（实例</span>-<span class="s1">长度</span>|"*"<span class="s1">）</span><span class="s2"><br>
</span><span class="s1">字节</span>-<span class="s1">范围</span>-<span class="s1">方面</span>-<span class="s1">说明</span> =<span class="s1">（首字节位置</span> "-" <span class="s1">末字节位置）</span> |"*"<span class="s2"><br>
</span><span class="s1">实例</span>-<span class="s1">长度</span>  =1*DIGIT</p>
<p class="p2">除非无法或很难测定，报头应指明全部实体正文的总长度。星号<span class="s3">"*"</span>表示生成应答信息时实例长度未知。</p>
<p class="p2">与字节<span class="s3">-</span>范围<span class="s3">-</span>指定符的值（参见<span class="s3">14</span>。<span class="s3">35</span>。<span class="s3">1</span>节）不同的是，字节<span class="s3">-</span>范围<span class="s3">-</span>方面<span class="s3">-</span>说明仅可指明一个范围，且必须包含首末字节的绝对位置。</p>
<p class="p2">其字节<span class="s3">-</span>范围<span class="s3">-</span>方面<span class="s3">-</span>说明的末字节值小于首字节值或实例<span class="s3">-</span>长度值小于等于末字节值的字节<span class="s3">-</span>内容<span class="s3">-</span>范围<span class="s3">-</span>说明是无效的。收到无效的字节<span class="s3">-</span>内容<span class="s3">-</span>范围<span class="s3">-</span>说明值时接收者必须忽略此值与随其传输的任何内容。</p>
<p class="p2">应答时发送状态码<span class="s3">416</span>（请求的范围无法满足）的服务器应在内容<span class="s3">-</span>范围域中填上字节<span class="s3">-</span>范围<span class="s3">-</span>方面<span class="s3">-</span>说明为<span class="s3">"*"</span>。实例<span class="s3">-</span>长度项指明被选资源的现有长度。状态码为<span class="s3">206</span>（部分内容）的应答不应将内容<span class="s3">-</span>范围域的字节<span class="s3">-</span>范围<span class="s3">-</span>方面<span class="s3">-</span>说明填为<span class="s3">"*"</span>。</p>
<p class="p2">假定实体共含<span class="s3">1234</span>字节，字节<span class="s3">-</span>范围<span class="s3">-</span>方面<span class="s3">-</span>说明项的示范值为：</p>
<p class="p1"><span class="s1">头</span>500<span class="s1">字节：</span> <span class="s1">字节</span>0-499/1234<span class="s2"><br>
</span><span class="s1">次</span>500<span class="s1">字节：</span> <span class="s1">字节</span>500-999/1234<span class="s2"><br>
</span><span class="s1">除头</span>500 <span class="s1">字节外的所有：</span> <span class="s1">字节</span>500-1233/1234<span class="s2"><br>
</span><span class="s1">末</span>500<span class="s1">字节：</span> <span class="s1">字节</span>734-1233/1234</p>
<p class="p2">当<span class="s3">HTTP</span>报文包含单一范围的内容时，（比如，对单一范围请求，或对一组互有覆盖但无遗漏的请求的应答）此内容在传输时内容<span class="s3">-</span>范围报头与内容<span class="s3">-</span>长度报头会显示实际传输的字节数。例如：</p>
<p class="p1">HTTP/1<span class="s1">。</span>1 206 <span class="s1">部分内容</span><span class="s2"><br>
</span><span class="s1">日期：</span> <span class="s1">星期三，</span> 1995<span class="s1">年</span>11<span class="s1">月</span>15<span class="s1">日</span> 06<span class="s1">：</span>25<span class="s1">：</span>24 <span class="s1">（格林威治时间）</span><span class="s2"><br>
</span><span class="s1">上次修改时间：星期三，</span> 1995<span class="s1">年</span>11<span class="s1">月</span>15<span class="s1">日</span> 04<span class="s1">：</span>58<span class="s1">：</span>08 <span class="s1">（格林威治时间）</span><span class="s2"><br>
</span><span class="s1">内容</span>-<span class="s1">范围：字节</span>21010-47021/47022<span class="s2"><br>
</span><span class="s1">内容</span>-<span class="s1">长度：</span> 26012<span class="s2"><br>
</span><span class="s1">内容</span>-<span class="s1">类型：</span>image/gif</p>
<p class="p2">当<span class="s3">HTTP</span>报文包含多个范围时（比如，对多个未重叠范围请求的应答），它们会被当作多部分报文来传送。</p>
<p class="p2">用于此目的的多部分媒体类型如附录<span class="s3">19</span>。<span class="s3">2</span>节中所述定义为<span class="s3">"multipart/byteranges"</span>。<span class="s3"> </span>其兼容性问题述于附录<span class="s3">19</span>。<span class="s3">6</span>。<span class="s3">3</span>中。</p>
<p class="p2">对单一范围请求的应答不得使用<span class="s3">multipart/byteranges</span>媒体类型。若对多范围请求的应答结果为单一范围，可以采用只有一个部分的<span class="s3">multipart/byteranges</span>媒体类型发送。无法对<span class="s3">multipart/byteranges</span>报文解码的客户机不得在单一请求中申请多个字节范围。</p>
<p class="p2">当客户机在单一请求中申请多个字节范围时，服务器应按请求中出现的顺序发回信息。</p>
<p class="p2">若服务器出于句法无效的原因忽略了字节<span class="s3">-</span>范围<span class="s3">-</span>说明，它应视无效的范围报头域不存在来处理请求。（正常情况下，这意味着发回含有全部实体的<span class="s3">200</span>应答。）</p>
<p class="p2">如果服务器接到请求报头域中含无法满足的范围（也即，所有字节<span class="s3">-</span>范围<span class="s3">-</span>说明值的首字节值大于所选资源现有长度）的请求（含条件<span class="s3">-</span>范围请求报头域的除外），则它应应答以代码<span class="s3">416</span>（请求的范围无法满足）（参见<span class="s3">10</span>。<span class="s3">4</span>。<span class="s3">17</span>节）。</p>
<p class="p2">注：<span class="s3"> </span>客户机对无法满足范围的请求报头不能指望服务器一定发回<span class="s3">416</span>（请求的范围无法满足）而非<span class="s3">200</span>（<span class="s3">OK</span>）的应答，因为不是所有服务器都处理这一请求报头。</p>
<p class="p1">14<span class="s1">．</span>17 <span class="s1">内容</span>-<span class="s1">类型</span></p>
<p class="p2">内容<span class="s3">-</span>类型实体报头域指明发给接收者的实体正文的媒体类型，或在<span class="s3">HEAD</span>方法中指明若请求为<span class="s3">GET</span>时将发送的媒体类型。</p>
<p class="p2">内容<span class="s3">-</span>类型<span class="s3">="</span>内容<span class="s3">-</span>类型<span class="s3">""</span>：<span class="s3">"</span>媒体类型</p>
<p class="p2">媒体类型有<span class="s3">3</span>。<span class="s3">7</span>节定义。<span class="s3"> </span>此域的示例如下：</p>
<p class="p1"><span class="s1">内容</span>-<span class="s1">类型：</span>text/html; charset<span class="s1">（字符集）</span>=ISO-8859-4</p>
<p class="p2"><span class="s3">7</span>．<span class="s3">2</span>．<span class="s3">1</span>节提供了关于确定实体媒体类型方法的进一步论述。</p>
<p class="p1">14<span class="s1">．</span>18  <span class="s1">日期</span></p>
<p class="p2"><span class="s3">  </span>日期头域描述消息产生的日期和时间，它和<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3">822</span>中的<span class="s3">ORIG-DATE</span>语义一样。域值是一个在<span class="s3">3</span>。<span class="s3">3</span>。<span class="s3">1</span>描述的<span class="s3">HTTP</span>日期；它必须用<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3">1123[8]</span>数据格式发送。</p>
<p class="p1">      Date="Date""<span class="s1">：</span>"HTTP-date</p>
<p class="p2"><span class="s3">  </span>举个例子</p>
<p class="p1">         Date:Tue,15 Nov 1994 08:12:31GMT</p>
<p class="p2">原服务器在所有的应答中必须包括一个日期头域，除了这些特例：<span class="s2"><br>
</span>　　１<span class="s3"> </span>如果应答的状态代码时１００（继续）获１０１（选者<a href="http://www.cnpaf.net/">协议</a>），相应可以在服务的选项中包括日期头域。</p>
<p class="p2">　　<span class="s3">2 </span>如果应答状态代码传送服务器错误，如５００（ｉｎｔｅｒｎｅｔ服务器错误）获５０３（服务器不可达），它没有困难或不可能产生有效的日期。</p>
<p class="p2">　　<span class="s3">3 </span>如果服务器没有时钟，不能提供合理的当前时间的近似值，这个应答没必要包括日期头域，但在这种情况下必须遵照<span class="s2"><br>
</span><span class="s3">14</span>．<span class="s3">18</span>．<span class="s3">1</span>节中的规则。</p>
<p class="p2">一个收到的消息没有日期头域的话会被接收者加上一个，如果这条消息将被那个接收者或网关储存并进由一个需要日期的<a href="http://www.cnpaf.net/">协议</a>。一个没有时钟的<span class="s3">http</span>执行不能缓存没有重新使之关于每一个使用有效的应答。一个<span class="s3">http</span>缓存，特别是一个共享的缓存，必须使用一种机制使它与外界可靠的时钟保持同步。</p>
<p class="p2">客户端秩序在包括实体的消息中发送日期头域，正如在<span class="s3">PUT</span>和<span class="s3">POST</span>请求的过程，甚至它是随意的。一个没有时钟的客户端不能在请求中发送日期头域。</p>
<p class="p2">一个日期头中的<span class="s3">http-date</span>没必要描述一个后续消息的产生的日期和时间。它必须描述消息产生的最有用的日期和实践的近似值。除非执行没有方法产生一个恰当的相当精确的日期和时间。理论上说，日期必须是实体产生之前的那一刻，实际上，日期能是消息产生的任何时候的时间而不会影响其语义。</p>
<p class="p2"><span class="s3">14</span>．<span class="s3">18</span>．<span class="s3">1 </span>没有时钟的原服务器的运作</p>
<p class="p2"><span class="s3">  </span>一些原服务器的执行可能没有可用的时钟。一个没有时钟的原服务器不能指定一个应答断开或维持修改的值除非这些值是和系统或用户可靠的时钟资源相关联的。它可以指定一个知道的终止值，在服务配置的时间或以前，这是过去的（这允许应答的预终止而不保存每个资源分离的分割值）。</p>
<p class="p1"><span class="s2"><br>
</span>14<span class="s1">．</span>19  ETag</p>
<p class="p2"><span class="s3">Etag</span>应答报头域提供了请求变量的当前实体标签。与实体标签一起使用的报头由<span class="s3">14</span>。<span class="s3">14</span>，<span class="s3">14</span>。<span class="s3">26</span>，<span class="s3">14</span>。<span class="s3">44</span>节描述。</p>
<p class="p2">实体标签可用于比较来自同一资源的不同实体。（参见<span class="s3">13</span>。<span class="s3">3</span>。<span class="s3">3</span>节）</p>
<p class="p1">Etag="ETag" "Etag"":" <span class="s1">实体</span>-<span class="s1">标签</span></p>
<p class="p2">例：</p>
<p class="p1">      ETag: "xyzzy"<span class="s2"><br>
</span>      ETag: W/"xyzzy"<span class="s2"><br>
</span>      ETag: ""</p>
<p class="p1"><span class="s2"><br>
</span>14<span class="s1">．</span>20 <span class="s1">期望</span></p>
<p class="p2">期望请求报头域用于指明客户机需要特定的服务器行为。</p>
<p class="p2">期望<span class="s3">="</span>期望<span class="s3">""</span>：<span class="s3">"1#</span>期望值<span class="s2"><br>
</span>期望值<span class="s3">="100-</span>继续<span class="s3">"|</span>期望值<span class="s3">-</span>扩展<span class="s2"><br>
</span>期望值<span class="s3">-</span>扩展<span class="s3">=</span>标号<span class="s3">["="</span>（标号<span class="s3">|</span>引用<span class="s3">-</span>字符串）<span class="s3"> *</span>期望<span class="s3">-</span>参数<span class="s3">]</span><span class="s2"><br>
</span>期望<span class="s3">-</span>参数<span class="s3">="</span>；<span class="s3">"</span>标号<span class="s3">["="</span>（标号<span class="s3">|</span>引用<span class="s3">-</span>字符串）<span class="s3">]</span></p>
<p class="p2">对请求的期望域中期望值不理解或与其不相容的服务器必须应答以相应的出错状态。<span class="s3"> </span>如果所有期望都无法满足，服务器必须应答以<span class="s3">417</span>（期望失败）状态。<span class="s3"> </span>若请求有其他问题，则应应答以其他<span class="s3">4xx</span>状态。</p>
<p class="p2">本报头域依照可扩展语法定义，以满足将来扩展需要。若服务器接到的请求含有它不支持的期望<span class="s3">-</span>扩展，则它必须应答以<span class="s3">417</span>（期望失败）状态。</p>
<p class="p2">期望值的比较对于未经引用的标号（包括<span class="s3">"100-</span>继续<span class="s3">"</span>标号）是而言对个例敏感的，对引用字符串的期望<span class="s3">-</span>扩展而言是对个例不敏感的。</p>
<p class="p2">期望机制是逐站进行的：即<span class="s3">HTTP/1</span>。<span class="s3">1</span>代理服务器在无法满足请求期望时必须<span class="s3">.</span>回送<span class="s3">417</span>（期望失败）状态。<span class="s3"> </span>然而，期望请求报头本身却是端到端的；它必须随请求一起转发。</p>
<p class="p2">许多旧版的<span class="s3">HTTP/1</span>。<span class="s3">0</span>和<span class="s3">HTTP/1</span>。<span class="s3">1</span>应用程序不理解期望报头。</p>
<p class="p2">参见<span class="s3">8</span>。<span class="s3">2</span>。<span class="s3">3</span>节中<span class="s3">100</span>（继续）状态的使用。</p>
<p class="p1">14<span class="s1">．</span>21 <span class="s1">过期（</span>Expire<span class="s1">）</span></p>
<p class="p2"><span class="s3">"</span>过期<span class="s3">"</span>实体报头域给出了在何日何时之后应答即被视为陈旧。除非首先经原服务器（或含有此实体较新拷贝的中介代理服务器缓存）确认为有效，缓存一般不会返回陈旧的缓存目录值。<span class="s3"> </span>请参见<span class="s3">13</span>。<span class="s3">2</span>节中对过期模型的深入论述。</p>
<p class="p2">其格式为由<span class="s3">3</span>。<span class="s3">3</span>。<span class="s3">1</span>节中<span class="s3">HTTP-</span>日期定义的绝对日期与时间；<span class="s3"> </span>它必须遵照<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 1123</span>的日期格式：</p>
<p class="p1"><span class="s1">过期</span>="<span class="s1">过期</span>""<span class="s1">：</span>" HTTP-<span class="s1">日期</span></p>
<p class="p2">使用示例为：</p>
<p class="p2">过期：<span class="s3"> </span>星期四，<span class="s3">1994</span>年<span class="s3">12</span>月<span class="s3">1</span>日，<span class="s3"> 16</span>：<span class="s3">00</span>：<span class="s3">00 </span>格林威治时间</p>
<p class="p2">注：若应答包含填有最大时限谓词（参见<span class="s3">14</span>。<span class="s3">9</span>。<span class="s3">3</span>节）的缓存<span class="s3">-</span>控制域，则谓词作用覆盖过期域。</p>
<p class="p2"><span class="s3">HTTP/1</span>。<span class="s3">1</span>客户机和缓存必须把其它无效的，尤其是含有<span class="s3">"0"</span>值的日期格式按过去值（即<span class="s3">"</span>已经过期<span class="s3">"</span>）处理。</p>
<p class="p2">要将应答标为<span class="s3">"</span>已经过期<span class="s3">"</span>，原服务器须发送和日期报头值相等的过期日期值。（参见<span class="s3">13</span>。<span class="s3">2</span>。<span class="s3">4</span>节的过期计算规则）</p>
<p class="p2">为标记应答为<span class="s3">"</span>永不过期<span class="s3">"</span>，原服务器须发送过期日期晚于发送应答的时间一年左右的过期日期。<span class="s3">HTTP/1</span>。<span class="s3">1</span>服务器不应发送超过将来一年的过期日期。</p>
<p class="p2">对于原本不可被缓存的应答而言，除非缓存控制域中另有指定，否则</p>
<p class="p2">过期报头域中填有将来的某一日期和时间值即是表明该应答允许缓存，</p>
<p class="p1">14<span class="s1">．</span>22 From<span class="s2"><br>
</span>    From<span class="s1">请求报头域，如果给定的话，应该（</span>SHOULD<span class="s1">）包括控制请求用户代理的人的互联网</span>E-MAIL<span class="s1">地址。这个地址应该（</span>SHOULD<span class="s1">）是适用于机器的，就像在<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a></span> 822 [9]<span class="s1">里定义的</span>“mailbox"<span class="s1">以及在<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a></span> 1123 [8]<span class="s1">修订的：</span><span class="s2"><br>
</span>    <span class="s2"><br>
</span>    From   = "From" ":" mailbox<span class="s2"><br>
</span>    <span class="s1">例如：</span><span class="s2"><br>
</span>          From: <a href="mailto:webmaster@w3.org">webmaster@w3.org</a></p>
<p class="p2"><span class="s3">    </span>报头域可以（<span class="s3">MAY</span>）用作记录日志的目的和作为认证无效或者多余请求源的方法。他不应该（<span class="s3">SHOULD NOT</span>）用作不<a href="http://www.cnpaf.net/class/security/">安全</a>形式的访问保护。这个域的解释是请求正在为某个给定的人执行，它承担这个方法执行的责任。特别的，自动控制代理应该（<span class="s3">SHOULD</span>）包括这个域这样一来如果接收端出现问题的话，对运行这个自动控制程序有责任的人能够得到联系。</p>
<p class="p2"><span class="s3">    </span>这个域的互联网<span class="s3">E-MAIL</span>地址可以（<span class="s3">MAY</span>）从发出请求的互联网主机中分离出来。例如，当一个请求通过一个代理服务器是应该（<span class="s3">SHOULD</span>）使用原发出者的地址。</p>
<p class="p2"><span class="s3">    </span>客户机不应该（<span class="s3">SHOULD</span>）发出没有得到用户批准的<span class="s3">From</span>域，因为它可能和用户的个人利益或者他们站点的<a href="http://www.cnpaf.net/class/security/">安全</a>政策冲突。强烈建议用户在任何一次请求之前能够取消，授权，和修改这个域的值。</p>
<p class="p2"><span class="s3">14</span>．<span class="s3">23 </span>主机（<span class="s3">Host</span>）<span class="s2"><br>
</span><span class="s3">    </span>主机（<span class="s3">Host</span>）请求报头域说明了正在请求的资源的互联网主机和端口号，就包括在用户或者提交的资源指定的源<span class="s3">URI</span>中（一般是一个<span class="s3">HTTP URL,</span>就像在<span class="s3">3.2.2</span>部分描述的）。<span class="s3">Host</span>域的值必须（<span class="s3">MUST</span>）代表源<span class="s3">URL</span>给定的源网关或者服务器的授权命名。这允许源服务器或网关区分内部不明确的<span class="s3">URL</span>，例如单个<span class="s3">IP</span>地址上有多个主机域名的服务器的根<span class="s3">“/”URL.</span><span class="s2"><br>
</span><span class="s3">    </span><span class="s2"><br>
</span><span class="s3">    Host = "Host" ":" host [ ":" port ] ; 3.2.2</span>节</p>
<p class="p1">    <span class="s1">一个没有任何追踪端口信息的</span>“<span class="s1">主机</span>”<span class="s1">暗示使用请求服务的缺省端口（例如，</span>“80”<span class="s1">对应</span>HTTP URL<span class="s1">）。例如，源服务器上对</span>&lt;<a href="http://www.w3.org/pub/WWW/">http://www.w3.org/pub/WWW/</a>&gt;<span class="s1">的请求将完全包括：</span><span class="s2"><br>
</span>      <span class="s2"><br>
</span>       GET /pub/WWW/ HTTP/1.1<span class="s2"><br>
</span>       Host: <a href="http://www.w3.org/">www.w3.org</a></p>
<p class="p2">在所有的<span class="s3">HTTP/1.1</span>请求信息中客户机必须（<span class="s3">MUST</span>）包括<span class="s3">Host</span>报头域。如果被请求的<span class="s3">URI</span>不包括被请求服务的互联网主机域名，那么<span class="s3">Host</span>报头域必须（<span class="s3">MUST</span>）是空值。</p>
<p class="p2">一个<span class="s3">HTTP/1.1</span>的代理服务器必须（<span class="s3">MUST</span>）确保它向前传递的任何报文确实包括代理服务器可识别的请求服务的适当的<span class="s3">Host</span>报头域。所有基于互联网的<span class="s3">HTTP/1.1</span>服务器必须（<span class="s3">MUST</span>）对任何缺少<span class="s3">Host</span>报头域的<span class="s3">HTTP/1.1</span>请求报文响应状态代码<span class="s3">400</span>（坏的请求）。</p>
<p class="p2">见<span class="s3">5.2</span>和<span class="s3">19.6.1.1</span>节和主机关联的其他请求。</p>
<p class="p2"><span class="s3">14</span>。<span class="s3">24 If-Match</span><span class="s2"><br>
</span><span class="s3">    </span><span class="s2"><br>
</span><span class="s3">If-Match</span>报头域是用一种方法使得它是有条件的。由以前从源获得的一个或更多实体的客户机能够校验那些实体中的一个现在包括在<span class="s3">If-Match</span>报头域的一系列联合的实体标签。实体标签在<span class="s3">3.11</span>节定义。这种特征的目的是允许用对报头进行最少量处理的方法对高速缓存信息进行有效的修正。它也用来在更新请求时防止源的错误版本无意识的修改。作为一种特殊情况，<span class="s3">“*”</span>匹配任何现有源的实体。</p>
<p class="p1">       If-Match = "If-Match" ":" ( "*" | 1#entity-tag )</p>
<p class="p2">如果任何一个实体标签匹配在对类似<span class="s3">GET</span>请求的响应中返回的实体的实体标签，或者如果给出<span class="s3">“*”</span>以及对那个源任何现存的实体，那么服务器可以（<span class="s3">MAY</span>）在执行请求的方法就好像<span class="s3">If-Match</span>报头域不存在一样。</p>
<p class="p2">服务器必须（<span class="s3">MUST</span>）用功能强大的比较函数来比较在<span class="s3">If-Match</span>中的实体标签。</p>
<p class="p2">如果没有一个实体标签匹配，或者给出了<span class="s3">“*”</span>而没有现有的实体，服务器一定不要（<span class="s3">MUST NOT)</span>执行请求的方法，并且返回<span class="s3">412</span>响应（预处理失败）。当客户机希望防止更新的方法，例如<span class="s3">PUT</span>，修改自从客户机上一次找到以后已经改变的源的时候，这种行为是很有用的。</p>
<p class="p2">如果请求将会导致除<span class="s3">2XX</span>或<span class="s3">412</span>以外的任何状态，没有<span class="s3">If-Match</span>报头域，那么<span class="s3">If-Match</span>报头必须（<span class="s3">MUST</span>）被忽略。</p>
<p class="p2"><span class="s3">"If-Match: *" </span>的含义是当源服务器（或高速缓存，很可能使用<span class="s3">Vary</span>机制，见<span class="s3">14.44</span>节）选择的表示法存在时，方法就应该被执行，并且当表示法不存在时，一定不要（<span class="s3">MUST NOT</span>）执行。</p>
<p class="p2">想要更新源的请求（例如<span class="s3">PUT</span>）可以（<span class="s3">MAY</span>）包括<span class="s3">If-Match</span>报头域来发出信号如果相应于<span class="s3">If-Match</span>值的实体（单个实体标签）不再是源的表示法请求方法应订不能（<span class="s3">MUST NOT</span>）得到应用。这允许用户表明如果源已经改变而他们不知道的话他们不希望请求成功。<span class="s2"><br>
</span>例如：</p>
<p class="p1">       If-Match: "xyzzy"<span class="s2"><br>
</span>       If-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"<span class="s2"><br>
</span>       If-Match: *</p>
<p class="p1"><span class="s1">既有</span>If-Match<span class="s1">报头域又有</span>If-None-Match<span class="s1">或</span>If-Modified-Since<span class="s1">报头域的请求的结果本规范没有定义。</span></p>
<p class="p1">14<span class="s1">．</span>25 If-Modified-Since</p>
<p class="p2"><span class="s3">    </span>用一种方法使<span class="s3">If-Modified-Since</span>请求报头域被用来使得如果请求的变量自从这个域说明的时间以来没有被修改过，实体将不会从服务器返回；相反的，将返回<span class="s3">304</span>响应（没有修改的）而没有任何报文实体。</p>
<p class="p1">       If-Modified-Since = "If-Modified-Since" ":" HTTP-date</p>
<p class="p2">这个域的一个例子是：</p>
<p class="p1">       If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT</p>
<p class="p2"><span class="s3">    </span>有<span class="s3">If-Modified-Since</span>报头没有<span class="s3">Range</span>报头的<span class="s3">GET</span>方法请求只有如果自从<span class="s3">If-Modified-Since </span>报头给定的时间以来认证实体已经被修改过，它才会被传递。决定这个的运算法则包括以下的情况：</p>
<p class="p2"><span class="s3">        a</span>）如果请求通常将会导致除状态<span class="s3">200</span>之外的任何情况，或者如果传递的<span class="s3">If-Modified-Since</span>日期是无效的，响应和对正常的<span class="s3">GET</span>的响应完全一样。比服务器现在的时间晚的日期是无效的。</p>
<p class="p1">        b<span class="s1">）如果自从</span>If-Modified-Since<span class="s1">日期以来变量已经修改了，响应和对正常</span>GET<span class="s1">的完全一样。</span></p>
<p class="p2"><span class="s3">        c</span>）如果自从一个有效的<span class="s3">If-Modified-Since</span>日期以来变量没有修改过，服务器应该返回响应<span class="s3">304</span>（没修改）。</p>
<p class="p2"><span class="s3">    </span>这种特征的目的是允许用对头部最小量的处理来有效的更新高速缓存的信息。</p>
<p class="p1">        <span class="s1">注释：</span>Range<span class="s1">请求报头域修改了</span>If-Modified-Since<span class="s1">的含义；完整的详细信息见</span> 14.35<span class="s1">。</span></p>
<p class="p2"><span class="s3">        </span>注释：<span class="s3">If-Modified-Since</span>的时间是由服务器说明的，它的时钟可能和客户机的不同步。</p>
<p class="p2"><span class="s3">        </span>注释：当处理一个<span class="s3">If-Modified-Since</span>报头域的时候，一些服务器使用精确的比较函数而不是稍差的函数，来决定是否发送响应<span class="s3">304</span>（没修改）。当给高速缓存确认发送<span class="s3">If-Modified-Since</span>报头域时为了得到最好的结果，建议客户机只要可能就采用从先前<span class="s3">Last-Modified</span>报头域收到的精确日期字符串。</p>
<p class="p2"><span class="s3">        </span>注释：如果客户机在<span class="s3">If-Modified-Since</span>报头域中用任意的日期代替从<span class="s3">Last-Modified</span>报头得到的对同样请求的日期，客户机应该注意到这个日期是由服务器对时间的理解来解释的事实。由于客户机和服务器之间时间编码的不同，客户机应该考虑时钟不同步和舍入的问题。这包括了如果在第一次请求的时间和后来请求的<span class="s3">If-Modified-Since</span>日期之间文档已经改变而出现竞争的可能性，以及如果<span class="s3">If-Modified-Since</span>从客户机得到的日期没有得到服务器时钟的修正而出现时钟倾斜有关问题的可能性。由于网络反应时间的原因客户机和服务器之间对不同时间基准的修正是最佳的近似。</p>
<p class="p1">    <span class="s1">既有</span>If-Modified-Since<span class="s1">报头域又有</span>If-Match<span class="s1">或</span>If-Unmodified-Since<span class="s1">报头域的请求的结果本规范没有定义。</span></p>
<p class="p1"> </p>
<p class="p2"><span class="s3">14</span>．<span class="s3">26 “</span>如果不匹配<span class="s3">”</span>（<span class="s3">If-None-Match</span>）<span class="s2"><br>
</span><span class="s3">        If-None-Match</span>报头区伴随一种使其条件化的算法使用。一个已从源端获得<span class="s2"><br>
</span>实体的客户可以校验得出：这些实体没有通过在<span class="s3">If-None-Match</span>报头区标明相应实体<span class="s2"><br>
</span>标签而流通。此特征的目的是达到最小代价的高效缓存信息刷新。它也可以防止一<span class="s2"><br>
</span>些算法无意中修改客户认为不存在而实际存在的资源。</p>
<p class="p1">        <span class="s1">作为特殊情况，特征值</span>“*”<span class="s1">匹配资源的任何当前实体。</span><span class="s2"><br>
</span>       If-None-Match = "If-None-Match" ":" ( "*" | 1#entity-tag )</p>
<p class="p2"><span class="s2"><br>
</span><span class="s3">        </span>如果任何实体标签与将被用来回复<span class="s3">GET</span>请求的实体匹配，或给出<span class="s3">“*”</span>且<span class="s2"><br>
</span>针对该资源的实体存在，则服务器不能执行被请求的算法，除非由于资源的修改<span class="s2"><br>
</span>数据不能匹配<span class="s3">If-Modified-Since</span>报头区提供的相应内容而被要求那样做。<span class="s2"><br>
</span>与之相反，如果请求算法是<span class="s3">GET</span>或<span class="s3">HEAD</span>，服务器应回复<span class="s3">304</span>响应，包含有匹配实<span class="s2"><br>
</span>体的缓存相关报头区。所有其它算法，服务器必须回复<span class="s3">412</span>状态码。</p>
<p class="p2"><span class="s2"><br>
</span><span class="s3">           13.3</span>节说明怎样判断两实体标签匹配<span class="s3">.</span>弱比较函数只能用于<span class="s3">GET</span>或<span class="s3">HEAD</span>请求。<span class="s2"><br>
</span><span class="s3">   </span><span class="s2"><br>
</span><span class="s3">        </span>如果没有实体标签匹配，则服务器将执行被请求的算法只当<span class="s3">If-None-Match</span><span class="s2"><br>
</span>报头区不存在，但必须同时也忽略请求中的<span class="s3">If-Modified-Since</span>报头区。即，如果没<span class="s2"><br>
</span>有实体标签匹配则不能回复<span class="s3">304</span>响应。<span class="s2"><br>
</span><span class="s3">        </span>如果没有<span class="s3">If-None-Match</span>报头区的请求最终回复非<span class="s3">2xx</span>及<span class="s3">304</span>响应，则<span class="s2"><br>
</span><span class="s3">If-None-Match</span>报头一定要被忽略。（见<span class="s3">13.3.4</span>）<span class="s2"><br>
</span><span class="s3">    "If-None-Match: *"</span>的意思是：当源服务器选择的代表（<span class="s3">representation</span>）<span class="s2"><br>
</span>存在时算法不可用而当七其存在时可用<span class="s3"> </span>此特征在防止<span class="s3">PUT</span>操作的<span class="s3">______</span>时是有用<span class="s2"><br>
</span>的<span class="s3">.</span></p>
<p class="p1">     <span class="s2"><br>
</span>     <span class="s1">例</span>:<span class="s2"><br>
</span>       If-None-Match: "xyzzy"<span class="s2"><br>
</span>       If-None-Match: W/"xyzzy"<span class="s2"><br>
</span>       If-None-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"<span class="s2"><br>
</span>       If-None-Match: W/"xyzzy", W/"r2d2xxxx", W/"c3piozzzz"<span class="s2"><br>
</span>       If-None-Match: *</p>
<p class="p1">           <span class="s1">含有</span>If-None-Match<span class="s1">报头区及</span>If-Match<span class="s1">或者</span>If-Unmodified-Since<span class="s1">（此后不可</span><span class="s2"><br>
</span><span class="s1">修改）报头区的请求结果在此说明中不做定义</span></p>
<p class="p2"><span class="s2"><br>
</span><span class="s3">14</span>．<span class="s3">27 If-Range</span><span class="s2"><br>
</span>如果客户机在其缓存中有实体的部分拷贝，并希望向缓存中添入整个实体的更新后拷贝，它可以在条件<span class="s3">GET</span>（<span class="s3">If-Unmodified-Since </span>和<span class="s3">If-Match</span>两者兼用或只取其一）中使用范围请求报头域。然而，若由于实体已被修改而导致条件不满足，客户机就需要再次发出获取当前整个实体正文的请求。</p>
<p class="p2"><span class="s3">If-Range</span>允许客户机<span class="s3">“</span>拦截<span class="s3">”</span>第二次请求。<span class="s3"> </span>简要说来，其含义为<span class="s3">“</span>若实体未改变，请发送我缺少的部分给我；否则，发给我整个实体<span class="s3">”</span>。<span class="s2"><br>
</span>若客户机不具备实体的实体标签，但有上次修改日期，它可以在<span class="s3">If-Range</span>报头中使用此日期（服务器通过检查一两个字符即可区分合法<span class="s3">HTTP</span>日期与任意形式的实体标签）。<span class="s3">If-Range</span>报头应只和范围报头一起使用，且在请求不含范围报头或服务器不支持亚范围操作时必须被忽略。<span class="s2"><br>
</span>若<span class="s3">If-Range</span>报头中给出的实体标签于实体当前的实体标签相吻合，则服务器应使用<span class="s3">206</span>（部分内容）应答来指明实体的亚范围。<span class="s3"> </span>若实体标签不相符，服务器应使用<span class="s3">200</span>（<span class="s3">OK</span>）应答返回整个实体。</p>
<p class="p2"><span class="s2"><br>
</span><span class="s3">14</span>．<span class="s3">28 If-Unmodified-Since</span><span class="s2"><br>
</span><span class="s3">If-Unmodified-Since</span>请求报头域用来使某方法变为条件的。若请求的资源在此域中指定的时间之后即未被修改，则服务器应按<span class="s3">If-Unmodified-Since</span>报头不存在的方式执行所请求的操作。</p>
<p class="p1"><span class="s1">若请求的变量在给定时间之后已被修改，则服务器不得执行所请求的操作，且必须返回</span>412<span class="s1">（前提条件不满足）应答。</span><span class="s2"><br>
</span>      If-Unmodified-Since = "If-Unmodified-Since" ":" HTTP-<span class="s1">日期</span></p>
<p class="p2"><span class="s3">   </span>此域的应用实例<span class="s3">:</span></p>
<p class="p1">       If-Unmodified-Since: <span class="s1">星期六</span>, 1994<span class="s1">年</span>10<span class="s1">月</span>29<span class="s1">日</span> 19:43:31 <span class="s1">格林威治时间</span></p>
<p class="p1"><span class="s1">如果正常情况下（即没有</span>If-Unmodified-Since<span class="s1">报头时），请求会得到除了</span>2xx<span class="s1">与</span>412<span class="s1">状态的结果，则</span>If-Unmodified-Since<span class="s1">报头应被忽略。</span><span class="s2"><br>
</span><span class="s1">若指定的日期无效，本域亦被忽略。</span><span class="s2"><br>
</span><span class="s1">本说明未定义一个既有</span>If-Unmodified-Since<span class="s1">报头，又有</span>If-None-Match <span class="s1">或</span>If-Modified-Since<span class="s1">报头的请求的结果。</span></p>
<p class="p2"><span class="s2"><br>
</span><span class="s3">14</span>．<span class="s3">29 </span>上次修改<span class="s2"><br>
</span>上次修改实体报头域指明原服务器认为的变量上次被修改的日期和时间。</p>
<p class="p2">上次修改<span class="s3">="</span>上次修改<span class="s3">""</span>：<span class="s3">"HTTP-</span>日期</p>
<p class="p2">应用示例如下：</p>
<p class="p2">上次修改：<span class="s3"> </span>星期二，<span class="s3"> 1994</span>年<span class="s3">11</span>月<span class="s3">15</span>日，<span class="s3"> 12</span>：<span class="s3">45</span>：<span class="s3">26 </span>格林威治时间</p>
<p class="p2">此报头域的确切含义取决于原服务器的处理和原资源的性质。<span class="s3"> </span>对文件而言，它可能仅仅指示文件系统上次修改时间。<span class="s3"> </span>对动态包含各个部分的实体而言，它可能指的是其组成部分的上次修改值中最近的一个。<span class="s3"> </span>对数据库网关而言，它可能就是记录的上次更新时间戳。<span class="s3"> </span>对虚拟对象而言，它可能是上次内部状态改变的时间。</p>
<p class="p2">原服务器不得发送迟于服务器生成此报文时间的上次修改日期。<span class="s3"> </span>在这种情况下资源的上次修改意味着将来的某一时刻，服务器必须以报文生成日期取代之。</p>
<p class="p2">原服务器应尽量在靠近其生成应答日期值的时刻获取上次修改值。<span class="s3"> </span>这样接收者可以更准确的估计实体的修改时间，当实体在应答生成时间的前后有所改动时尤为如此。</p>
<p class="p2"><span class="s3">HTTP/1</span>。<span class="s3">1</span>服务器应尽可能发送<span class="s3">"</span>上次修改<span class="s3">"</span>信息。</p>
<p class="p1">14<span class="s1">．</span>30 <span class="s1">位置（</span>Location<span class="s1">）</span><span class="s2"><br>
</span><span class="s1">除了应用于关于请求完成或新资源确认的请求</span>,URI<span class="s1">位置响应报头域还用于使收件人重发到某个地址</span>.<span class="s1">对</span>201(Created)<span class="s1">响应</span>,<span class="s1">位置是请求建立的新资源</span>.<span class="s1">对</span>3xx<span class="s1">响应</span>.Location<span class="s1">应当指出服务器的关于资源自动重定向的首选</span>URI.<span class="s1">该域的值由单个绝对的</span>URI<span class="s1">组成</span>.<span class="s2"><br>
</span>                      Location       = "Location" ":" absoluteURI<span class="s2"><br>
</span><span class="s1">例如：</span></p>
<p class="p1">       Location: <a href="http://www.w3.org/pub/WWW/People.html">http://www.w3.org/pub/WWW/People.html</a></p>
<p class="p1"><span class="s1">注</span>: Content-Location<span class="s1">报头域</span>(14.14<span class="s1">节</span>)<span class="s1">不同于</span>Location, Content-Location<span class="s1">定义了请求附属实体的源地址</span>.<span class="s1">因此响应有可能既有</span>Location<span class="s1">报头域</span>,<span class="s1">也有</span>Content-Location<span class="s1">报头域</span>.<span class="s1">看</span>13.10<span class="s1">节一些方法的缓存需求</span>.</p>
<p class="p1">14<span class="s1">．</span>31 <span class="s1">最大前向</span>(Max-Forwards)<span class="s2"><br>
</span><span class="s1">最大前向请求头域提供一种带有</span>TRACE(9.8<span class="s1">节</span>)<span class="s1">和</span>OPTION(9.2<span class="s1">节</span>)<span class="s1">方法的机制以限制那些能够向下一个本地服务器转送请求的代理或网关</span>.<span class="s1">当客户尝试跟踪一个似乎失败或在中间链循环的请求链时</span>,<span class="s1">这一点十分有用</span>.<span class="s2"><br>
</span>       Max-Forwards   = "Max-Forwards" ":" 1*DIGIT</p>
<p class="p2">最大前向值是一个表示剩余的请求转送时间的十进制整数<span class="s3">.</span></p>
<p class="p2">每个代理或网关接受包含最大前向头域的<span class="s3">TRACE</span>或<span class="s3">OPTION</span>请求时必须在转送请求前　<span class="s3">Copyright  www.cnpaf.net (2007).          All Rights Reserved.</span><span class="s2"><br>
</span>检查和修正它的值<span class="s3">.</span>如果接收到的值是<span class="s3">zero(0),</span>接收者一定不能转送这个请求<span class="s3">;</span>相反<span class="s3">,</span>它必须像最终接收者一样响应<span class="s3">.</span>如果接收到的最大前向值大于<span class="s3">0,</span>转送的消息必须包含一个经过修正的最大前向域<span class="s3">,</span>其域值减一<span class="s3">.</span></p>
<p class="p2">对本说明书定义的所有其它方法以及任何没有明确将它归作定义的一部分的扩展方法<span class="s3">,</span>最大前向头域可以被忽略<span class="s3">.</span></p>
<p class="p1">14<span class="s1">．</span>32 <span class="s1">实用</span>(Pragma)</p>
<p class="p2"><span class="s3">   </span>实用常规头域被用来包含特殊的执行指令，它可沿请求<span class="s3">/</span>接受链应用于任何接收端。从<a href="http://www.cnpaf.net/">协议</a>的观点所有的实用指示了详细的可选行为；不管怎样，一些系统可以被要求那些行为与指示的相一致。</p>
<p class="p1">            Pragma                ="pargma"":"1#pragma-directive<span class="s2"><br>
</span>            Pragma-directive         ="no-cache"|extension-pragma<span class="s2"><br>
</span>            Extension-pragma        =token["="(token|quoted-dtring)]</p>
<p class="p2">当一个非缓存的指示出现在请求的消息中，应用程序必须跟随这个原服务器的请求，甚至这是个正在被请求的缓存的复制。这个实用的指示的语义和非缓存指示（<span class="s3">14</span>。<span class="s3">9</span>节）一致，他的定义是为了和<span class="s3">http/1.0</span>保持一致。当一个非缓存的请求被送到一个不知道是否支持<span class="s3">http/1.1</span>的服务器，客户端必须包括两个头域。</p>
<p class="p2">使用指示必须被代理和网关应用程序过，不管对于那些应用程序有没有意义。因为这些指令可以被请求<span class="s3">/</span>应答链上的所有接受者应用。不可能为一个特殊的接收者定义一个实用，然而，实用指示必须被不相关的接收者忽略。</p>
<p class="p1">  HTTP/1.1<span class="s1">高速缓冲器必须把</span>"Pragma<span class="s1">：</span>no_cache"<span class="s1">当作客户端发送了</span>"cache_control:no-cache".<span class="s1">在</span>http<span class="s1">中不会有新的指令定义。</span></p>
<p class="p1">     <span class="s1">注意：因为</span>Pragma: no-cache<span class="s1">的意思并没有作为应答的头域在十几种定义，他不提供可靠的应答中</span>Cache-Control: no-cache<span class="s1">的替代。</span><span class="s2"><br>
</span>14<span class="s1">．</span>33 <span class="s1">代理认证</span>(Proxy-Authenticate)<span class="s2"><br>
</span><span class="s1">代理认证的响应头域必须是</span>407<span class="s1">响应的一部分</span>.<span class="s1">这个域的值由表示认证方案的复杂问题和应用于这个请求</span>URI<span class="s1">的代理的参数组成</span>.<span class="s2"><br>
</span>       Proxy-Authenticate  = "Proxy-Authenticate" ":" 1#challenge</p>
<p class="p2"><span class="s3">HTTP</span>访问认证进程如<span class="s3">"HTTP</span>认证<span class="s3">:</span>基本和分类访问认证<span class="s3">"[43]</span>所描述<span class="s3">.</span>与<span class="s3">www</span>认证不同<span class="s3">,</span>代理认证的头域仅仅应用于当前连接<span class="s3">,</span>不应该转到下游客户<span class="s3">.</span>但是<span class="s3">,</span>中间代理可能需要向下游客户请求获得它自己的证书<span class="s3">,</span>有时候看起来这好像代理在转送代理认证头域<span class="s3">.</span></p>
<p class="p2"><span class="s3">14</span>．<span class="s3">34 </span>代理授权<span class="s2"><br>
</span>代理授权的请求头域允许客户将它自己<span class="s3">(</span>或的使用者<span class="s3">)</span>看作和需要认证的代理一样<span class="s3">.</span>代理授权的域值由包含用户代理对代理服务器的授权信息和正在被请求的资源界组成<span class="s3">. [</span>译者注<span class="s3">]realm:</span>数据库中的一种逻辑子域，它包含了有约定的数据的聚集的全部<span class="s3">(</span>具体<span class="s3">)</span>值<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">       Proxy-Authorization     = "Proxy-Authorization" ":" credentials</span></p>
<p class="p2"><span class="s3">HTTP</span>访问认证进程如<span class="s3">"HTTP</span>认证<span class="s3">:</span>基本和分类访问认证<span class="s3">"[43]</span>所描述<span class="s3">.</span>与授权不同<span class="s3">,</span>代理授权的头域仅仅应用于下一个需要认证的外地代理<span class="s3">,</span>用的是代理认证域<span class="s3">.</span>当多个代理在链中使用时<span class="s3">,</span>代理授权的头域由第一个期待收到证书的外地代理消耗<span class="s3">.</span>代理可以从客户请求向下一个代理转发证书<span class="s3">,</span>如果那是代理协同认证给定请求的机制<span class="s3">.</span></p>
<p class="p2"><span class="s3">14</span>．<span class="s3">35 </span>范围<span class="s2"><br>
</span><span class="s3">14.35.1 </span>字节范围<span class="s2"><br>
</span>既然所有的<span class="s3">HTTP</span>实体都以字节序列形式的<span class="s3">HTTP</span>消息表示<span class="s3">,</span>字节范围的概念对任何<span class="s3">HTTP</span>实体都是有意义的<span class="s3">.(</span>不过并不是所有的客户和服务器都需要支持字节范围操作<span class="s3">.</span></p>
<p class="p2"><span class="s3">HTTP</span>里字节范围的详述应用于实体正文<span class="s3">(</span>不必和消息体一样<span class="s3">)</span>的字节序列<span class="s3">.</span></p>
<p class="p2">一个字节范围操作可以确定字节的单一范围<span class="s3">,</span>或一个单一实体里的一组范围<span class="s3">.</span></p>
<p class="p1">       ranges-specifier = byte-ranges-specifier<span class="s2"><br>
</span>       byte-ranges-specifier = bytes-unit "=" byte-range-set<span class="s2"><br>
</span>       byte-range-set  = 1#( byte-range-spec | suffix-byte-range-spec )<span class="s2"><br>
</span>       byte-range-spec = first-byte-pos "-" [last-byte-pos]<span class="s2"><br>
</span>       first-byte-pos  = 1*DIGIT<span class="s2"><br>
</span>       last-byte-pos   = 1*DIGIT</p>
<p class="p1">Byte-range-spec<span class="s1">里的</span>First-byte-pos<span class="s1">值给出了一个范围里第一个字节的偏移量</span>.<span class="s2"><br>
</span>last-byte-pos<span class="s1">值给出了这个范围里最后一个字节的偏移量</span>;<span class="s1">也就是说</span>,<span class="s1">确定的字节位置包含在内</span>.<span class="s1">字节偏移量初始值为零</span>.<span class="s2"><br>
</span><span class="s1">如果存在</span>last-byte-pos<span class="s1">值</span>,<span class="s1">它一定大于或等于那个</span>byte-range-spec<span class="s1">里的</span><span class="s2"><br>
</span>first-byte-pos,<span class="s1">否则</span>byte-range-spec<span class="s1">在句法上是非法的</span>.<span class="s1">接收者收到包括一个或更多句法非法的</span>byte-range-spec<span class="s1">值的</span>byte-range-set<span class="s1">时必须忽略包括那个</span>byte-range-set<span class="s1">的头域</span>.</p>
<p class="p2">如果<span class="s3">last-byte-pos</span>值不存在<span class="s3">,</span>或者大于或等于实体正文的当前长度<span class="s3">,</span>则认为<span class="s2"><br>
</span><span class="s3">last-byte-pos</span>等同于一个字节数少于实体正文当前长度的<span class="s3">last-byte-pos.</span></p>
<p class="p2">通过选择<span class="s3">last-byte-pos,</span>客户能够限制检索字节的数量而不必知道实体的大小<span class="s3">.</span></p>
<p class="p2"><span class="s3">suffix-byte-range-spec</span>用来表示实体正文的后缀<span class="s3">,</span>其长度由后缀长度值给出<span class="s3">.(</span>也就是说<span class="s3">,</span>这种形式规定了实体正文的最后<span class="s3">N</span>个字节<span class="s3">.)</span>如果实体短于确定的后缀长度<span class="s3">,</span>则使用整个实体正文<span class="s3">.</span></p>
<p class="p1"><span class="s1">如果一个句法正确的</span>byte-range-set<span class="s1">至少包括一个这样的</span>byte-range-spec:<span class="s1">它的</span><span class="s2"><br>
</span>first-byte-pos<span class="s1">比实体正文的当前长度小</span>,<span class="s1">或至少包括一个后缀长度非零的</span><span class="s2"><br>
</span>suffix-byte-range-spec,<span class="s1">那么</span>byte-range-set<span class="s1">是可以满足的</span>.<span class="s1">否则是不可满足的</span>.</p>
<p class="p2">如果<span class="s3">byte-range-set</span>是不可满足的<span class="s3">,</span>服务器应该返回一个带有<span class="s3">206</span>状态<span class="s3">(</span>局部内容<span class="s3">)</span>的响应<span class="s3">,</span>其中包括实体正文的可满足范围<span class="s3">.</span><span class="s2"><br>
</span><span class="s3">byte-ranges-specifier(</span>字节<span class="s3">-</span>范围<span class="s3">-</span>说明符<span class="s3">)</span>值的例子<span class="s3">(</span>假定实体正文长度为<span class="s3">10000):</span></p>
<p class="p1">-- <span class="s1">第一个</span>500<span class="s1">字节</span>(<span class="s1">字节偏移量</span>0-499,<span class="s1">包括</span>0<span class="s1">和</span>499):<span class="s2"><br>
</span>bytes=0-499</p>
<p class="p1">-- <span class="s1">第二个</span>500<span class="s1">字节</span>(<span class="s1">字节偏移量</span>500-999,<span class="s1">包括</span>500<span class="s1">和</span>999):<span class="s2"><br>
</span>bytes=500-999</p>
<p class="p1">-- <span class="s1">最后</span>500<span class="s1">字节</span>(<span class="s1">字节偏移量</span>9500-9999,<span class="s1">包括</span>9500<span class="s1">和</span>9999):<span class="s2"><br>
</span>      bytes=-500 <span class="s1">或</span> bytes=9500-</p>
<p class="p1">-- <span class="s1">仅仅第一个和最后一个字节</span>(<span class="s1">字节</span>0<span class="s1">和</span>9999):<span class="s2"><br>
</span>bytes=0-0,-1 </p>
<p class="p1">-- <span class="s1">关于第二个</span>500<span class="s1">字节</span>(<span class="s1">字节偏移量</span>500-999,<span class="s1">包括</span>500<span class="s1">和</span>999)<span class="s1">的几种合法但不规范的叙述</span>:<span class="s2"><br>
</span>         bytes=500-600,601-999<span class="s2"><br>
</span>         bytes=500-700,601-999</p>
<p class="p2"><span class="s3">14.35.2 </span>范围检索请求<span class="s2"><br>
</span><span class="s3">HTTP</span>检索请求使用有条件或无条件<span class="s3">GET</span>方法<span class="s3">,</span>可以利用范围请求头来请求实体的一个或更多子范围而不是整个实体<span class="s3">,</span>范围请求头部应用于作为请求结果返回的实体<span class="s3">.</span></p>
<p class="p1">     Range = "Range" ":" ranges-specifier</p>
<p class="p2">服务器可以忽落范围头<span class="s3">.</span>但是<span class="s3">,HTTP/1.1</span>源服务器和中间高速缓存应该在可能的时候支持字节范围<span class="s3">,</span>既然范围支持部分失败传输的有效恢复<span class="s3">,</span>并且支持对大实体的部分检索<span class="s3">.</span></p>
<p class="p2">如果服务器支持范围头和确定的范围<span class="s3">,</span>或范围对实体是合适的<span class="s3">:</span></p>
<p class="p2"><span class="s3">-- </span>如果<span class="s3">GET</span>是以别的方式成功的<span class="s3">,</span>无条件<span class="s3">GET</span>里范围头的存在修改返回的东西<span class="s3">.</span>换句话说<span class="s3">,</span>响应携带的是状态代码<span class="s3">206(</span>部分内容<span class="s3">)</span>而不是<span class="s3">200(</span>好<span class="s3">).</span></p>
<p class="p1">-- <span class="s1">如果</span>GET<span class="s1">以别的方式成功且条件为真</span>,<span class="s1">有条件</span>GET(<span class="s1">一种使用</span>If-Modified-Since<span class="s1">和</span>If-None-Match<span class="s1">二者之一或全部</span>,<span class="s1">或者</span>If-Unmodified-Since<span class="s1">和</span>If-Match<span class="s1">二者之一或全部的请求</span>)<span class="s1">里范围头的存在修改返回的东西</span>.<span class="s1">它并不影响返回的</span>304(<span class="s1">未修改</span>)<span class="s1">响应</span>,<span class="s1">如果条件为假</span>.</p>
<p class="p1"><span class="s1">某些情形下</span>,<span class="s1">使用</span>Range header(<span class="s1">范围头</span>)<span class="s1">辅以</span>If-Range header(<span class="s1">假设范围头</span>)<span class="s1">可能更合适</span>.</p>
<p class="p2">如果支持范围的代理收到范围请求<span class="s3">,</span>将请求转发到本地服务器<span class="s3">,</span>以及收到回复的整个实体<span class="s3">,</span>它应该只把请求的范围返回给客户<span class="s3">.</span>它应该将接收到的整个响应存储在高速缓存中<span class="s3">,</span>如果这跟它的高速缓存分配方针一致的话<span class="s3">.</span></p>
<p class="p2"><span class="s3">14</span>．<span class="s3">36 </span>参考者（<span class="s3">Referer</span>）<span class="s2"><br>
</span>参考者（<span class="s3">Referer</span>）请求头域允许客户确定获得请求<span class="s3">URI</span>的资源地址<span class="s3">(URI)-</span>为了服务器的利益<span class="s3">.Referer</span>请求头允许服务器生成关于到资源的反向连接<span class="s3">(back-link)</span>的列表<span class="s3">,</span>为了兴趣<span class="s3">,</span>记录<span class="s3">,</span>优化的高速缓存等等<span class="s3">.</span>它也允许追踪过时的或错误类型的连接<span class="s3">(link)</span>以便维护<span class="s3">.</span>如果请求<span class="s3">URI</span>是从一个没有自己的<span class="s3">URI</span>的源获得的<span class="s3">,</span>如从使用者键盘的输入<span class="s3">,</span>那么一定不要发送<span class="s3">Referer</span>域<span class="s3">.</span></p>
<p class="p1">       Referer        = "Referer" ":" ( absoluteURI | relativeURI )</p>
<p class="p1">  <span class="s1">例如</span>:</p>
<p class="p1">       Referer: <a href="http://www.w3.org/hypertext/DataSources/Overview.html">http://www.w3.org/hypertext/DataSources/Overview.html</a></p>
<p class="p2">如果域值是相对<span class="s3">URI,</span>它应该理解为与请求<span class="s3">URI</span>相关<span class="s3">.URI</span>一定不能包括片断<span class="s3">.<a href="http://www.cnpaf.net/class/security/"><span class="s1">安全</span></a></span>考虑请参看<span class="s3">15.1.3</span>节<span class="s3">.</span></p>
<p class="p2"><span class="s3">14</span>．<span class="s3">37 </span>稍后重试<span class="s2"><br>
</span>稍后重试应答报头域可以和<span class="s3">503</span>（服务不可达）应答一起使用，以指示服务对于发出请求的客户机而言预计有多久不可达。本域也可与任何<span class="s3">3xx</span>（重新定向）应答一起用于指示用户代理在重定向请求前被要求等待的最小时间。本域的值可以是应答时间只有的<span class="s3">HTTP-</span>日期或整值的秒数（十进制）。</p>
<p class="p1"><span class="s1">稍后重试</span>=“<span class="s1">稍后重试</span>”“<span class="s1">：</span>”<span class="s1">（</span>HTTP-<span class="s1">日期</span>|delta-<span class="s1">秒）</span></p>
<p class="p2">应用的例子有二：</p>
<p class="p2">稍后重试：星期五，<span class="s3">1999</span>年<span class="s3">12</span>月<span class="s3">31 23:59:59 </span>格林威治时间<span class="s2"><br>
</span>稍后重试：<span class="s3">120</span></p>
<p class="p2">在后一例中，延迟时间为<span class="s3">2</span>分钟。</p>
<p class="p1">14<span class="s1">．</span>38 <span class="s1">服务器</span></p>
<p class="p2">服务器应答报头域包含了原服务器用于处理请求的软件信息。<span class="s3"> </span>此域可包含多个产品标记（<span class="s3">3</span>。<span class="s3">8</span>节），以及鉴别服务器与其他重要亚产品的注释。产品标记按它们对于鉴别应用程序的重要性的顺序排列。<span class="s2"><br>
</span>服务器<span class="s3">=“</span>服务器<span class="s3">”</span>：<span class="s3">“1*</span>（产品<span class="s3">|</span>注释）<span class="s2"><br>
</span>例：</p>
<p class="p1"><span class="s1">服务器：</span>CERN/3<span class="s1">。</span>0 libwww/2.17</p>
<p class="p2">若应答是通过代理服务器转发的，则代理程序不得修改服务器应答报头域。作为替代，它应添入路由（<span class="s3">Via</span>）报头（如<span class="s3">14</span>。<span class="s3">45</span>节定义）。<span class="s3"> </span><span class="s2"><br>
</span>注：揭示特定的软件版本可能会使服务器易于受到那些针对已知的软件<a href="http://www.cnpaf.net/class/security/">安全</a>漏洞的攻击。<span class="s3"> </span>建议服务器实现者将此域作为可设置项。</p>
<p class="p2"><span class="s3">14</span>．<span class="s3">39 TE</span><span class="s2"><br>
</span><span class="s3">TE</span>请求报头域指明了它愿意从应答中接收哪种扩展传输编码以及是否愿接收成块传输<span class="s3">-</span>代码中的<span class="s3">trailer</span>域。其值可由关键字<span class="s3">“trailers”</span>，由逗号隔开的含可选接收参数的扩展传输<span class="s3">-</span>代码列表组成。</p>
<p class="p1">       TE        = "TE" ":" #( t-codings )<span class="s2"><br>
</span>       t-codings = "trailers" | (<span class="s1">传输</span>-<span class="s1">扩展</span> [<span class="s1">接收</span>-<span class="s1">参数</span> ] )<span class="s2"><br>
</span><span class="s1">关键字</span>“trailers”<span class="s1">的存在表明客户机愿意接收如</span>3<span class="s1">。</span>6<span class="s1">。</span>1<span class="s1">节中定义的成块传输</span>-<span class="s1">代码中的</span>trailer<span class="s1">域。</span> <span class="s1">此关键字为传输</span>-<span class="s1">代码值而保留，但它本身不代表一种传输</span>-<span class="s1">代码。</span><span class="s2"><br>
</span><span class="s1">应用举例：</span><span class="s2"><br>
</span>       TE: deflate<span class="s2"><br>
</span>       TE:<span class="s2"><br>
</span>       TE: trailers, deflate;q=0.5<span class="s2"><br>
</span>TE<span class="s1">报头域仅适用于立即连接。所以无论何时</span>HTTP/1<span class="s1">。</span>1<span class="s1">消息中有</span>TE<span class="s1">，连接报头域（参见</span>14<span class="s1">。</span>10<span class="s1">节）中就必须提供关键字。</span><span class="s2"><br>
</span><span class="s1">服务器利用下述规则，依据</span>TE<span class="s1">域来裁定传输</span>-<span class="s1">代码是否可被接受：</span></p>
<p class="p2">如果关键字<span class="s3">“trailers”</span>在列，则成块传输<span class="s3">-</span>代码总被接受。<span class="s3"> </span>客户机已代表它自己与下游客户机指出愿接受成块应答中的<span class="s3">trailer</span>域。<span class="s3"> </span>这意味着，可能的话，客户机正申明要么所有下游客户机都愿接收转发应答中的<span class="s3">trailer</span>域，要么它将试图代表下游接收者暂存应答。<span class="s2"><br>
</span>注：<span class="s3">HTTP/1</span>。<span class="s3">1</span>并未定义任何限制块状应答大小，以保证客户机能够暂存整个应答的方法，<span class="s2"><br>
</span>若被检验的传输<span class="s3">-</span>代码在<span class="s3">TE</span>域中有列出，它就可被接受，除非伴有<span class="s3">qvalue</span>为<span class="s3">0</span>值（如<span class="s3">3</span>。<span class="s3">9</span>节定义，<span class="s3"> qvalue </span>的<span class="s3">0</span>值表示<span class="s3">“</span>不可接受<span class="s3">”</span>）。<span class="s2"><br>
</span>若多个传输<span class="s3">-</span>代码都是可接受的，则可接受传输<span class="s3">-</span>代码中<span class="s3">qvalue</span>值最高者优先。<span class="s3"> “</span>成块<span class="s3">”</span>传输<span class="s3">-</span>代码的<span class="s3">qvalue</span>值总是<span class="s3">1</span>。<span class="s2"><br>
</span>若<span class="s3">TE</span>报头域为空，或没有<span class="s3">TE</span>报头域，则仅有的传输<span class="s3">-</span>代码是<span class="s3">“</span>成块<span class="s3">”</span>。<span class="s3"> </span>无传输<span class="s3">-</span>代码的报文总是可接受的。</p>
<p class="p2"><span class="s2"><br>
</span><span class="s3">14</span>．<span class="s3">40 </span>追踪者（<span class="s3">Trailer</span>）<span class="s2"><br>
</span><span class="s3">Trailer</span>常规域值指示在<span class="s3">trailer</span>消息中有给定的头域设置，此消息用成块传输编码编码的。</p>
<p class="p1">                  Trailer  = "Trailer" ":" 1#field-name</p>
<p class="p2">一个<span class="s3">http/1.1</span>消息使用成块传输编码时要包括一个<span class="s3">trailer</span>头域，且其不能为空。这样才能让接收者知道<span class="s3">trailer</span>中期望得到哪个头域。<span class="s2"><br>
</span><span class="s3">  </span>如果没有<span class="s3">trailer</span>头域存在，<span class="s3">trailer</span>不能包括任何头域。在成块传输编码中用到的<span class="s3">trailer</span>域的限制看<span class="s3">3</span>。<span class="s3">6</span>。<span class="s3">1</span>节。<span class="s2"><br>
</span><span class="s3">  Trailer</span>头域中列出的消息头域必须不能包括下面的头域：</p>
<p class="p1">   <span class="s1">传输编码</span><span class="s2"><br>
</span>   <span class="s1">内容长度</span><span class="s2"><br>
</span>   Trailer</p>
<p class="p1">14<span class="s1">．</span>41 <span class="s1">传输</span>-<span class="s1">编码</span></p>
<p class="p2"><span class="s3">   </span>传输<span class="s3">-</span>编码常规头域指出为了在发送者和接收者之间<a href="http://www.cnpaf.net/class/security/">安全</a>的传输而应用了什么样类型的转换。它不同于内容代码，传输代码是消息而不是实体的属性。</p>
<p class="p1">       Transfer-Encoding       = "Transfer-Encoding" ":" 1#transfer-coding</p>
<p class="p2"><span class="s3">  </span>传输代码在<span class="s3">3</span>。<span class="s3">6</span>节中被定义了。一个例子是：</p>
<p class="p1">         Transfer-Encoding: chunked</p>
<p class="p2"><span class="s3">   </span>如果一个实体应用了多种编码，传输代码必须顺序列出应用的编码。关于代码参数的额外信息有其他的实体头域指定。许多旧的<span class="s3">http/1.0</span>应用程序不懂传输编码头。</p>
<p class="p1">14<span class="s1">．</span>42 <span class="s1">升级</span>(Upgrade)</p>
<p class="p2"><span class="s3">   </span>升级头域允许客户端指定它支持什么样的附加传输<a href="http://www.cnpaf.net/">协议</a>并想使用如果服务器发现选择这种<a href="http://www.cnpaf.net/">协议</a>是恰当的话。服务器必须用<span class="s3">101</span>（选择<a href="http://www.cnpaf.net/">协议</a>）升级头域来指示要选择那个<a href="http://www.cnpaf.net/">协议</a>。</p>
<p class="p1">   Upgrade        = "Upgrade" ":" 1#product</p>
<p class="p2">举个例子：</p>
<p class="p2"><span class="s3">   Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</span><span class="s2"><br>
</span>升级头域被用来规定一种简单的机制从<span class="s3">http/q.q</span>过渡到其他不同性质的<a href="http://www.cnpaf.net/">协议</a>。它允许客户发出它期望使用另一个<a href="http://www.cnpaf.net/">协议</a>，比如说稍后的更高版本的<span class="s3">http<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>，甚至当前的请求已经使用了<span class="s3">http/1.1<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>。通过允许客户端发出一个用更普通的<a href="http://www.cnpaf.net/">协议</a>的请求来指示服务器它想用更好的<a href="http://www.cnpaf.net/">协议</a>（这儿得更好的由服务器决定，可能是按照方法的自然性或被请求的资源）它减轻了两个不同性质的<a href="http://www.cnpaf.net/">协议</a>之间传输的困难。</p>
<p class="p2"><span class="s3">  </span>升级头域只被用来从存在的传输层<a href="http://www.cnpaf.net/">协议</a>之上选择应用层<a href="http://www.cnpaf.net/">协议</a>。升级不能被用来强迫一个<a href="http://www.cnpaf.net/">协议</a>的改变；它的接受和使用是由服务器自由决定的。<a href="http://www.cnpaf.net/">协议</a>变换后应用层的通讯的性能和本性是由新选择的<a href="http://www.cnpaf.net/">协议</a>决定的，虽然改变<a href="http://www.cnpaf.net/">协议</a>以后的第一个动作是包含升级头域的原来<span class="s3">http</span>请求的应答。</p>
<p class="p2"><span class="s3">  </span>升级头域只应用于直接连接，因此无论升级出现在<span class="s3">http/1.1</span>消息的是什么时候，升级的关键字都必须应用于连接的头域中。</p>
<p class="p2"><span class="s3">  </span>升级头域不能被用来指示选择不同连接中的<a href="http://www.cnpaf.net/">协议</a>。为这个目的，使用<span class="s3">301</span>，<span class="s3">302</span>，<span class="s3">303</span>重定位应答更合适。</p>
<p class="p2"><span class="s3">  </span>这个规范着定义了<span class="s3">http<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>的名字，它被在<span class="s3">3</span>。<span class="s3">1</span>节的<span class="s3">http</span>版本规则中定义的超文本传输<a href="http://www.cnpaf.net/">协议</a>家族使用。任何一个记号都可被用来做<a href="http://www.cnpaf.net/">协议</a>名字，然而，只有当客户端和服务器用同一个<a href="http://www.cnpaf.net/">协议</a>关联时才有用。</p>
<p class="p2"><span class="s3">14</span>．<span class="s3">43 </span>用户代理<span class="s2"><br>
</span><span class="s3">  </span>用户代理请求头包括发出请求的用户代理的信息。这是为了统计学的目的，跟踪违反<a href="http://www.cnpaf.net/">协议</a>，为了因特定用户代理的限制制作对应响应而自动识别用户代理。用户代理必须在请求中包括这个域。这个域包括多个指明代理和构成代理的重要组件的产品标记和元素。按惯例，这些产品标记按指明应用程序的重要性的顺序排列。</p>
<p class="p1">      User-Agent     = "User-Agent" ":" 1*( product | comment )</p>
<p class="p2">例子<span class="s3">:</span></p>
<p class="p1">       User-Agent: CERN-LineMode/2.15 libwww/2.17b3</p>
<p class="p2"><span class="s3">14</span>．<span class="s3">44 </span>更正<span class="s3">(Vary)</span><span class="s2"><br>
</span><span class="s3">  </span>更正头域是在响应开始的时候变更完全接收的请求头域设置，而不管高速缓存是否允许用响应回复后续的请求。对于非高速缓存或者旧的响应，更正头域值建议用户代理用来选择请求的标准。</p>
<p class="p2"><span class="s3">  </span>一个为<span class="s3">“*”</span>的更正域意味着高速缓存不能根据后来的请求的请求头判断而不管这个请求是否是恰当请求。高速缓存对更正头域的用法间<span class="s3">13</span>。<span class="s3">6</span>节。</p>
<p class="p1">   Vary  = "Vary" ":" ( "*" | 1#field-name )</p>
<p class="p2"><span class="s3">  </span>一个<span class="s3">HTTP/1.1</span>的服务器的任何能缓存的响应必须包括一个更正头域，这是服务器驱动商议的科目。这样做高速缓存呢能恰当的解释下一个关于那个资源的请求同时通知用户代理需要对那个资源商议。一个服务器可以在非缓存的响应中包括更正头域，这是服务器驱动商议的科目，既然这可以提供用户代理在响应的时候响应的变化的有用信息。</p>
<p class="p2"><span class="s3">  </span>一个更正头域由一张头域的表组成，响应按一个选择的法则从其中选出，这个法则在选择最恰当的响应的时候只考虑列出的请求头域。一个高速缓存会假定下一个请求的选择会和列出的头域的值一样。</p>
<p class="p2"><span class="s3">  </span>此给定头域的名字不受这个说明书定义的标准请求头域的规范所限制。域名是对缓存不敏感的。</p>
<p class="p2"><span class="s3">  </span>一个值为没有定义的<span class="s3">“*”</span>表明对请求头没有限制（例如，网络客户端的地址），作为选择响应表述的规则。<span class="s3">“*”</span>值一定不能由代理服务器产生；它只可以由源服务器产生。</p>
<p class="p1">14<span class="s1">．</span>45 <span class="s1">路由（</span>Via<span class="s1">）</span></p>
<p class="p2"><span class="s3">  </span>路有常规头域必须被网关和代理服务起来指示中间的<a href="http://www.cnpaf.net/">协议</a>和关于请求的使用者和服务器之间的接收者及应答的原服务器和<span class="s2"><br>
</span>客户端的接收者。它类似于<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 822[9]</span>的接收域，被用来跟踪消息的去向，避免请求循环，及识别沿请求<span class="s3">/</span>应答链个发送者<a href="http://www.cnpaf.net/">协议</a>的性能。</p>
<p class="p1">      Via =  "Via" ":" 1#( received-protocol received-by [ comment ] )<span class="s2"><br>
</span>      received-protocol = [ protocol-name "/" ] protocol-version<span class="s2"><br>
</span>      protocol-name     = token<span class="s2"><br>
</span>      protocol-version  = token<span class="s2"><br>
</span>      received-by       = ( host [ ":" port ] ) | pseudonym<span class="s2"><br>
</span>      pseudonym         = token</p>
<p class="p2"><span class="s3">  </span>接收<a href="http://www.cnpaf.net/">协议</a>指出沿请求<span class="s3">/</span>应答链的每一段后被服务器或客户端接收到的消息的版本。接收<a href="http://www.cnpaf.net/">协议</a>的版本被加到路由域值中，因此对于所有的接收者来说以前的所有应用程序的<a href="http://www.cnpaf.net/">协议</a>能力的信息都保留了。</p>
<p class="p2"><span class="s3">  <a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>的名字是可以选择的，只要也只有它是<span class="s3">HTTP</span>。接收到的域一般是通常的主机和接收服务器或客户端的可选择的端口，然而，如果真实的主机考虑信息的敏感性，它可能会用假名代替，如果没有指明端口，它被假设成接收<a href="http://www.cnpaf.net/">协议</a>的默认端口。<span class="s2"><br>
</span>多重路由域值应答传递消息中的每一个代理或网关。每一个接收者必须添加上自己的信息，这样结果依照传递的应用程序的顺序范围。</p>
<p class="p2"><span class="s3">  </span>路由头域可能会使用注释来识别接收的代理或网关的软件，用户代理和服务器头域也是如此。然而，所有的路由头域中的注释是可选的，它可以被任何接收的代理服务器删掉。</p>
<p class="p2"><span class="s3">  </span>举个例子，一个<span class="s3">http/1.0</span>的用户代理发送一个叫<span class="s3">fred</span>的请求消息给国内的代理，它使用<span class="s3">http/1.1</span>来传递请求给在<span class="s3">nowhere.com</span>的公共代理，它把这个请求传递给在<span class="s3">wwwlics.uci.edu</span>的原服务器。这个请求被<a href="http://www.ics.uci.edu/"><span class="s3">www.ics.uci.edu</span></a>收到的时候应该有以下的路由头域：</p>
<p class="p1">  Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</p>
<p class="p2"><span class="s3">  </span>代理和网关被作为一个通过防火墙的入口，在默认情况下，它不能传递防火墙内的主机的名字和端口。这个信息只有在明确允许下才能传播。如果不允许的话，任何在防火墙后面的主机将被用假名代替。</p>
<p class="p2"><span class="s3">  </span>对于那些要求很强的隐藏内部结构的需求的机构，一个代理可以把有顺序的路由头域和同样的接收<a href="http://www.cnpaf.net/">协议</a>值组合在单个的条目中。举个例子：</p>
<p class="p1">       Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy<span class="s2"><br>
</span>        <span class="s1">可能退化为</span><span class="s2"><br>
</span>       Via: 1.0 ricky, 1.1 mertz, 1.0 lucy</p>
<p class="p2"><span class="s3">  </span>应用程序不能把多个实体组合在一起除非他们都在同一个组织的控制之下同时主机已经用假名代替了。应用程序不能把不同接收<a href="http://www.cnpaf.net/">协议</a>值的实体组合在一起。</p>
<p class="p1">14<span class="s1">．</span>46 <span class="s1">警告</span>(Warning)</p>
<p class="p2"><span class="s3">  </span>警告常规头域被用来传递没有被回复的消息的状态或转变的信息。这个消息典型的应用是来警告一个消息实体正文的缓存操作或转换缺乏语义的透明性。</p>
<p class="p1">  <span class="s1">应答时警告头域按以下格式发送：</span><span class="s2"><br>
</span>       Warning    = "Warning" ":" 1#warning-value</p>
<p class="p1">       warning-value = warn-code SP warn-agent SP warn-text<span class="s2"><br>
</span>                                             [SP warn-date]</p>
<p class="p1">       warn-code  = 3DIGIT<span class="s2"><br>
</span>       warn-agent = ( host [ ":" port ] ) | pseudonym<span class="s2"><br>
</span>                       ; the name or pseudonym of the server adding<span class="s2"><br>
</span>                       ; the Warning header, for use in debugging<span class="s2"><br>
</span>       warn-text  = quoted-string<span class="s2"><br>
</span>       warn-date  = &lt;"&gt; HTTP-date &lt;"&gt;</p>
<p class="p2"><span class="s3">  </span>警告文本必须使用自然语言，对于接收应答的使用人来说它基本上时可理解的。这个决定可以基于任何可利用的知识，比如说缓存或使用者的位置，请求中的接收语言域，应答中的内容语言域，等等。默认的语言是英语，默认的属性设置是<span class="s3">ISO-8859-1</span>。</p>
<p class="p2"><span class="s3">  </span>如果属性设置不是使用<span class="s3">ISO-8859-1</span>，它必须按<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 2047[14]</span>中描述的在警告文本中指明。</p>
<p class="p2"><span class="s3">  </span>警告头一般能被应用于任何的消息，然而一些特殊的警告代码对于高速缓存是特殊的，只能应用于应答消息。新的警告头必须加到任何存在的警告头的后面。一个高速缓存一定不能删掉它接收到的消息的警告头域。然而，如果高速缓存成功的使高速缓存条目有效，它能把符合条目的警告头都删掉除了那些特殊的警告代码。它必须马上把它接收到的警告头域加到确认应答中。用其他华说，警告头实那些能附加于最近大多数应答的应答。</p>
<p class="p2"><span class="s3">  </span>当多个警告头附加于一个应答，用户代理必须按应答中显示的顺序尽可能多的通知使用者。如果不能通知所有警告的拥护，用户代理必须按这些<span class="s3">HEURISTICS</span>运作：</p>
<p class="p2"><span class="s3">  -</span>出现在应答中前面的警告从那些出现在后面手中接过优先权</p>
<p class="p2"><span class="s3">  -</span>符合用户首选性质设置的警告从其它使用相同的警告代码和警告代理但在其他性质设置的警告手中接过优先权。</p>
<p class="p2"><span class="s3">  </span>产生多个警告头的系统必须按用户代理的行为排列它们。<span class="s2"><br>
</span><span class="s3">  </span>对于注意警告的高速缓存的行为的要求在<span class="s3">13</span>。<span class="s3">1</span>。<span class="s3">2</span>节中规定。<span class="s2"><br>
</span><span class="s3">  </span>这是通常定义的警告代码的列表，每一个有推荐的英语的警告文本和它意思的描述。</p>
<p class="p2"><span class="s3">  110 </span>应答迟缓<span class="s2"><br>
</span><span class="s3">     </span>当回复应答迟缓的时候应用</p>
<p class="p2"><span class="s3">  111 </span>重新连接失败<span class="s2"><br>
</span><span class="s3">        </span>当试图重新连接失败高速缓存返回一个迟缓应答，原因是服务器不可达。</p>
<p class="p2"><span class="s3">  112 </span>分离操作<span class="s2"><br>
</span><span class="s3">        </span>当高速缓存要有意从其它的网络中分离一段时间。</p>
<p class="p2"><span class="s3">  113 </span>探索终止<span class="s2"><br>
</span><span class="s3">           </span>高速缓存要选择保鲜的。生存期大于<span class="s3">24</span>小时，应答年龄大于<span class="s3">24</span>小时。</p>
<p class="p2"><span class="s3">  199 </span>混合警告<span class="s2"><br>
</span><span class="s3">          </span>警告文本可以包括只能给使用人看的信息。一个系统收到这样的警告必须给使用者看而不能自动处理。</p>
<p class="p2"><span class="s3">  214 </span>转变被应用了<span class="s2"><br>
</span><span class="s3">          </span>如果中间高速缓存或代理的任何应答的内容编码（如在内容编码头中指定的）或媒体类型（如在内容类型头指定的）或实体正文被改变了则这个警告必须被添加上去，除非这个警告代码已经出现在应答中。<span class="s2"><br>
</span><span class="s3">  </span><span class="s2"><br>
</span><span class="s3">  299 </span>持久混合警告<span class="s2"><br>
</span><span class="s3">          </span>警告文本可以包括只能给使用人看的信息。一个系统收到这样的警告一定不能自动处理。</p>
<p class="p2"><span class="s3">  </span>如果一个实现用<span class="s3">http/1.0</span>或更低的版本发送了一个又一个或多个警告头的消息，发送者必须包括和应答中匹配的每一个警告值和警告数据。</p>
<p class="p2"><span class="s3">  </span>如果一个实现收到一条报文，在这条报文中警告值包括一个警告数据，这个警告数据和行营中的数据值不同，那么这个警告值必须在储藏，传递或使用以前从这条消息中删掉。这可防止错误储存警告头域）如果因为这个原因所有的警告制度被删掉了，则这个警告头也应该被删掉。</p>
<p class="p2"><span class="s3">14</span>．<span class="s3">47 WWW-</span>认证<span class="s2"><br>
</span><span class="s3">401</span>（未授权的）应答报文中必须含有<span class="s3">WWW-</span>认证应答报头域。<span class="s3"> </span>域值至少包括一个指明了可应用于请求<span class="s3">-URI</span>的认证方案与参数的挑战（<span class="s3">challenge</span>）<span class="s3">.</span></p>
<p class="p1">WWW-<span class="s1">认证</span>=“WWW-<span class="s1">认证</span>”“<span class="s1">：</span>”1#<span class="s1">挑战</span></p>
<p class="p2"><span class="s3">HTTP</span>访问认证过程在<span class="s3">“HTTP</span>认证：基本与摘要访问认证<span class="s3">”[43]</span>中有所描述。<span class="s2"><br>
</span>建议用户代理尤其谨慎地解析<span class="s3">WWW-</span>认证域值，因为它可能含多个挑战，或在有多个<span class="s3">WWW-</span>认证报头域的情况下挑战内容本身即含有由逗号隔开的认证参数列表。</p>
<p class="p2"><span class="s3">15</span>．<a href="http://www.cnpaf.net/class/security/">安全</a>考虑</p>
<p class="p2"><span class="s3">    </span>这一部分是用来提醒程序开发人员，信息提供者，和<span class="s3">HTTP/1.1</span>中的<a href="http://www.cnpaf.net/class/security/">安全</a>限制的用户这篇文档所叙述的事情。虽然这个讨论为减少<a href="http://www.cnpaf.net/class/security/">安全</a>风险确实提供了一些建议，但是它并不包括所透露问题的最终解决方案。</p>
<p class="p2"><span class="s3">15</span>．<span class="s3">1 </span>个人信息</p>
<p class="p2"><span class="s3">    HTTP</span>的客户机经常对大量的个人信息是敏感的（例如用户的名字，域，邮件地址，口令，密匙等。），并且应当（<span class="s3">SHOULD</span>）非常小心地防止这些信息无意识地通过<span class="s3">HTTP</span>泄露到其他的主机。我们非常强烈地建议应该提供给用户一个方便的界面来控制这种信息的分发，并且设计者和使用者在这方面应该特别注意。历史告诉我们在这方面的错误经常引起严重的<a href="http://www.cnpaf.net/class/security/">安全</a>和<span class="s3">/</span>或者机要问题并导致出现对使用者的公司非常不利的公开的情况。</p>
<p class="p2"><span class="s3">15.1.1</span>服务器日志信息的滥用</p>
<p class="p2"><span class="s3">    </span>服务器是处在存储个人数据的位置上，这些数据是关于用户的请求的<span class="s3">,</span>这些请求可以识别他们的阅读习惯或者感兴趣的主题。自然这种信息明显是机要的并且在某些国家对它的处理是受限制的。使用<span class="s3">HTTP<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>提供数据的人们有责任确保这样的材料不会在没有得到任何公开结果确认的人允许的情况下被散布出去。</p>
<p class="p2"><span class="s3">15.1.2</span>敏感信息的传输</p>
<p class="p2"><span class="s3">    </span>就像任何种类的数据传输<a href="http://www.cnpaf.net/">协议</a>一样，<span class="s3">HTTP</span>不能控制被传输数据的内容，也没有任何一种区分的方法来决定在任何给定请求的上下文中某个特别的信息片段的敏感性。因此，应用程序应该（<span class="s3">SHOULD</span>）提供给发布信息的人尽可能多的对这个信息的控制能力。四个报头域是值得在这段文字中特别提到的：<span class="s3">Server</span>，<span class="s3">Via</span>，<span class="s3">Referer</span>和<span class="s3">From</span>。</p>
<p class="p2"><span class="s3">    </span>暴露服务器详细的软件版本信息可能会导致服务器因为已知有<a href="http://www.cnpaf.net/class/security/">安全</a>漏洞的软件而变得更易受到攻击。开发人员应该（<span class="s3">SHOULD</span>）使<span class="s3">Server</span>报头域是一个可配置的选项。<span class="s2"><br>
</span><span class="s3">    </span><span class="s2"><br>
</span><span class="s3">    </span>作为通过一个网络防火墙的入口的代理服务器应该（<span class="s3">SHOULD</span>）对关于确认防火墙后面的主机的报头信息的传输采取特别的防范。特别的，它们应当移走或者用清洁的版本代替，<span class="s3">Via</span>域在放火墙后面产生。</p>
<p class="p2"><span class="s3">    Referer</span>报头允许学习的阅读模式并且可以进行反向连接。虽然它非常有用，但是如果用户的资料没有从<span class="s3">Referer</span>包括的信息中分离出来的话它的能力就可能会被滥用。甚至当信息已经被移开，<span class="s3">Referer</span>报头还是可能指示出一个不适于公开的私人文档的<span class="s3">URI</span>。</p>
<p class="p2"><span class="s3">    </span>在<span class="s3">From</span>域发送的信息可能和用户的个人利益或者他们站点的<a href="http://www.cnpaf.net/class/security/">安全</a>政策相抵触，因此用户如果不能使之失效，对其授权，和修改域的内容的话，它就不应该（<span class="s3">SHOULD NOT</span>）被传输。用户必须（<span class="s3">MUST</span>）能够按用户的选择或者应用程序的缺省配置设置这个域的内容。</p>
<p class="p2"><span class="s3">    </span>虽然并不是必须的，我们建议向用户提供一个可以选择允许或者禁止<span class="s3">From</span>和<span class="s3">Referer</span>信息的发送的方便捆绑界面。</p>
<p class="p2"><span class="s3">    </span>用户代理（<span class="s3">14.43</span>节）或者服务器（<span class="s3">14.38</span>节）的报头域有时候会被用来判断某个特定的客户机或者服务器有一个可以被利用的特别的<a href="http://www.cnpaf.net/class/security/">安全</a>漏洞。不幸的是同样的信息经常被用作其它有价值的目的因为<span class="s3">HTTP</span>现在没有更好的机制。</p>
<p class="p1">15.1.3 URI<span class="s1">中敏感信息的编码</span></p>
<p class="p2"><span class="s3">    </span>因为一个连接的源地址可能是机要的信息或者可能会暴露另外一个机要的信息源，所以强烈推荐用户能够选择是否发送<span class="s3">Referer</span>域。例如，一个浏览器的用户能够有一个捆绑的选择是公开<span class="s3">/</span>匿名浏览，这将会分别允许<span class="s3">/</span>禁止<span class="s3">Referer</span>和<span class="s3">From</span>信息的发送。</p>
<p class="p2"><span class="s3">    </span>如果目标页使用<a href="http://www.cnpaf.net/class/security/">安全</a>的<a href="http://www.cnpaf.net/">协议</a>传输的话，在一个（不<a href="http://www.cnpaf.net/class/security/">安全</a>）<span class="s3">HTTP</span>请求中客户机不应该（<span class="s3">SHOULD NOT</span>）包括一个<span class="s3">Referer</span>报头域。</p>
<p class="p2"><span class="s3">    </span>使用<span class="s3">HTTP<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>的服务提供者不应该（<span class="s3">SHOULD NOT</span>）使用基于使敏感数据屈服的形式的<span class="s3">GET</span>命令，因为这将导致在<span class="s3">Request-URI</span>中编码这个数据。许多现有的服务器，代理服务器，和用户代理将把请求<span class="s3">URI</span>日志记录在某个第三方可以看见的地方。服务器可以用基于屈服形式的<span class="s3">POST</span>代替。</p>
<p class="p1">15.1.4<span class="s1">连接到</span>Accept<span class="s1">报头的机要问题</span></p>
<p class="p2"><span class="s3">    </span>接受<span class="s3">request-header</span>可能暴露关于用户可以进入的所有服务器的信息。特别的<span class="s3">Accept-language</span>报头可能暴露用户个人的民族，因为对特殊语言的理解对特殊的同文化的民族的成员经常有很强的相关性。提供在每个请求中配置发送的<span class="s3">Accept-language</span>报头的选项的用户代理被坚定的鼓励让配置过程包括让用户明白有关机要泄露的信息。</p>
<p class="p2"><span class="s3">    </span>对于用户代理来说一种限制机要泄露的方法是在缺省的情况下忽略发送<span class="s3">Accept-language</span>包头，并且如果通过寻找任何由服务器发出的变化的<span class="s3">response-header</span>域，发现这样的发送能够提高服务的质量，就询问用户是否向服务器发送<span class="s3">Accept-language</span>报头。</p>
<p class="p2"><span class="s3">    </span>在每个<span class="s3">request</span>中发送的为用户精心制作的<span class="s3">accept</span>报头域，特别如果这些包括质量价值，能够被服务器用作相关地可信赖的和长久的用户标识符。这样的用户标识符将会允许内容提供者进行单击轨迹跟踪以及允许合作的内容提供者匹配交叉服务器单击轨迹或者形成单个用户的屈从。注意对于许多并不在代理服务器后面的用户，运行用户代理的主机的网络地址也将作为长久用户的标识符。在代理服务器被用作增强保密的环境里，用户代理在提供给终端用户<span class="s3">accept</span>报头配置选项上应该是保守的。作为一个保密的极端措施，代理服务器应该在转发请求信息的时候过滤<span class="s3">accept</span>报头。提供高度报头配置能力的一般用途的用户代理应该（<span class="s3">SHOULD</span>）警告用户可能涉及的机要泄漏。</p>
<p class="p2"><span class="s3">15</span>．<span class="s3">2 </span>基于文件和路径名称的攻击</p>
<p class="p2"><span class="s3">    </span>实现<span class="s3">HTTP</span>的原服务器应该（<span class="s3">SHOULD</span>）小心地限制由<span class="s3">HTTP</span>请求返回的文档仅仅是那些服务器<a href="http://www.cnpaf.net/class/Manage/">管理</a>员授权设置的。如果<span class="s3">HTTP</span>服务器直接把<span class="s3">HTTP URIs</span>翻译成文件的系统名称，服务器必须（<span class="s3">MUST</span>）特别注意不要提供没有授权发布给<span class="s3">HTTP</span>客户的文件。例如<span class="s3">UNIX</span>，微软<span class="s3">Windows</span>，和其它操作系统使用<span class="s3">".."</span>作为指示当前目录的上一层的路径的一部分。在这样一个系统中，如果不允许通过<span class="s3">HTTP</span>服务器访问那些除授权允许访问以外的资源的话，<span class="s3">HTTP</span>服务器就必须（<span class="s3">MUST</span>）禁止在<span class="s3">Request-URI</span>中任何这样的结构。同样的，必须（<span class="s3">MUST</span>）保护认为仅仅涉及服务器内部的文件（例如访问控制文件，配置文件，和剧本代码）不要被不适当的获取，因为它们可能包含敏感信息。经验表明在<span class="s3">HTTP</span>服务器这样的使用中次要的<span class="s3">bug</span>已经转变为威胁<a href="http://www.cnpaf.net/class/security/">安全</a>的风险。</p>
<p class="p1">15<span class="s1">．</span>3 <a href="http://www.cnpaf.net/class/dns/">DNS</a><span class="s1">欺骗</span></p>
<p class="p2"><span class="s3">    </span>客户使用<span class="s3">HTTP</span>严重依赖于域名服务，因此一般倾向基于故意不相关的<span class="s3">IP</span>地址和<a href="http://www.cnpaf.net/class/dns/"><span class="s3">DNS</span></a>名称的<a href="http://www.cnpaf.net/class/security/">安全</a>攻击。客户需要在假定一个<span class="s3">IP</span>号<span class="s3">/<a href="http://www.cnpaf.net/class/dns/">DNS</a></span>名称关联继续合法时谨慎。</p>
<p class="p2"><span class="s3">    </span>特别的，<span class="s3">HTTP</span>客户对于一个<span class="s3">IP</span>号<span class="s3">/<a href="http://www.cnpaf.net/class/dns/">DNS</a></span>名称关联的确认应该（<span class="s3">SHOULD</span>）依靠对它们名字的解析，而不是存在高速缓存中以前主机名解析查找的结果。在适当的时候并且他们应该（<span class="s3">SHOULD</span>）被设置成这样做的时候，许多论坛已经能够在本地用高速缓存存储主机名。只有当域名服务器报告的<span class="s3">TTL</span>（现在时刻）信息使高速缓存里的信息很可能仍然是有用的时候，对这些高速缓存的查询才是适当的。</p>
<p class="p2"><span class="s3">    </span>如果<span class="s3">HTTP</span>客户为了达到提高性能的目的把查询到的主机名结果存在高速缓存中，他们必须（<span class="s3">MUST</span>）遵守域名服务器报告的<span class="s3">TTL</span>信息。</p>
<p class="p2"><span class="s3">    </span>如果<span class="s3">HTTP</span>客户不遵守这个规则，在一个以前访问过的服务器的<span class="s3">IP</span>地址改变的时候他们就会被欺骗。在网络重新编号被认为变得日益普遍的时候，这种形式的攻击的可能性将会增大。遵守这个必要条件将会因此减少这种潜在的<a href="http://www.cnpaf.net/class/security/">安全</a>隐患。</p>
<p class="p2"><span class="s3">    </span>这个必要条件也改进了客户机对使用同样域名的镜像服务器的平衡加载行为并且减少了用户访问使用这种策略的站点经历失败的可能性。</p>
<p class="p1">15<span class="s1">．</span>4 Location<span class="s1">（位置）报头和欺骗</span></p>
<p class="p2"><span class="s3">    </span>如果单个的服务器支持互不信任的多个组织，那么它必须（<span class="s3">MUST</span>）检查在自称的某个组织控制下产生的应答信息中<span class="s3">Location</span>和<span class="s3">Content-Location</span>报头的值以确认他们没有企图使他们没有权限的资源无效。</p>
<p class="p1">15<span class="s1">．</span>5 <span class="s1">内容倾向问题（</span>Content-Disposition Issues<span class="s1">）</span><span class="s2"><br>
</span>    <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 1806 [35]<span class="s1">，在</span>HTTP<span class="s1">中经常使用的</span>Content-Disposition<span class="s1">（见</span>19.5.1<span class="s1">节</span>)<span class="s1">报头就源于此，有许多非常认真的<a href="http://www.cnpaf.net/class/security/">安全</a>考虑。</span>Content-Disposition<span class="s1">并不是</span>HTTP<span class="s1">标准版本中的一部分，但自从它被广泛应用以来，我们正在证明它对使用者的价值和风险。详细资料见<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a></span> 2183 [49]<span class="s1">（对<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a></span> 1806<span class="s1">的升级）。</span></p>
<p class="p2"><span class="s3">15</span>．<span class="s3">6 </span>鉴定证书和空闲的客户机</p>
<p class="p2"><span class="s3">    </span>现有的<span class="s3">HTTP</span>客户机和用户代理有代表性地不确定地保留鉴定信息。<span class="s3">HTTP/1.1</span>没有提供一个从服务器到直接的客户机的方法来丢弃这些保存在高速缓存里的证书。这是一个重大的需要对<span class="s3">HTTP</span>做进一步扩展的的缺点。在高速缓存里的证书可能干扰应用程序的<a href="http://www.cnpaf.net/class/security/">安全</a>模式的情况包括但不只限于：</p>
<p class="p2"><span class="s3">    --</span>客户机已经空闲了很长时间，然后服务器可能希望引起客户机再一次出示用户的证书。</p>
<p class="p2"><span class="s3">    --</span>应用程序包括了一个进程中断的指令（例如在一页上有<span class="s3">"logout"</span>或者<span class="s3">"commit"</span>的按钮），在此之后应用程序的服务器方面<span class="s3">"</span>知道<span class="s3">"</span>客户机没有进一步的理由保留证书。</p>
<p class="p2"><span class="s3">    </span>这是当前分散考虑的情况下。这个问题的各部分有许多的工作区，我们鼓励在屏保程序中使用密码保护，空闲暂停，以及其它在这个问题中减轻固有<a href="http://www.cnpaf.net/class/security/">安全</a>问题的方法。特别的，在高速缓存中保存证书的用户代理被鼓励提供一个在用户控制下丢弃保存在高速缓存中的证书的可以容易访问的机制。</p>
<p class="p2"><span class="s3">15</span>．<span class="s3">7 </span>代理服务器和高速缓存</p>
<p class="p2"><span class="s3">    HTTP</span>代理是中间人，并且扮演一个<span class="s3">"</span>中间者<span class="s3">"</span>攻击的目标。代理运行系统的妥协可能导致严重的<a href="http://www.cnpaf.net/class/security/">安全</a>和保密问题。代理有权访问与<a href="http://www.cnpaf.net/class/security/">安全</a>相关的信息，关于个人用户和组织的私人信息，属于用户和内容提供者的所有权信息。一个不<a href="http://www.cnpaf.net/class/security/">安全</a>的代理，或者一个使用或配置没有注意<a href="http://www.cnpaf.net/class/security/">安全</a>和保密考虑的代理，可能被用作广泛的潜在攻击的代理。</p>
<p class="p2"><span class="s3">    </span>代理服务器的<a href="http://www.cnpaf.net/class/Manage/">管理</a>员应当保护代理服务器上运行的系统就像他们保护包括或者传递敏感信息的任何系统一样。特别的，在代理上聚集的日志信息经常包括高度敏感的个人信息，和<span class="s3">/</span>或者关于组织的信息。日志信息应该被小心地保护，并且对发展的和接下来的使用持适当的指导方针。<span class="s3">(15.1.1</span>节<span class="s3">)</span></p>
<p class="p2"><span class="s3">    </span>高速缓存代理给其它潜在的攻击提供了机会，因为高速缓存的内容对于恶意利用是一个有吸引力的目标。因为当一个<span class="s3">HTTP</span>请求完成以后高速缓存的内容仍然存在，对高速缓存的攻击能揭示很早以前用户就认为已经从网络上移走的信息。因此，高速缓存的内容应该当作敏感信息保护。</p>
<p class="p2"><span class="s3">    </span>代理服务器的设计者应当考虑他们的设计和编码的制定，以及他们提供给代理服务器操作人员的配置选项（尤其是缺省配置）所牵涉到的保密和<a href="http://www.cnpaf.net/class/security/">安全</a>问题。</p>
<p class="p2"><span class="s3">    </span>代理服务器的用户必须明白他们并不比<a href="http://www.cnpaf.net/class/Manage/">管理</a>代理服务器的人更值得信任；<span class="s3">HTTP</span>自己不能解决这个问题。</p>
<p class="p2"><span class="s3">    </span>在适当的时候明智的使用密码系统可以提供足够的保护免遭广泛的针对<a href="http://www.cnpaf.net/class/security/">安全</a>和保密的攻击。这种密码系统超出了<span class="s3">HTTP/1.1</span>规范的范围。</p>
<p class="p2"><span class="s3">15.7.1 </span>对代理服务器的拒绝服务攻击</p>
<p class="p2"><span class="s3">    </span>它们是存在的。它们很难防御。研究在继续。当心。</p>
<p class="p1">16 <span class="s1">感谢（</span>Acknowledgment)</p>
<p class="p2"><span class="s3">    </span>这份规范大量使用了扩展<span class="s3">BNF</span>和<span class="s3">David</span>为<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 822 [9]</span>定义的类的结构。同样的，它继续使用了很多<span class="s3">Nathaniel Borenestein</span>和<span class="s3">Ned Freed</span>为<span class="s3">MIME [7]</span>提供的定义。我们希望在这份规范里它们包含的内容有助于减少过去在<span class="s3">HTTP</span>和互联网邮件消息格式关系上的混乱。</p>
<p class="p1">    HTTP<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a><span class="s1">在这几年已经有了相当的发展。它受益域大量积极的开发人员的团体</span>--<span class="s1">许多人已经通过利用邮件列表的万维网交谈来分担工作</span>--<span class="s1">并且通常就是团体对</span>HTTP<span class="s1">和万维网的成功负担了其中大多数的责任。</span> Marc Andreessen, Robert  Cailliau, Daniel W. Connolly, Bob Denny, John Franks, Jean-Francois Groff , Phillip M. Hallam-Baker, Hakon W. Lie, Ari Luotonen, Rob McCool, Lou Montulli, Dave Raggett, Tony Sanders, <span class="s1">和</span> Marc VanHeyningen<span class="s1">因为他们在定义<a href="http://www.cnpaf.net/">协议</a>早期方面的贡献应该得到特别的赞誉。</span></p>
<p class="p1">    <span class="s1">这篇文档从所有那些分担</span>HTTP-WG<span class="s1">的人员的注释中获得了很大的益处。除了已经提到的那些人以外，下列人士对这个规范做出了贡献：</span><span class="s2"><br>
</span>       Gary Adams                  Ross Patterson<span class="s2"><br>
</span>       Harald Tveit Alvestrand     Albert Lunde<span class="s2"><br>
</span>       Keith Ball                  John C. Mallery<span class="s2"><br>
</span>       Brian Behlendorf            Jean-Philippe Martin-Flatin<span class="s2"><br>
</span>       Paul Burchard               Mitra<span class="s2"><br>
</span>       Maurizio Codogno            David Morris<span class="s2"><br>
</span>       Mike Cowlishaw              Gavin Nicol<span class="s2"><br>
</span>       Roman Czyborra              Bill Perry<span class="s2"><br>
</span>       Michael A. Dolan            Jeffrey Perry<span class="s2"><br>
</span>       David J. Fiander            Scott Powers<span class="s2"><br>
</span>       Alan Freier                 Owen Rees<span class="s2"><br>
</span>       Marc Hedlund                Luigi Rizzo<span class="s2"><br>
</span>       Greg Herlihy                David Robinson<span class="s2"><br>
</span>       Koen Holtman                Marc Salomon<span class="s2"><br>
</span>       Alex Hopmann                Rich Salz<span class="s2"><br>
</span>       Bob Jernigan                Allan M. Schiffman<span class="s2"><br>
</span>       Shel Kaphan                 Jim Seidman<span class="s2"><br>
</span>       Rohit Khare                 Chuck Shotton<span class="s2"><br>
</span>       John Klensin                Eric W. Sink<span class="s2"><br>
</span>       Martijn Koster              Simon E. Spero<span class="s2"><br>
</span>       Alexei Kosut                Richard N. Taylor<span class="s2"><br>
</span>       David M. Kristol            Robert S. Thau<span class="s2"><br>
</span>       Daniel LaLiberte            Bill (BearHeart) Weinman<span class="s2"><br>
</span>       Ben Laurie                  Francois Yergeau<span class="s2"><br>
</span>       Paul J. Leach               Mary Ellen Zurko<span class="s2"><br>
</span>       Daniel DuBois               Josh Cohen</p>
<p class="p1">    <span class="s1">高速缓存设计的许多内容和介绍应归于一下人士的建议和注释：</span>Shel Kaphan,<span class="s2"><br>
</span>Paul Leach, Koen Holtman, David Morris, <span class="s1">和</span> Larry Masinter<span class="s1">。</span></p>
<p class="p1">    <span class="s1">大部分规范的范围是基于</span>Ari Luotonen<span class="s1">和</span>John Franks<span class="s1">早期做的工作，以及从</span>Steve Zilles<span class="s1">另外加入的内容。</span></p>
<p class="p1">    <span class="s1">感谢</span>Palo Alto<span class="s1">的</span>"cave men"<span class="s1">。你们知道你们是谁。</span></p>
<p class="p1">    Jim Gettys<span class="s1">（这篇文档现在的编者）特别希望感谢</span>Roy Fielding<span class="s1">，这篇文档以前的编者，连同</span>John Klensin, Jeff Mogul, Paul Leach, Dave Kristol, Koen Holtman, John Franks, Josh Cohen, Alex Hopmann, Scott Lawrence, <span class="s1">和</span>Larry Masinter<span class="s1">一起感谢他们的帮助。还要特别感谢</span>Jeff Mogul<span class="s1">和</span>Scott Lawrence<span class="s1">对</span>"MUST/MAY/  SHOULD"<span class="s1">使用的检查。</span></p>
<p class="p1">    Apache<span class="s1">组，</span>Anselm Baird-Smith<span class="s1">，</span>Jigsaw<span class="s1">的作者，和</span>Henrik Frystyk<span class="s1">在早期实现了<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a></span> 2068<span class="s1">，我们希望感谢他们发现了许多这篇文档尝试纠正的问题。</span></p>
<p class="p1">17 <span class="s1">参考资料</span> (Reference)</p>
<p class="p1">   [1] Alvestrand, H., "Tags for the Identification of Languages", <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a><span class="s2"><br>
</span>       1766, March 1995.</p>
<p class="p1">   [2] Anklesaria, F., McCahill, M., Lindner, P., Johnson, D., Torrey,<span class="s2"><br>
</span>       D. and B. Alberti, "The Internet Gopher Protocol (a distributed<span class="s2"><br>
</span>       document search and retrieval protocol)", <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 1436, March 1993.</p>
<p class="p1">   [3] Berners-Lee, T., "Universal Resource Identifiers in WWW", <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a><span class="s2"><br>
</span>       1630, June 1994.</p>
<p class="p1">   [4] Berners-Lee, T., Masinter, L. and M. McCahill, "Uniform Resource<span class="s2"><br>
</span>       Locators (URL)", <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 1738, December 1994.</p>
<p class="p1">   [5] Berners-Lee, T. and D. Connolly, "Hypertext Markup Language -<span class="s2"><br>
</span>       2.0", <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 1866, November 1995.</p>
<p class="p1">   [6] Berners-Lee, T., Fielding, R. and H. Frystyk, "Hypertext Transfer<span class="s2"><br>
</span>       Protocol -- HTTP/1.0", <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 1945, May 1996.</p>
<p class="p1">   [7] Freed, N. and N. Borenstein, "Multipurpose Internet Mail<span class="s2"><br>
</span>       Extensions (MIME) Part One: Format of Internet Message Bodies",<span class="s2"><br>
</span>       <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 2045, November 1996.</p>
<p class="p1">   [8] Braden, R., "Requirements for Internet Hosts -- Communication<span class="s2"><br>
</span>       Layers", STD 3, <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 1123, October 1989.</p>
<p class="p1">   [9] Crocker, D., "Standard for The Format of ARPA Internet Text<span class="s2"><br>
</span>       Messages", STD 11, <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 822, August 1982.</p>
<p class="p1">   [10] Davis, F., Kahle, B., Morris, H., Salem, J., Shen, T., Wang, R.,<span class="s2"><br>
</span>        Sui, J., and M. Grinbaum, "WAIS Interface Protocol Prototype<span class="s2"><br>
</span>        Functional Specification," (v1.5), Thinking Machines<span class="s2"><br>
</span>        Corporation, April 1990.</p>
<p class="p1">   [11] Fielding, R., "Relative Uniform Resource Locators", <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 1808,<span class="s2"><br>
</span>        June 1995.</p>
<p class="p1">   [12] Horton, M. and R. Adams, "Standard for Interchange of USENET<span class="s2"><br>
</span>        Messages", <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 1036, December 1987.</p>
<p class="p1">   [13] Kantor, B. and P. Lapsley, "Network News Transfer Protocol", <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a><span class="s2"><br>
</span>        977, February 1986.</p>
<p class="p1">   [14] Moore, K., "MIME (Multipurpose Internet Mail Extensions) Part<span class="s2"><br>
</span>        Three: Message Header Extensions for Non-ASCII Text", <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 2047,<span class="s2"><br>
</span>        November 1996.</p>
<p class="p1">   [15] Nebel, E. and L. Masinter, "Form-based File Upload in HTML", <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a><span class="s2"><br>
</span>        1867, November 1995.</p>
<p class="p1">   [16] Postel, J., "Simple Mail Transfer Protocol", STD 10, <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 821,<span class="s2"><br>
</span>        August 1982.</p>
<p class="p1">   [17] Postel, J., "Media Type Registration Procedure", <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 1590,<span class="s2"><br>
</span>        November 1996.</p>
<p class="p1">   [18] Postel, J. and J. Reynolds, "File Transfer Protocol", STD 9, <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a><span class="s2"><br>
</span>        959, October 1985.</p>
<p class="p1">   [19] Reynolds, J. and J. Postel, "Assigned Numbers", STD 2, <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 1700,<span class="s2"><br>
</span>        October 1994.</p>
<p class="p1">   [20] Sollins, K. and L. Masinter, "Functional Requirements for<span class="s2"><br>
</span>        Uniform Resource Names", <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 1737, December 1994.</p>
<p class="p1">   [21] US-ASCII. Coded Character Set - 7-Bit American Standard Code for<span class="s2"><br>
</span>        Information Interchange. Standard ANSI X3.4-1986, ANSI, 1986.</p>
<p class="p1">   [22] ISO-8859. International Standard -- Information Processing --<span class="s2"><br>
</span>        8-bit Single-Byte Coded Graphic Character Sets --<span class="s2"><br>
</span>        Part 1: Latin alphabet No. 1, ISO-8859-1:1987.<span class="s2"><br>
</span>        Part 2: Latin alphabet No. 2, ISO-8859-2, 1987.<span class="s2"><br>
</span>        Part 3: Latin alphabet No. 3, ISO-8859-3, 1988.<span class="s2"><br>
</span>        Part 4: Latin alphabet No. 4, ISO-8859-4, 1988.<span class="s2"><br>
</span>        Part 5: Latin/Cyrillic alphabet, ISO-8859-5, 1988.<span class="s2"><br>
</span>        Part 6: Latin/Arabic alphabet, ISO-8859-6, 1987.<span class="s2"><br>
</span>        Part 7: Latin/Greek alphabet, ISO-8859-7, 1987.<span class="s2"><br>
</span>        Part 8: Latin/Hebrew alphabet, ISO-8859-8, 1988.<span class="s2"><br>
</span>        Part 9: Latin alphabet No. 5, ISO-8859-9, 1990.</p>
<p class="p1">   [23] Meyers, J. and M. Rose, "The Content-MD5 Header Field", <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a><span class="s2"><br>
</span>        1864, October 1995.</p>
<p class="p1">   [24] Carpenter, B. and Y. Rekhter, "Renumbering Needs Work", <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a><span class="s2"><br>
</span>        1900, February 1996.</p>
<p class="p1">   [25] Deutsch, P., "GZIP file format specification version 4.3", <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a><span class="s2"><br>
</span>        1952, May 1996.</p>
<p class="p1">   [26] Venkata N. Padmanabhan, and Jeffrey C. Mogul. "Improving HTTP<span class="s2"><br>
</span>        Latency", Computer Networks and ISDN Systems, v. 28, pp. 25-35,<span class="s2"><br>
</span>        Dec. 1995. Slightly revised version of paper in Proc. 2nd<span class="s2"><br>
</span>        International WWW Conference '94: Mosaic and the Web, Oct. 1994,<span class="s2"><br>
</span>        which is available at<span class="s2"><br>
</span>        <a href="http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLat">http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLat</a><span class="s2"><br>
</span>        ency.html.</p>
<p class="p1">   [27] Joe Touch, John Heidemann, and Katia Obraczka. "Analysis of HTTP<span class="s2"><br>
</span>        Performance", http://www.isi.edu/touch/pubs/http-perf96/&gt;,<span class="s2"><br>
</span>        ISI Research Report ISI/RR-98-463, (original report dated Aug.<span class="s2"><br>
</span>        1996), USC/Information Sciences Institute, August 1998.</p>
<p class="p1">   [28] Mills, D., "Network Time Protocol (Version 3) Specification,<span class="s2"><br>
</span>        Implementation and Analysis", <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 1305, March 1992.</p>
<p class="p1">   [29] Deutsch, P., "DEFLATE Compressed Data Format Specification<span class="s2"><br>
</span>        version 1.3", <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 1951, May 1996.</p>
<p class="p1">   [30] S. Spero, "Analysis of HTTP Performance Problems,"<span class="s2"><br>
</span>        <a href="http://sunsite.unc.edu/mdma-release/http-prob.html">http://sunsite.unc.edu/mdma-release/http-prob.html</a>.</p>
<p class="p1">   [31] Deutsch, P. and J. Gailly, "ZLIB Compressed Data Format<span class="s2"><br>
</span>        Specification version 3.3", <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 1950, May 1996.</p>
<p class="p1">   [32] Franks, J., Hallam-Baker, P., Hostetler, J., Leach, P.,<span class="s2"><br>
</span>        Luotonen, A., Sink, E. and L. Stewart, "An Extension to HTTP:<span class="s2"><br>
</span>        Digest Access Authentication", <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 2069, January 1997.</p>
<p class="p1">   [33] Fielding, R., Gettys, J., Mogul, J., Frystyk, H. and T.<span class="s2"><br>
</span>        Berners-Lee, "Hypertext Transfer Protocol -- HTTP/1.1", <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a><span class="s2"><br>
</span>        2068, January 1997.</p>
<p class="p1">   [34] Bradner, S., "Key words for use in <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a>s to Indicate Requirement<span class="s2"><br>
</span>        Levels", BCP 14, <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 2119, March 1997.</p>
<p class="p1">   [35] Troost, R. and Dorner, S., "Communicating Presentation<span class="s2"><br>
</span>        Information in Internet Messages: The Content-Disposition<span class="s2"><br>
</span>        Header", <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 1806, June 1995.</p>
<p class="p1">   [36] Mogul, J., Fielding, R., Gettys, J. and H. Frystyk, "Use and<span class="s2"><br>
</span>        Interpretation of HTTP Version Numbers", <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 2145, May 1997.<span class="s2"><br>
</span>        [jg639]</p>
<p class="p1">   [37] Palme, J., "Common Internet Message Headers", <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 2076, February<span class="s2"><br>
</span>        1997. [jg640]</p>
<p class="p1">   [38] Yergeau, F., "UTF-8, a transformation format of Unicode and<span class="s2"><br>
</span>        ISO-10646", <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 2279, January 1998. [jg641]</p>
<p class="p1">   [39] Nielsen, H.F., Gettys, J., Baird-Smith, A., Prud'hommeaux, E.,<span class="s2"><br>
</span>        Lie, H., and C. Lilley. "Network Performance Effects of<span class="s2"><br>
</span>        HTTP/1.1, CSS1, and PNG," Proceedings of ACM SIGCOMM '97, Cannes<span class="s2"><br>
</span>        France, September 1997.[jg642]</p>
<p class="p1">   [40] Freed, N. and N. Borenstein, "Multipurpose Internet Mail<span class="s2"><br>
</span>        Extensions (MIME) Part Two: Media Types", <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 2046, November<span class="s2"><br>
</span>        1996. [jg643]</p>
<p class="p1">   [41] Alvestrand, H., "IETF Policy on Character Sets and Languages",<span class="s2"><br>
</span>        BCP 18, <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 2277, January 1998. [jg644]</p>
<p class="p1">   [42] Berners-Lee, T., Fielding, R. and L. Masinter, "Uniform Resource<span class="s2"><br>
</span>        Identifiers (URI): Generic Syntax and Semantics", <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 2396,<span class="s2"><br>
</span>        August 1998. [jg645]</p>
<p class="p1">   [43] Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,<span class="s2"><br>
</span>        Leach, P., Luotonen, A., Sink, E. and L. Stewart, "HTTP<span class="s2"><br>
</span>        Authentication: Basic and Digest Access Authentication", <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a><span class="s2"><br>
</span>        2617, June 1999. [jg646]</p>
<p class="p1">   [44] Luotonen, A., "Tunneling <a href="http://www.cnpaf.net/class/tcpandip/">TCP</a> based protocols through Web proxy<span class="s2"><br>
</span>        servers," Work in Progress. [jg647]</p>
<p class="p1">   [45] Palme, J. and A. Hopmann, "MIME E-mail Encapsulation of<span class="s2"><br>
</span>        Aggregate Documents, such as HTML (MHTML)", <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 2110, March<span class="s2"><br>
</span>        1997.</p>
<p class="p1">   [46] Bradner, S., "The Internet Standards Process -- Revision 3", BCP<span class="s2"><br>
</span>        9, <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 2026, October 1996.</p>
<p class="p1">   [47] Masinter, L., "Hyper Text Coffee Pot Control Protocol<span class="s2"><br>
</span>        (H<a href="http://www.cnpaf.net/class/tcpandip/">TCP</a>CP/1.0)", <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 2324, 1 April 1998.</p>
<p class="p1">   [48] Freed, N. and N. Borenstein, "Multipurpose Internet Mail<span class="s2"><br>
</span>        Extensions (MIME) Part Five: Conformance Criteria and Examples",<span class="s2"><br>
</span>        <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 2049, November 1996.</p>
<p class="p1">   [49] Troost, R., Dorner, S. and K. Moore, "Communicating Presentation<span class="s2"><br>
</span>        Information in Internet Messages: The Content-Disposition Header<span class="s2"><br>
</span>        Field", <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 2183, August 1997.<span class="s2"><br>
</span><span class="s1">　</span>Copyright  www.cnpaf.net (2007).          All Rights Reserved.</p>
<p class="p2"><span class="s2"><br>
</span><span class="s3">18 </span>作者地址</p>
<p class="p1">   Roy T. Fielding<span class="s2"><br>
</span>   Information and Computer Science<span class="s2"><br>
</span>   University of California, Irvine<span class="s2"><br>
</span>   Irvine, CA 92697-3425, USA</p>
<p class="p1">   Fax: +1 (949) 824-1715<span class="s2"><br>
</span>   EMail: <a href="mailto:fielding@ics.uci.edu">fielding@ics.uci.edu</a></p>
<p class="p1"><span class="s2"><br>
</span>   James Gettys<span class="s2"><br>
</span>   World Wide Web Consortium<span class="s2"><br>
</span>   MIT Laboratory for Computer Science<span class="s2"><br>
</span>   545 Technology Square<span class="s2"><br>
</span>   Cambridge, MA 02139, USA</p>
<p class="p1">   Fax: +1 (617) 258 8682<span class="s2"><br>
</span>   EMail: <a href="mailto:jg@w3.org">jg@w3.org</a></p>
<p class="p1"><span class="s2"><br>
</span>   Jeffrey C. Mogul<span class="s2"><br>
</span>   Western Research Laboratory<span class="s2"><br>
</span>   Compaq Computer Corporation<span class="s2"><br>
</span>   250 University Avenue<span class="s2"><br>
</span>   Palo Alto, California, 94305, USA</p>
<p class="p1">   EMail: <a href="mailto:mogul@wrl.dec.com">mogul@wrl.dec.com</a></p>
<p class="p1"><span class="s2"><br>
</span>   Henrik Frystyk Nielsen<span class="s2"><br>
</span>   World Wide Web Consortium<span class="s2"><br>
</span>   MIT Laboratory for Computer Science<span class="s2"><br>
</span>   545 Technology Square<span class="s2"><br>
</span>   Cambridge, MA 02139, USA</p>
<p class="p1">   Fax: +1 (617) 258 8682<span class="s2"><br>
</span>   EMail: <a href="mailto:frystyk@w3.org">frystyk@w3.org</a></p>
<p class="p1"><span class="s2"><br>
</span>   Larry Masinter<span class="s2"><br>
</span>   Xerox Corporation<span class="s2"><br>
</span>   3333 Coyote Hill Road<span class="s2"><br>
</span>   Palo Alto, CA 94034, USA</p>
<p class="p1">   EMail: <a href="mailto:masinter@parc.xerox.com">masinter@parc.xerox.com</a></p>
<p class="p1"><span class="s2"><br>
</span>   Paul J. Leach<span class="s2"><br>
</span>   Microsoft Corporation<span class="s2"><br>
</span>   1 Microsoft Way<span class="s2"><br>
</span>   Redmond, WA 98052, USA</p>
<p class="p1">   EMail: <a href="mailto:paulle@microsoft.com">paulle@microsoft.com</a></p>
<p class="p1"><span class="s2"><br>
</span>   Tim Berners-Lee<span class="s2"><br>
</span>   Director, World Wide Web Consortium<span class="s2"><br>
</span>   MIT Laboratory for Computer Science<span class="s2"><br>
</span>   545 Technology Square<span class="s2"><br>
</span>   Cambridge, MA 02139, USA</p>
<p class="p1">   Fax: +1 (617) 258 8682<span class="s2"><br>
</span>   EMail: <a href="mailto:timbl@w3.org">timbl@w3.org</a></p>
<p class="p1">19 <span class="s1">附录</span></p>
<p class="p1">19<span class="s1">．</span>1 <span class="s1">互联网媒介类型</span>message/http<span class="s1">和</span>application/http</p>
<p class="p1">     <span class="s1">这篇文档除了定义</span>HTTP/1.1<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a><span class="s1">外，还用作互联网媒介类型</span>"message/http"<span class="s1">和</span>"application/http"<span class="s1">的规范。倘若</span>message/http<span class="s1">类型遵守</span>MIME<span class="s1">对所有</span>"message"<span class="s1">类型关于路径长度和编码的限制，它就可以用来封装单独的</span>HTTP<span class="s1">请求和应答信息。</span>application/http<span class="s1">类型可以用来封装一个或者更多</span>HTTP<span class="s1">请求或应答信息（非混合的）的传输路径。下列是在</span>IANA[17]<span class="s1">注册的。</span><span class="s2"><br>
</span>        <span class="s2"><br>
</span>        <span class="s1">媒介类型名称：</span>    message<span class="s2"><br>
</span>        <span class="s1">媒介次类型名称：</span>  http<span class="s2"><br>
</span>        <span class="s1">必须参数：</span>        <span class="s1">无</span><span class="s2"><br>
</span>        <span class="s1">可选参数：</span>        <span class="s1">版本，信息类型</span><span class="s2"><br>
</span>        <span class="s1">版本：封装信息的</span>HTTP<span class="s1">版本号（例如，</span>"1.1"<span class="s1">）。如果不存在，版本可以从报文的</span>        <span class="s1">第一行确定。</span><span class="s2"><br>
</span>        <span class="s1">信息类型：信息类型</span>--"request"<span class="s1">或者</span>"response"<span class="s1">。如果不存在，类型可以从报文的第一行确定。</span>     <span class="s2"><br>
</span>        <span class="s1">编码考虑：只有</span>"7bit"<span class="s1">，</span>"8bit"<span class="s1">，或者</span>"<span class="s1">二进制</span>"<span class="s1">是允许的。</span><span class="s2"><br>
</span>        <a href="http://www.cnpaf.net/class/security/"><span class="s1">安全</span></a><span class="s1">考虑：无</span></p>
<p class="p1">        <span class="s2"><br>
</span>        <span class="s1">媒介类型名称：</span>    application<span class="s2"><br>
</span>        <span class="s1">媒介次类型名称：</span>  http<span class="s2"><br>
</span>        <span class="s1">必须参数：</span>        <span class="s1">无</span><span class="s2"><br>
</span>        <span class="s1">可选参数：</span>        <span class="s1">版本，信息类型</span><span class="s2"><br>
</span>        <span class="s1">版本：封装信息的</span>HTTP<span class="s1">版本号（例如，</span>"1.1"<span class="s1">）。如果不存在，版本可以从报文的第一行确定。</span><span class="s2"><br>
</span>        <span class="s1">信息类型：信息类型</span>--"request"<span class="s1">或者</span>"response"<span class="s1">。如果不存在，类型可以从报文的第一行确定。</span>     <span class="s2"><br>
</span>        <span class="s1">编码考虑：用这种类型封装的</span>HTTP<span class="s1">信息是</span>"<span class="s1">二进制</span>"<span class="s1">的格式；当通过</span>E-mail<span class="s1">传递的时候一种合适的内容传输编码是必须的。</span><span class="s2"><br>
</span>        <a href="http://www.cnpaf.net/class/security/"><span class="s1">安全</span></a><span class="s1">考虑：无</span>        </p>
<p class="p2"><span class="s3">19</span>．<span class="s3">2 </span>互联网媒介类型<span class="s3">multipart/byteranges</span><span class="s2"><br>
</span><span class="s3">     </span>当一个<span class="s3">HTTP206</span>（部分内容）应答信息包括很大范围的内容（对于大范围非重叠的请求的应答），这些是作为一个<span class="s3">multipart</span>信息报文传的。这种用途的媒介类型被称作<span class="s3">"multipart/byteranges"</span>。</p>
<p class="p2"><span class="s3">    multipart/byteranges</span>媒介类型包括两个或者更多的部分，每一个都有自己内容类型和内容范围的域。必需的分界参数指定了用来分开每个报文部分的分界字符串。</p>
<p class="p1">        <span class="s1">媒介类型名称：</span>    multipart<span class="s2"><br>
</span>        <span class="s1">媒介次类型名称：</span>  byteranges<span class="s2"><br>
</span>        <span class="s1">必须参数：</span>        boundary<span class="s2"><br>
</span>        <span class="s1">可选参数：</span>        <span class="s1">无</span><span class="s2"><br>
</span>        <span class="s1">编码考虑：只有</span>"7bit"<span class="s1">，</span>"8bit"<span class="s1">，或者</span>"<span class="s1">二进制</span>"<span class="s1">是允许的。</span><span class="s2"><br>
</span>        <a href="http://www.cnpaf.net/class/security/"><span class="s1">安全</span></a><span class="s1">考虑：无</span>        </p>
<p class="p1">    <span class="s1">例如：</span><span class="s2"><br>
</span>    HTTP/1.1 206<span class="s1">部分内容</span><span class="s2"><br>
</span>   Date: Wed, 15 Nov 1995 06:25:24 GMT<span class="s2"><br>
</span>   Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT<span class="s2"><br>
</span>   Content-type:multipart/byteranges;boundary=THIS_STRING_SEPARATES</p>
<p class="p1">   --THIS_STRING_SEPARATES<span class="s2"><br>
</span>   Content-type: application/pdf<span class="s2"><br>
</span>   Content-range: bytes 500-999/8000</p>
<p class="p1">   ...<span class="s1">第一部分</span>...<span class="s2"><br>
</span>   --THIS_STRING_SEPARATES<span class="s2"><br>
</span>   Content-type: application/pdf<span class="s2"><br>
</span>   Content-range: bytes 7000-7999/8000</p>
<p class="p1">   ...<span class="s1">第二部分</span><span class="s2"><br>
</span>   --THIS_STRING_SEPARATES--</p>
<p class="p2"><span class="s3">   </span>注解：<span class="s2"><br>
</span><span class="s3">   1</span>）附加的<span class="s3">CRLFs</span>在报文中可以优先于第一个分界字符串。<span class="s2"><br>
</span><span class="s3">   2</span>）虽然<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 2046 [40]</span>允许分界字符串被应用，但是一些现有的程序对引用的分界字符串会进行错误的处理。<span class="s2"><br>
</span><span class="s3">   3</span>）许多浏览器和服务器是按照使用<span class="s3">multipart/x-byteranges</span>媒介类型的<span class="s3">byteranges</span>规范的早期草案编码的，这个草案总是但不完全和<span class="s3">HTTP/1.1</span>中描述的版本兼容。</p>
<p class="p1">19<span class="s1">．</span>3 <span class="s1">宽容的应用程序</span> (Tolerent Applications)</p>
<p class="p2"><span class="s3">     </span>虽然这篇文档列出了<span class="s3">HTTP/1.1</span>这一代消息所必须的元素，但是并不是所有的程序在实现的时候都是正确的。因此我们建议当偏差可以明确解释的时候操作程序对这种偏差应该是宽容的。</p>
<p class="p2"><span class="s3">    </span>客户机在<a href="http://www.cnpaf.net/">分析</a>状态行的时候应该（<span class="s3">SHOULD</span>）是宽容的并且服务器在<a href="http://www.cnpaf.net/">分析</a>请求行的时候也是（应该）是宽容的。特别的，甚至在域之间只需要一个<span class="s3">SP</span>的时候，他们也应该（<span class="s3">SHOULD</span>）接收任意数量的<span class="s3">SP</span>或者<span class="s3">HT</span>字符。</p>
<p class="p2"><span class="s3">    </span>消息报头域的结束行是顺序<span class="s3">CRLF</span>。然而我们建议在解析这样的报头的时候，程序应该接受单个的<span class="s3">LF</span>作为一行的结束并忽略第一位的<span class="s3">CR</span>。</p>
<p class="p2"><span class="s3">    </span>一个实体正文的特征设置应该（<span class="s3">SHOULD</span>）分成基本的类并用那个报文中的特征代码来命名，除非无分类实体的优先级比用<span class="s3">US-ASCII</span>或<span class="s3">ISO-8859-1</span>分类的实体高。见<span class="s3">3.7.1</span>和<span class="s3">3.4.1</span>。</p>
<p class="p2"><span class="s3">    </span>对关于时间的<a href="http://www.cnpaf.net/">分析</a>和编码以及时间编码的其它潜在问题的需要的附加规则包括：<span class="s2"><br>
</span><span class="s3">    --HTTP/1.1</span>客户机和高速缓存应该（<span class="s3">SHOULD</span>）假定一个似乎是<span class="s3">50</span>多年以后的<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3">-850</span>日期实际上是过去的（这有助于解决<span class="s3">"2000</span>年<span class="s3">"</span>问题）。</p>
<p class="p2"><span class="s3">    </span>一个<span class="s3">HTTP/1.1</span>的实现可以（<span class="s3">MAY</span>）在内部表现为<a href="http://www.cnpaf.net/">分析</a>完成时间比正确日期更早，但是一定不要（<span class="s3">MUST NOT</span>）在内部表现为<a href="http://www.cnpaf.net/">分析</a>完成时间比正确日期更晚。</p>
<p class="p2"><span class="s3">    --</span>所有与结束时间有关的计算必须（<span class="s3">MUST</span>）用格林尼治时间。本地市区一定不能（<span class="s3">MUST NOT</span>）影响年龄或完成时间的计算和比较。</p>
<p class="p2"><span class="s3">    --</span>如果一个<span class="s3">HTTP</span>报头不正确的携带了一个格林尼治时间以外其它市区的时间，它必须（<span class="s3">MUST</span>）用所有可能中最保守的方法转换成格林尼治时间。</p>
<p class="p1">19<span class="s1">．</span>4 HTTP<span class="s1">实体和<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a></span> 2045<span class="s1">实体之间的区别</span></p>
<p class="p2"><span class="s3">    HTTP/1.1</span>使用了许多为网际邮件（<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 822 [9]</span>）和多用途网际邮件扩充（<span class="s3">MIME [7]</span>）定义的允许在一个开放的表现多样的环境中用扩展的机制传输实体的结构。不论如何，<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 2045</span>讨论邮件，<span class="s3">HTTP</span>有一些功能部件和<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 2045</span>中描述的不同。这些不同被小心地挑选出来优化二进制连接的性能，允许使用新媒介类型有更大的灵活性，是时间比较更容易，并且承认一些早期<span class="s3">HTTP</span>服务器和客户机的规则。</p>
<p class="p2"><span class="s3">    </span>这个附录描述了<span class="s3">HTTP</span>和<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 2045</span>不同的特殊区域。在严格的<span class="s3">MIME</span>环境中的代理服务器和网关应该（<span class="s3">SHOULD</span>）意识到这些不同并且在必要的地方提供这种转换。从<span class="s3">MIME</span>环境到<span class="s3">HTTP</span>的代理服务器和网管也需要意识到这些不同因为一些转换可能是需要的。</p>
<p class="p1">19.4.1 MIME<span class="s1">版本</span></p>
<p class="p2"><span class="s3">    HTTP</span>不是一个遵守<span class="s3">MIME</span>的<a href="http://www.cnpaf.net/">协议</a>。然而<span class="s3">HTTP/1.1</span>消息可以（<span class="s3">MAY</span>）包括单个<span class="s3">MIME</span>版本的普通报头域来指出构造这个消息使用的<span class="s3">MIME<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>的版本。</p>
<p class="p2"><span class="s3">    MIME</span>版本的报头域的使用表明这个消息是完全遵守<span class="s3">MIME<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>的（<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 2045[7]</span>定义的）。在输出<span class="s3">HTTP</span>消息到严格<span class="s3">MIME</span>环境的时候代理服务器<span class="s3">/</span>网关有责任确保（在可能的地方）完全匹配。</p>
<p class="p1">       MIME-Version   = "MIME-Version" ":" 1*DIGIT "." 1*DIGIT</p>
<p class="p2"><span class="s3">    </span>在<span class="s3">HTTP/1.1</span>用的缺省值是<span class="s3">MIME1.0</span>版本。然而，<span class="s3">HTTP/1.1</span>消息的<a href="http://www.cnpaf.net/">分析</a>和语义是由这篇文档而不是<span class="s3">MIME</span>规范定义的。</p>
<p class="p1">19.4.2 <span class="s1">转换到规范形式</span></p>
<p class="p2"><span class="s3">    <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 2045 [7]</span>需要网际通信实体在传输以前先转换成规范形式，就像在<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 2049 [48]</span>第<span class="s3">4</span>部分中描述的那样。这篇文档的<span class="s3">3.7.1</span>节描述了当用<span class="s3">HTTP</span>传输时允许使用的<span class="s3">"</span>文本<span class="s3">"</span>媒介的次<a href="http://www.cnpaf.net/">协议</a>的形式。<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 2046</span>需要关于<span class="s3">"</span>文本<span class="s3">"</span>类型的内容就像<span class="s3">CRLF</span>一样代表行间隔符并禁止在行间隔符序列以外使用<span class="s3">CR</span>或者<span class="s3">LF</span>。<span class="s3">HTTP</span>允许<span class="s3">CRLF</span>，单独的<span class="s3">CR</span>，和单独的<span class="s3">LF</span>来指出在一个消息用<span class="s3">HTTP</span>传输的时候文本内容里的行间隔符。</p>
<p class="p2">在可能的地方，从<span class="s3">HTTP</span>到严格的<span class="s3">MIME</span>环境的代理服务器或者网关应该（<span class="s3">SHOULD</span>）把本文档<span class="s3">3.7.1</span>节描述的文本媒介类型里的所有行间隔符翻译成<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 2049 CRLF</span>的规范形式。然而注意当出现内容的编码以及<span class="s3">HTTP</span>允许使用一些不用八位组的<span class="s3">13</span>和<span class="s3">10</span>表示<span class="s3">CR</span>和<span class="s3">LF</span>的特殊设置的实际，就像一些多位组的特殊设置的情况，这可能是复杂的。</p>
<p class="p2"><span class="s3">    </span>使用者应该注意转换将会破坏任何用于原内容的密码校验和，除非原内容已经是规范形式。因此，对任何在<span class="s3">HTTP</span>中使用这种校验和的内容建议表示为规范形式。</p>
<p class="p1">19.4.3 <span class="s1">日期格式的转换</span></p>
<p class="p2"><span class="s3">    </span>为了简化日期比较的过程<span class="s3">HTTP/1.1</span>使用了一种限定的日期格式设置。从其它<a href="http://www.cnpaf.net/">协议</a>过来的代理服务器河网馆应该（<span class="s3">SHOULD</span>）确保消息里现在的任何日期报头域符合一种<span class="s3">HTTP/1.1</span>的格式，如果必要的话重写日期。</p>
<p class="p1">19.4.4 <span class="s1">内容编码的介绍</span></p>
<p class="p2"><span class="s3">    <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 2045</span>不包括任何相当于<span class="s3">HTTP/1.1</span>的内容编码报头域的概念。既然从<span class="s3">HTTP</span>到服从<span class="s3">MIME<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>的代理和网关作为媒介类型的修正者，它就必须（<span class="s3">MUST</span>）改变内容类型报头域的值或者在向前传送消息以前解码实体正文。（一些网际通信内容类型的试验程序已经使用了媒介类型参数<span class="s3">";conversions="</span>来实现等效于媒介编码的功能。不管怎样，这个参数不是<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 2045</span>的一部分。）</p>
<p class="p1">19.4.5 <span class="s1">无内容传输编码</span></p>
<p class="p1">    HTTP<span class="s1">不使用<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a></span> 2045<span class="s1">的内容传输编码（</span>CTE<span class="s1">）。从使用</span>MIME<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a><span class="s1">到</span>HTTP<span class="s1">的代理和网关必须（</span>MUST<span class="s1">）在把应答信息传给</span>HTTP<span class="s1">客户机之前删除任何非实体</span>CTE<span class="s1">（</span>"quoted-printable"<span class="s1">或</span>"base64"<span class="s1">）编码。</span></p>
<p class="p2"><span class="s3">    </span>从<span class="s3">HTTP</span>到使用<span class="s3">MIME<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>的代理和网关有责任确保信息对那个<a href="http://www.cnpaf.net/">协议</a>来说是用正确的格式和编码在<a href="http://www.cnpaf.net/class/security/">安全</a>的传输，在那<span class="s3">"<a href="http://www.cnpaf.net/class/security/"><span class="s1">安全</span></a></span>传输<span class="s3">"</span>的定义是由使用的<a href="http://www.cnpaf.net/">协议</a>的限制给出的。如果分类将提高用目标<a href="http://www.cnpaf.net/">协议</a><a href="http://www.cnpaf.net/class/security/">安全</a>传输的可能，代理或网关就应该（<span class="s3">SHOULD</span>）用合适的内容传输编码对数据进行分类。</p>
<p class="p1">19.4.6 <span class="s1">传输编码的介绍</span></p>
<p class="p2"><span class="s3">    HTTP/1.1</span>介绍了传输编码报头域（<span class="s3">14.41</span>节）。代理<span class="s3">/</span>网关必须（<span class="s3">MUST</span>）在（经过）使用<span class="s3">MIME<a href="http://www.cnpaf.net/"><span class="s1">协议</span></a></span>（的网段）向前传递消息以前删除任何传输编码。</p>
<p class="p1">    <span class="s1">一个解码</span>"chunked"<span class="s1">传输代码（</span>3.6<span class="s1">节）的程序可以用假代码表示如下：</span><span class="s2"><br>
</span>       length := 0<span class="s2"><br>
</span>       read chunk-size, chunk-extension (if any) and CRLF<span class="s2"><br>
</span>       while (chunk-size &gt; 0) {<span class="s2"><br>
</span>          read chunk-data and CRLF<span class="s2"><br>
</span>          append chunk-data to entity-body<span class="s2"><br>
</span>          length := length + chunk-size<span class="s2"><br>
</span>          read chunk-size and CRLF<span class="s2"><br>
</span>       }<span class="s2"><br>
</span>       read entity-header<span class="s2"><br>
</span>       while (entity-header not empty) {<span class="s2"><br>
</span>          append entity-header to existing header fields<span class="s2"><br>
</span>          read entity-header<span class="s2"><br>
</span>       }<span class="s2"><br>
</span>       Content-Length := length<span class="s2"><br>
</span>       Remove "chunked" from Transfer-Encoding</p>
<p class="p1">19.4.7 MHTML<span class="s1">和行长度限制</span></p>
<p class="p2"><span class="s3">    </span>和<span class="s3">MHTML</span>程序共享代码的<span class="s3">HTTP</span>程序需要了解<span class="s3">MIME</span>行长度限制。既然<span class="s3">HTTP</span>没有这个限制，<span class="s3">HTTP</span>并不压缩长的行。用<span class="s3">HTTP</span>传输的<span class="s3">MHTML</span>消息遵守所有<span class="s3">MHTML</span>的规定，包括行长度的限制和压缩，规范化等，既然<span class="s3">HTTP</span>传输所有作为有效载荷的消息实体（见<span class="s3">3.7.2</span>节）并且不说明内容或任何可能包括在那的<span class="s3">MIME</span>报头行。</p>
<p class="p1">19.5 <span class="s1">其它特点</span></p>
<p class="p2"><span class="s3">    <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 1945</span>和<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 2068</span>记录了一些现有的对<span class="s3">HTTP</span>的实现所用到的<a href="http://www.cnpaf.net/">协议</a>原理，但是对于大多数软件既不兼容也不正确。他们中的一些描述了计划的实验的特征，一些描述了被发现缺少建立在<span class="s3">HTTP/1.1</span>规范基础上的地址的实验部署的特征。</p>
<p class="p2"><span class="s3">    </span>许多从<a href="http://www.cnpaf.net/class/smtp/"><span class="s3">SMTP</span></a>和<span class="s3">MIME</span>来的其它的报头，例如内容处理和标题，也经常实现（见<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 2076 [37]</span>）。</p>
<p class="p1">19.5.1 <span class="s1">内容处理</span></p>
<p class="p2"><span class="s3">    </span>内容处理应答报头已经被计划为一种如果用户请求把内容存成一个文件原服务器提供一个缺身文件名的方法。这种用法来自<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 1806 [35]</span>的定义。</p>
<p class="p1">        content-disposition = "Content-Disposition" ":"<span class="s2"><br>
</span>                              disposition-type *( ";" disposition-parm )<span class="s2"><br>
</span>        disposition-type = "attachment" | disp-extension-token<span class="s2"><br>
</span>        disposition-parm = filename-parm | disp-extension-parm<span class="s2"><br>
</span>        filename-parm = "filename" "=" quoted-string<span class="s2"><br>
</span>        disp-extension-token = token<span class="s2"><br>
</span>        disp-extension-parm = token "=" ( token | quoted-string )</p>
<p class="p2"><span class="s3">    </span>一个例子是：</p>
<p class="p1">      Content-Disposition: attachment; filename="fname.ext"</p>
<p class="p2"><span class="s3">    </span>接收用户的代理不应该（<span class="s3">SHOULD NOT</span>）注意任何在文件名的参数中出现的文件路径信息，这个参数被认为仅仅是一个在这一次申请应用<span class="s3">HTTP</span>的参数。文件名应该（<span class="s3">SHOULD</span>）只被当作终端的一部分。</p>
<p class="p2"><span class="s3">    </span>如果在应答中用到的报头有程序<span class="s3">/</span>八位字节流内容类型，这暗示用户代理不应该现实应答（信息），而直接开始应答<span class="s3">...'dialog</span>。</p>
<p class="p2"><span class="s3">    </span>见<span class="s3">15.5</span>节内容处理的<a href="http://www.cnpaf.net/class/security/">安全</a>问题。</p>
<p class="p2"><span class="s3">19.6 </span>和以前版本的兼容</p>
<p class="p2"><span class="s3">    </span>要求和以前的版本的兼容超出了<a href="http://www.cnpaf.net/">协议</a>规范的范围。然而<span class="s3">HTTP/1.1</span>有意设计成很容易支持以前的版本。在写这份规范的时候，值的记录下我们希望商业化的<span class="s3">HTTP/1.1</span>服务器是：</p>
<p class="p1">      --<span class="s1">接受</span>HTTP/0.9,1.0<span class="s1">和</span>1.1<span class="s1">请求的请求行格式；</span><span class="s2"><br>
</span>      --<span class="s1">懂得</span>HTTP/0.9,1.0<span class="s1">或</span>1.1<span class="s1">格式中的任何有效请求；</span><span class="s2"><br>
</span>      --<span class="s1">恰当地用客户机使用的主要版本回复信息。</span></p>
<p class="p1">    <span class="s1">并且我们希望</span>HTTP/1.1<span class="s1">的客户机：</span></p>
<p class="p1">      --<span class="s1">接受</span>HTTP/1.0<span class="s1">和</span>1.1<span class="s1">应答的状态行格式；</span><span class="s2"><br>
</span>      --<span class="s1">懂得</span>HTTP/0.9,1.0<span class="s1">或</span>1.1<span class="s1">的格式中任何有效的应答。</span><span class="s2"><br>
</span>    <span class="s2"><br>
</span>    <span class="s1">对大多数</span>HTTP/1.0<span class="s1">的实现，每一个连接的建立是通过客户机先发出请求在服务器应答后关闭。一些实现了在<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a></span> 2068 [33]<span class="s1">的</span>19.7.1<span class="s1">节描述的</span>Keep-Alive<span class="s1">的牢固连接的版本。</span></p>
<p class="p1">19.6.1 <span class="s1">对</span>HTTP/1.0<span class="s1">的改变</span></p>
<p class="p1">    <span class="s1">这一部分总结</span>HTTP/1.0<span class="s1">和</span>HTTP/1.1<span class="s1">之间主要的区别。</span></p>
<p class="p2"><span class="s3">19.6.1.1 </span>对简单的多主机<span class="s3">web</span>服务器和保留<span class="s3">IP</span>地址的改变</p>
<p class="p2"><span class="s3">    </span>客户机和服务器支持主机请求报头<span class="s3">,</span>如果主机的<span class="s3">HTTP/1.1</span>请求的请求报头（<span class="s3">14.23</span>节）不存在就报告出错，并且接受绝对的<span class="s3">URIs</span>（<span class="s3">5.1.2</span>节）是本规范定义的最重要的改变。<span class="s2"><br>
</span><span class="s3">    </span><span class="s2"><br>
</span><span class="s3">    </span>老的<span class="s3">HTTP/1.0</span>客户机假定<span class="s3">IP</span>地址和服务器是一对一的关系。没有其它确定的机制区别有意对服务器的请求和直接对<span class="s3">IP</span>地址的请求。一旦老的<span class="s3">HTTP</span>客户疾步在普遍上文概述的改变将允许互联网支持一个<span class="s3">IP</span>地址多重<span class="s3">WEB</span>站点，极大简化了对<span class="s3">WEB</span>服务器的控制，对一个主机分配多个<span class="s3">IP</span>地址已经导致严重的问题。互联网也能从新获得已经分配给用在顶层<span class="s3">HTTP URLs</span>只单独为了某个特殊用途的域名的<span class="s3">IP</span>地址。给定<span class="s3">WEB</span>增加的速度，已经配置的服务器的数量，所有对<span class="s3">HTTP</span>的实现（包括对现有<span class="s3">HTTP/1.0</span>的程序的升级）正确的实现这些要求是非常重要的：</p>
<p class="p2"><span class="s3">    --</span>客户机和服务器都必须（<span class="s3">MUST</span>）支持主机请求报头。<span class="s2"><br>
</span><span class="s3">    --</span>发送<span class="s3">HTTP/1.1</span>请求的客户机必须（<span class="s3">MUST</span>）发送主机报头。<span class="s2"><br>
</span><span class="s3">    --</span>如果<span class="s3">HTTP/1.1</span>请求不包括主机请求报头服务器就必须（<span class="s3">MUST</span>）报告错误<span class="s3">400</span>（<span class="s3">Bad Request</span>）。<span class="s2"><br>
</span><span class="s3">    --</span>服务器必须（<span class="s3">MUST</span>）接受完全<span class="s3">URIs</span>。</p>
<p class="p1">19.6.2 <span class="s1">和</span>HTTP/1.0<span class="s1">持续连接的兼容</span></p>
<p class="p2"><span class="s3">    </span>一些客户机和服务器可能希望和一些对以前实现<span class="s3">HTTP/1.0</span>持续连接的客户机和服务器兼容。单个持续连接不是缺省的行为的时候，它就被明确的越过。<span class="s3">HTTP/1.0</span>持续连接的实验性实现是有缺陷的，在<span class="s3">HTTP/1.1</span>中设计新的简单的来纠正这些问题。问题是一些现有的<span class="s3">1.0</span>客户机可能发送<span class="s3">Keep-Alive</span>给一个不明白这种连接的代理服务器，那么就错误地将它传向下一个接收服务器，它将建立一个<span class="s3">Keep-Alive</span>连接并导致一个挂着的<span class="s3">HTTP/1.0</span>代理等待关闭的应答。结果是<span class="s3">HTTP/1.0</span>客户机必须禁止使用<span class="s3">Keep-Alive</span>和代理交谈。</p>
<p class="p2"><span class="s3">    </span>然而，和代理交谈是持续连接最重要的用处，所以禁止很明显是无法接受的。因此，我们需要一些其它的机制来表明渴望持续连接，甚至当和一个忽略<span class="s3">Connection</span>的老代理交谈这样使用也是<a href="http://www.cnpaf.net/class/security/">安全</a>的。对<span class="s3">HTTP/1. 0</span>消息持续连接是缺省的<span class="s3">;</span>我们引入一个新的关键字<span class="s3">(Connection: close)</span>来申明非持续。见<span class="s3">14.10</span>节。<span class="s3">  </span><span class="s2"><br>
</span><span class="s3">    </span>原始的持续连接<span class="s3">HTTP/1.0</span>的形式（<span class="s3">the Connection: Keep-Alive and Keep-Alive header</span>）记录在<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 2068 [33]</span>。</p>
<p class="p2"><span class="s3">19.6.3 </span>对<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 2068</span>的改变<span class="s2"><br>
</span><span class="s3">    </span>这篇规范已经被仔细的审查来纠正关键字的用法和消除它们的歧义；<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 2068</span>在遵守<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 2119 [34] </span>制定的协定方面有很多问题。</p>
<p class="p2"><span class="s3">    </span>澄清哪个错误代码将会使入站服务器失灵（例如<a href="http://www.cnpaf.net/class/dns/"><span class="s3">DNS</span></a>失灵）。（<span class="s3">10.5.5</span>节）</p>
<p class="p2"><span class="s3">    CREATE</span>有一个特点当一份资料第一次创建的时候他必须发送一个<span class="s3">Etag</span>。（<span class="s3">10.2.2</span>节<span class="s3">)</span></p>
<p class="p2"><span class="s3">    </span>从规范中删除了内容基：它无法广泛的实现，并且除了精力充沛的扩展机制以外没有简单，<a href="http://www.cnpaf.net/class/security/">安全</a>的方法把它引入。此外它以类似但不一样的方式在<span class="s3">MHTML [45] </span>中使用。</p>
<p class="p2"><span class="s3">    </span>传输译码和消息长度以当使用<span class="s3">chunked</span>编码（允许传输自己不划界的编码）需要正确匹配的方式相互影响；正确的弄清如何计算消息长度是重要的。（<span class="s3">3.6,4.4,7.2.2,13.5.2,14.13,14.16</span>节）</p>
<p class="p2"><span class="s2"><br>
</span><span class="s3">    </span>引入<span class="s3">"</span>身份<span class="s3">"</span>的内容译码来解决高速缓存中发现的问题。（<span class="s3">3.5</span>节）</p>
<p class="p2"><span class="s3">    </span>零值的性质应该表明<span class="s3">"</span>我什么都不想要<span class="s3">"</span>以允许客户机拒绝请求。（<span class="s3">3.9</span>节）</p>
<p class="p2"><span class="s3">    <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a> 2145</span>已经澄清了<span class="s3">HTTP</span>版本号的使用和解释。需要代理升级他们为了处理在实现<span class="s3">HTTP/1.0</span>中发现的问题而要求支持的最高<a href="http://www.cnpaf.net/">协议</a>版本。（<span class="s3">3.1</span>节）</p>
<p class="p2"><span class="s3">    </span>统配符字符设置的引入是为了避免在接受报头的性质设置名称的激增。（<span class="s3">14.2</span>节）</p>
<p class="p1">    HTTP/1.1<span class="s1">的高速缓存控制模式中的一种情况被遗漏了；引入</span>s-maxage<span class="s1">是为了补充这种情况。（</span>13.4<span class="s1">，</span>14.8<span class="s1">，</span>14.9<span class="s1">，</span>14.9.3<span class="s1">节）</span></p>
<p class="p2"><span class="s3">    </span>高速缓存控制：为了应答而定义的最大生存时间指标是不恰当的。（<span class="s3">14.9.3</span>节）</p>
<p class="p2"><span class="s3">    </span>有服务器（尤其是代理）不知道应答的全部长度但仍可以应答比特流请求的情况。我们因此需要一个机制允许内容范围并不指示消息全部长度的比特流。</p>
<p class="p2"><span class="s3">    </span>如果总是回复所有的<span class="s3">meta-data</span>范围请求应答将变得非常冗长；通过允许服务器在<span class="s3">206</span>应答中只发送必要的报头，这个问题能够避免。（<span class="s3">10.2.7,13.5.3,</span>和<span class="s3">14.27</span>节）</p>
<p class="p2"><span class="s3">    </span>解决不能满足请求范围的问题；有两种情况：语法问题<span class="s3">,</span>以及范围在文档中不存在。需要状态<span class="s3">416</span>代码确定这种模糊，它必须指出一个超出文档实际内容的比特请求范围错误。<span class="s3"> (10.4.17, 14.16</span>节<span class="s3">)</span></p>
<p class="p2"><span class="s3">    </span>消息传输重写的需要使得明白错误的事先更加困难，因为这里错误的结果对互联网有重大的影响，要应付下列问题：</p>
<p class="p1">    1.<span class="s1">把</span>"HTTP/1.1<span class="s1">或以后的版本</span>"<span class="s1">变成</span>"HTTP/1.1"<span class="s1">，这不适当的设置了对未来</span>HTTP/1.x<span class="s1">版本实现行为的要求。</span></p>
<p class="p2"><span class="s3">    2.</span>一般是用户代理而不是客户机应该重发请求这一点要清楚。</p>
<p class="p2"><span class="s3">    3.</span>把对客户机忽略不希望的<span class="s3">100</span>（以后）应答，以及对代理转发应答<span class="s3">100</span>的要求变为对应答<span class="s3">1xx</span>的一般要求。</p>
<p class="p2"><span class="s3">    4.</span>修改一些特殊<a href="http://www.cnpaf.net/class/tcpandip/"><span class="s3">TCP</span></a>语言，使得<span class="s3">HTTP</span>可以用非<a href="http://www.cnpaf.net/class/tcpandip/"><span class="s3">TCP</span></a>传输这一点更清楚。</p>
<p class="p2"><span class="s3">    5.</span>要求原服务器在发送必须的应答<span class="s3">100(</span>扩展<span class="s3">)</span>之前一定不要（<span class="s3">MUST NOT</span>）等待请求主体。</p>
<p class="p2"><span class="s3">    6.</span>如果服务器已经看见一些请求主体，允许，不是必须，它忽略<span class="s3">100</span>（扩展）。</p>
<p class="p2"><span class="s3">    7.</span>允许服务器防范拒绝服务攻击和被控制的客户机。</p>
<p class="p1">    <span class="s1">这个变化增加了期待的报头和状态</span>417<span class="s1">代码。消息传输要求的修改在</span>8.2<span class="s1">，</span>, 10.4.18<span class="s1">，</span>8.1.2.2, 13.11, <span class="s1">和</span>14.20<span class="s1">节。</span></p>
<p class="p2"><span class="s3">    </span>代理应该可以在适当的时候增加内容的长度。（<span class="s3">13.5.2</span>节）</p>
<p class="p1">    <span class="s1">整理应答</span>403<span class="s1">和</span>404<span class="s1">之间的混乱。（</span>10.4.4, 10.4.5, <span class="s1">和</span>10.4.11<span class="s1">节）</span></p>
<p class="p2"><span class="s3">    </span>警告可能被错误的隐藏起来，或者没有得到适当的纠正。（<span class="s3">13.1.2, 13.2.4, 13.5.2, 13.5.3, 14.9.3, </span>和<span class="s3">14.46</span>节）警告也需要有一个普通的报头，因为<span class="s3">PUT</span>或其它命令可能需要它。<span class="s2"><br>
</span><span class="s3">    </span><span class="s2"><br>
</span><span class="s3">    </span>传输译码有重要的问题，特别是由于用<span class="s3">chunked</span>编码的交互作用。解决的办法是把传输译码变得和内容译码一样快速。这涉及到给传输译码增加一个<span class="s3">IANA</span>注册（从内容译码中分离），一个新的报头域（<span class="s3">TE</span>）和未来授权跟踪报头。传输编码性能有很主要的好处，所以修改它是值得的。<span class="s3">TE</span>也解决其它的，不太明显的，因为跟踪认证，<span class="s3">chunked</span>编码和<span class="s3">HTTP/1.0</span>客户机之间相互作用而出现的向下兼容的问题。（<span class="s3">3.6, 3.6.1, </span>和<span class="s3">14.39</span>节）</p>
<p class="p2"><span class="s3">    </span>补丁，连接，解除连接的方法在这份规范以前的版本中定义过但不能一般的实现。见<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 2068 [33]</span>。</p>
<p class="p2"><span class="s3">    </span>变化，内容版本，源，连接，<span class="s3">URI</span>，公开和内容基报头域在这份规范以前的版本中定义过，但不能一般地实现。见<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a><span class="s3"> 2068 [33]</span>。</p>
<p class="p1">20 <span class="s1">索引</span> (Index)</p>
<p class="p2"><span class="s3">    </span>参见这份<a href="http://www.cnpaf.net/class/RfcAll/"><span class="s3">RFC</span></a>对索引的后记部分。</p>
<p class="p2"><span class="s3">21 </span>全部版权声明</p>
<p class="p1">    <span class="s1">版权所有（</span>C<span class="s1">）</span>INTERNET SOCIETY<span class="s1">（</span>1999<span class="s1">）。保留所有权利（</span>All rights reserved)<span class="s1">。</span></p>
<p class="p2"><span class="s3">    </span>如果所有的复制和派生工作包括上面的版权声明和这一段，那么这篇文档和它的翻译就可以拷贝并提供给其他人，就可以准备，复制，出版和发行，全部或者部分，注释或其它的解释或在它的实现中的帮助等派生工作，而没有任何的限制。然而，无论如何这篇文档本身不能被修改，例如删除版权声明或<span class="s3">INTERNET SOCIETY</span>及其它互联网组织的参考数目，除非为了发展互联网标准的目的，在这种情况下互联网标准进程定义的版权程序必须得到遵守，或者需要把它翻译成英语之外的语言。</p>
<p class="p2"><span class="s3">    </span>上面准许的有限许可是永久的并且不会被<span class="s3">INTERNET SOCIETY</span>或者它的后继组织或分支机构撤回。</p>
<p class="p2"><span class="s3">    </span>这篇文档和里面包含的内容是在<span class="s3">"AS IS"</span>的基础上并且<span class="s3">INTERNET SOCIETY</span>和<span class="s3">INTERNET ENGINEERING TASK FORCE</span>放弃所有的理由，明确的或者暗指的，包括但不限于任何使用这里的信息将不会破坏任何的权利理由或任何商业或适当的特殊目的的隐含的理由。</p>
<p class="p1"><span class="s1">感谢</span>(Acknowledgment)<span class="s2"><br>
</span>    <span class="s2"><br>
</span>    <a href="http://www.cnpaf.net/class/RfcAll/">RFC</a><span class="s1">编辑活动的资金由</span>Internet Society<span class="s1">提供。</span><span class="s2"><br>
</span><span class="s1">　</span>Copyright  www.cnpaf.net (2007).          All Rights Reserved.</p>
</body>
</html>
