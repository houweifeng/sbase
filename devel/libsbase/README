
  libsbase是一个对服务, 线程, 连接等与业务逻辑无关的封装, 可以用于服务端和客户端的网络应用开发.

    sbase包括服务管理(service), 线程管理(procthread), 连接管理(connection), 采用libevbase(类似libevent)的网络IO读写通知模式, 对业务逻辑数据的处理采用消息队列(message_queue)的方式运行, 每个连接(connection)可以定义独立的会话特性(SESSION), 附着与连接上的业务逻辑采用回调的方式执行, 具体的回调函数封装于session内.

typedef struct _SESSION
{
    /* packet */
    int  packet_type;
    int  packet_length;
    char *packet_delimiter;
    int  packet_delimiter_length;
    int  buffer_size;

    /* methods */
    /* 当连接发生读写错误或者对端断开的时候 用于错误处理 */
    int (*error_handler)(struct _CONN *, CB_DATA *packet, CB_DATA *cache, CB_DATA *chunk);
    /* 从连接的数据buffer区内读取数据头 */
    int (*packet_reader)(struct _CONN *, CB_DATA *buffer);
    /* 数据头被读取后的处理 */
    int (*packet_handler)(struct _CONN *, CB_DATA *packet);
    /* 数据头之外的数据处理 */
    int (*data_handler)(struct _CONN *, CB_DATA *packet, CB_DATA *cache, CB_DATA *chunk);
    /* 接受完的文件处理 */
    int (*file_handler)(struct _CONN *, CB_DATA *packet, CB_DATA *cache);
    /* 带外数据处理 */
    int (*oob_handler)(struct _CONN *, CB_DATA *oob);
    /* 超时处理(需要通过conn->set_timeout()) */
    int (*timeout_handler)(struct _CONN *, CB_DATA *packet, CB_DATA *cache, CB_DATA *chunk);
    /* 事务处理(需要通过service->new_transaction()注册事务 )*/
    int (*transaction_handler)(struct _CONN *, int tid);
}SESSION;

  sbase总体结构 sbase->services[] service->procthreads[] procthread->connections[]
  sbase 可以同时运行多个service (sbase->add_service()).
  sbase主线程负责管理所有service下的监听端口的文件描数字, 如果sbase通过libevbase发现有fd可读会通知service下的成员负责accept操作和添加新连接操作.
typedef struct _SBASE
{
    /* base option */
    /* 多进程模式下进程数 */
    int nchilds;
    /* 连接数限制 */
    int connections_limit;
    /* while 循环usleep的微妙数 */
    int usec_sleep;
    /* 运行状态 1 为运行 0 为停止 */
    int running_status;
    /* libevbse */
    EVBASE *evbase;
    /* services[] 列表 */
    struct _SERVICE **services;
    /* 当前运行service个数 */
    int running_services;
    /* 心跳计数 */
    long long nheartbeat;

    /* timer && logger */
    void *logger;
    void *timer;

    /* evtimer 超时检查器 */
    void *evtimer;

    /* message queue for proc mode 多进程模式下的消息队列 */
    void *message_queue;

    int  (*set_log)(struct _SBASE *, char *);
    int  (*set_evlog)(struct _SBASE *, char *);
    
    /* 添加服务 service需要通过service_init() 初始化以后 */
    int  (*add_service)(struct _SBASE *, struct _SERVICE *);    
    /* 运行sbase下的所有服务 */
    int  (*running)(struct _SBASE *, int time_usec);
    /* 停止sbase下的所有服务 */
    void (*stop)(struct _SBASE *);
    void (*clean)(struct _SBASE **);
}SBASE;

  
  service 负责管理服务下的所有线程以及连接, service本身不参与主循环的工作, service只是接受sbase的调用以及连接(connection)的调用, 与service相关的业务逻辑都是运行在service->procthreads[]线程之上, 另外任务(task)运行在service->daemons[]线程之上. service之上的所有连接根据文件描数字(fd)散列到procthreads[]之上. 
typedef struct _SERVICE
{
    /* global */
    /* service下所有线程运行usleep 微妙数*/
    int usec_sleep;
    /* sbase指针 */
    SBASE *sbase;
    /* service下所有线程访问service公共资源的锁 */
    void *mutex;

    /* heartbeat */
    /* running heartbeat_handler when looped hearbeat_interval times 心跳间隔 */
    int heartbeat_interval;
    void *heartbeat_arg;
    /* 心跳回调 */
    CALLBACK *heartbeat_handler;
    /* 设置服务心跳心跳控制由sbase->evtimer完成 */
    void (*set_heartbeat)(struct _SERVICE *, int interval, CALLBACK *handler, void *arg);
    /* 心跳操作激活 会调用service->hearbeat_handler()  */
    void (*active_heartbeat)(struct _SERVICE *);

    /* working mode 运行模式*/
    int working_mode;
    /* 多进程模式下使用 */
    struct _PROCTHREAD *daemon;
    /* 线程数 */
    int nprocthreads;
    /* 连接所在线程池 */
    struct _PROCTHREAD **procthreads;
    /* 后台线程个数 */
    int ndaemons;
    /* 用于task的后台线程池, 可选择是否用, 如果ndaemons为0表示不用 */
    struct _PROCTHREAD **daemons;


    /* socket and inet addr option  网络连接或本地监听相关的参数 */
    int family;
    int sock_type;
    struct  sockaddr_in sa;
    char *ip;
    int port;
    int fd;
    int backlog;

    /* service option 服务运行相关 */
    int service_type;
    char *service_name;
    /* 设置服务包括本地监听设置, 初始化远程连接参数 */
    int  (*set)(struct _SERVICE *service);
    /* 运行服务, 初始化线程 */
    int  (*run)(struct _SERVICE *service);
    /* 停止服务 */
    void (*stop)(struct _SERVICE *service);

    /* event option libevbase 相关 */
    EVBASE *evbase;
    EVENT *event;

    /* message queue for proc mode 多进程模式下的消息队列, 等同sbase->message_queue */
    void *message_queue;

    /* connections option 连接相关参数 */
    /* 连接数限制 */
    int connections_limit;
    /* 当前connecions位置最大值 */
    int index_max;
    /* 当前运行连接总数 */
    int running_connections;
    /* service下的所有连接列表 用于统一管理连接 */
    struct _CONN **connections;
    /* C_SERVICE ONLY 客户端服务操作方法 */
    /* 客户端连接数 */
    int client_connections_limit;
    /* 发起新连接 */
    struct _CONN *(*newconn)(struct _SERVICE *service, int inet_family, int sock_type,
            char *ip, int port, SESSION *session);
    /* 添加新连接 */
    struct _CONN *(*addconn)(struct _SERVICE *service, int sock_type, int fd,
            char *remote_ip, int remote_port, char *local_ip, int local_port, SESSION *);
    /* 获取空闲连接 */
    struct _CONN *(*getconn)(struct _SERVICE *service);
    /* 添加正常正确的连接到service->connecions */
    int     (*pushconn)(struct _SERVICE *service, struct _CONN *conn);
    /* 从service->connections 删除指定连接 */
    int     (*popconn)(struct _SERVICE *service, struct _CONN *conn);
    /* evtimer 超时检查器 */
    void *evtimer;
    int evid;

    /* timer and logger */
    void *timer;
    void *logger;
    int  is_inside_logger;
    int (*set_log)(struct _SERVICE *service, char *logfile);

    /* transaction and task */
    int ntask;
    /* 运行新任务 任务运行散列通过ntask散列到service->daemons[]之上 */
    int (*newtask)(struct _SERVICE *, CALLBACK *, void *arg);
    /* 在指定连接上执行事务 通过conn->index定位service->connections[] 上 */
    int (*newtransaction)(struct _SERVICE *, struct _CONN *, int tid);

    /* service default session option 设置服务默认业务逻辑的会话参数 */
    SESSION session;
    int (*set_session)(struct _SERVICE *, SESSION *);

    /* clean */
    void (*clean)(struct _SERVICE **pservice);

}SERVICE;

编译安装:

homepage : http://sbase.googlecode.com

install :
./configure --enable-debug
make 

test & demo :

./src/lechod -c doc/rc.lechod.ini 

required libevbase 0.0.14 from http://sbase.googlecode.com/files/libevbase-0.0.14.tar.gz

NOTE: if you want to build rpm , look doc/libsbase.spec



